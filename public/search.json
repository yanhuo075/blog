[{"title":"Typora+Github+PicGo搭建个人免费图床","path":"/2025/06/09/2025/06/Typora-Github-PicGo/","content":"一、配置GitHub1、新建公开仓库1.1、New repository 1.2、定义仓库名称，设置公开属性 2、创建私人令牌（token）2.1、个人头像 – Settings 2.2、左侧列底部点击 Developer settings 2.3、选择 Generate new token (classic) 依此点击 Personal access tokens – Tokens(classic) – Generate new token – Generate new token(classic) 2.4、密码验证 2.5、创建令牌 Note：标记作用，任意写 Token 过期时间：为了安全性，不建议选择永久 访问权限：选择repo，对私有库享有完全控制 2.6、记事本记下token 二、配置PicGo1、PicGo下载地址MolunerfinnPicGo 依据自身的操作系统下载安装软件包 2、图床设置 图床设置 – GitHub 3、具体图床参数配置 3.1、图床配置名当前图床的名称，自定义 3.2、设定仓库名 格式：用户名仓库名 可以通过GitHub上创建仓库页的域名快速得到 bash # 例如我这边的仓库名就是misakivv/Cloud-Image-Hosting 3.3、设定分支名 默认情况下均为 main 分支 3.4、设定Token上面 一、2.6、保存的Token 3.5、设定存储路径存放至 Github 指定仓库的哪个文件夹下 如果直接放到仓库的根目录下就不需要填写这一栏 如果需要放到某个目录下，格式： 当填写的目录不存在时，Github会自动创建对应目录 3.6、设定自定义域名 这里使用免费的CDN：jsDelivr 官网链接：jsDelivr - A free, fast, and reliable CDN for JS and open source bash # https://cdn.jsdelivr.net/gh/：固定的前缀，相当于替换掉了Github地址中的https://github.com/# user：Github上的用户名# repo：仓库名# @version：版本号（这里我们可以不管）# file：文件名（这里我们也不需要加上，因为上传完图片后，它会自动将上传的图片的名字作为存储的文件名）# 例如我这里的填写https://cdn.jsdelivr.net/gh/misakivv/Cloud-Image-Hosting 这里值得注意的是，如果需要指定上传到哪个分支，此时需要在自定义域名后面使用@ + 分支名，如果是仓库默认的分支，可以省略指定分支这一步。 eg：我需要上传到 k8s 分支上，此时自定义域名就变成了：https://cdn.jsdelivr.net/gh/misakivv/Cloud-Image-Hosting@k8s 三、测试上述配置完成后即可上传本地图片生成对应云端平台链接使用 1、本地上传图片 上传区 – 选择GitHub图床 – 点击上传 2、相册查看 3、时间戳重命名 添加时间戳命名选项可以避免上传相同图片被覆盖的情况 四、Typora插入图片实现自动上传至PicGo（可选） 需要将PicGo图床的链接格式换成Markdonw格式才能实现功能 1、打开 Typora 偏好设置 ctrl + , 快捷键 2、插入图片选项选择上传图片 3、上传服务设定 上传服务选择 PicGo（app） PicGo 路径为安装 PicGo 目录","tags":["主题装修"],"categories":["装修日记"]},{"title":"Hello World","path":"/2025/06/09/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new My New Post More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","tags":["标签云"],"categories":["测试"]},{"title":"Hexo-Stellar主题装修日记(一)","path":"/2025/06/09/2025/06/theme-design1/","content":"前言记录一下自己从默认主题样式到现在本网站的样子中间都修改了哪些地方，也作为完善博客期间的备份。 博客引用资源本地资源文件夹将头像、图标、css、js等文件放在source下 静态资源本地化有两次发现通过jsdelivr引入的静态资源会失效，为了网站的稳定性，决定将所有通过jsdelivr引入的静态资源保存到本地，防止失效后网站无法访问。 引用落霞孤鹜字体tale/_config.ymlinject: head: - link rel=stylesheet href=https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css media=print onload=this.media=all #字体Copytale/_config.stellar.ymlstyle: font-family: body: LXGW WenKai Screen, sans-serifCopy 引用鸿蒙字体tale/_config.ymlinject: head: - link rel=preconnect href=https://s1.hdslb.com/ / - link rel=stylesheet href=//s1.hdslb.com/bfs/static/jinkela/long/font/regular.css media=all onload=this.media=all / #鸿蒙正常字体 - link rel=stylesheet href=//s1.hdslb.com/bfs/static/jinkela/long/font/medium.css media=all onload=this.media=all / #鸿蒙加粗字体Copytale/_config.stellar.ymlstyle: font-family: body: HarmonyOS_Regular # 鸿蒙正常字体 #body: HarmonyOS_Regular # 鸿蒙加粗字体Copy 博客基本配置基本信息tale/_config.yml# Sitetitle: SFZhang #网站名称avatar: /customize/images/sfzhang.jpg #博客头像favicon: /customize/images/sfzhang.jpg #网站图标subtitle: SFZhangs blog | blog.sfzhang.cn #鼠标移入翻转效果description: 一个积极生活的人keywords:author: SFZhang #博客作者language: zh-CN #博客语言：en、zh-CNtimezone: Copy 显示导航tale/_config.stellar.ymlsidebar: menu: post: [btn.blog](/) wiki: [btn.wiki](/) friends: [友链](/) about: [关于](/)Copy 图片放大（fancybox）其中selector设置为需要放大图片的HTML选择器： tale/_config.ymltag_plugins: # % image % image: fancybox: true # true, false parse_markdown: true # 把 markdown 格式的图片解析成图片标签######## JS Plugins ########plugins: # https://fancyapps.com/docs/ui/fancybox/ # available for % image xxx % fancybox: enable: true #js: /customize/js/fancybox.umd.js css: /customize/css/fancybox.css js: https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js #css: https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css # 可以处理评论区的图片（不支持 iframe 类评论系统）例如： # 使用twikoo评论可以写: .tk-content img:not([class*=emo]) # 使用waline评论可以写: #waline_container .vcontent img selector: .swiper-slide img, .md-text.content pimg, .md-text.content li img , .wl-content img, .image-bg img # 多个选择器用英文逗号隔开 #selector: .swiper-slide img # 多个选择器用英文逗号隔开Copy 侧边栏侧边栏底部按钮tale/_config.stellar.ymlfooter: social: QQ: icon: img src=/customize/svg/contact.svg/ url: https://wpa.qq.com/msgrd?v=3uin=1119716380site=qqmenu=yesjumpflag=1 github: icon: img src=/customize/svg/github.svg/ url: https://github.com/z23654262 #iconfont: # icon: img src=/customize/svg/iconfont.svg/ # url: https://www.iconfont.cn/ unsplash: icon: img src=/customize/svg/unsplash.svg/ url: https://unsplash.com/@z23654262 train: icon: img src=/customize/svg/train.svg/ url: https://unsplash.com/@z23654262 Moon: icon: img id=ThemeM src=/customize/svg/moon.svg/ url: javaScript:void(永夜); Sun: icon: img id=ThemeL src=/customize/svg/sun.svg/ url: javaScript:void(永昼); #AI: # icon: img id=ThemeAI src=/customize/svg/auto.svg/ # url: javaScript:void(跟随系统);Copy 小组件tale/source/_data/widget,ymlwelcome: layout: markdown title: 欢迎来到SFZhang的知识库 content: | 不以物喜，不以己悲 script src=https://v1.hitokoto.cn/?c=iencode=jsselect=%23hitokoto defer=/script p一诗：span id=hitokoto/span/pyiyan: layout: markdown title: 一诗 content: | script src=https://v1.hitokoto.cn/?c=iencode=jsselect=%23hitokoto defer=/script pspan id=hitokoto/span/ptimeline: layout: timeline title: 生活碎片 api: https://api.github.com/repos/z23654262/blog-life/issues?per_page=10 # 若你想限制数量，在api链接后面加上?per_page=1指限制为1条 user: # 是否过滤只显示某个人发布的内容，如果要筛选多人，用英文逗号隔开 hide: # title,footer # 隐藏标题或底部 # 此功能需要 Stellar v1.13.0ghuser: layout: ghuser username: z23654262 # your github login username avatar: true # show avatar or not menu: true # show menu or not#搜索search_blog: layout: search filter: /blog/ # or /posts/ ... placeholder: 文章搜索search_all_docs: layout: search filter: /wiki/ placeholder: 文档系统搜索search_docs: layout: search filter: auto placeholder: 文档内搜索Copy 生活碎片添加页面添加首页按钮tale/_config.stellar.ymlpost-index: # 近期发布 分类 标签 归档 and ... 生活碎片: /lifeCopy 导航高亮问题tale/node_modules/hexo-theme-stellar/layout/_partial/main/navbar/list_post.ejsif (full_url_for(page.path) == full_url_for(obj[key]))Copy 修改为 tale/node_modules/hexo-theme-stellar/layout/_partial/main/navbar/list_post.ejsif (full_url_for(page.path) == full_url_for(obj[key]) + /index.html)Copy 新建github仓库并添加一条issue 编辑生活碎片页面tale/source/life/index.md---title: menu_id: post #侧边栏首页高亮breadcrumb: false # 隐藏面包屑导航post_list: true # 显示首页导航date: 2023-10-10 10:34:34---% note color:orange 分享自己的生活碎片！ %% timeline api:https://api.github.com/repos/z23654262/blog-life/issues?direction=ascper_page=30 %% endtimeline %Copy 预览生活碎片页面 添加评论系统giscus新增github仓库新增blog-comments仓库并开启Discussions功能并勾选blog-commentsSettingsFeaturesDiscussions即可。 修改配置tale/_config.stellar.ymlcomments: service: giscus # giscus # https://giscus.app/zh-CN giscus: data-repo: xxx/xxx # [在此输入仓库] data-repo-id: # [在此输入仓库 ID] data-category: # [在此输入分类名] data-category-id: data-mapping: pathname data-strict: 0 data-reactions-enabled: 1 data-emit-metadata: 0 data-input-position: top # top, bottom data-theme: preferred_color_scheme data-lang: zh-CN data-loading: lazy crossorigin: anonymousCopy 测试giscus评论系统博客内评论： github仓库中Discussions： 添加waline评论系统waline官方教程 waline程序托管于vercel，数据存储使用learncloud国际版，域名使用waline.sfzhang.top二级域名 learncloud国际版设置 登录 或 注册 LeanCloud 国际版 并进入 控制台 点击左上角创建应用并起一个你喜欢的名字 (请选择免费的开发版) 进入应用，选择左下角的 设置 应用 Key。你可以看到你的 APP ID,APP Key 和 Master Key。请记录它们，以便后续使用。 vercel设置 点击Vercel，跳转至 Vercel 进行 Server 端部署。（如果登录无法访问github，则使用邮箱登录） 跳转后会自动机遇waline仓库进行初始化，只需要填写Vercel仓库名称即可。 点击顶部的 Settings - Environment Variables 进入环境变量配置页，并配置三个环境变量 LEAN_ID, LEAN_KEY 和 LEAN_MASTER_KEY 。它们的值分别对应上一步在 LeanCloud 中获得的 APP ID, APP KEY, Master Key。 环境变量配置完成之后点击顶部的 Deployments 点击顶部最新的一次部署右侧的 Redeploy 按钮进行重新部署。该步骤是为了让刚才设置的环境变量生效。 此时会跳转到 Overview 界面开始部署，等待片刻后 STATUS 会变成 Ready。此时请点击 Visit ，即可跳转到部署好的网站地址，此地址即为你的服务端地址。 Vercel绑定域名 点击顶部的 Settings - Domains 进入域名配置页，并输入需要绑定的域名 在阿里云处配置域名解析 博客配置文件tale/_config.staller.yml######## Comments ########comments: service: waline # beaudar, utterances, giscus, twikoo, waline, artalk # Waline # https://waline.js.org/ waline: js: https://unpkg.com/@waline/client@2.14.1/dist/waline.js css: https://unpkg.com/@waline/client@2.14.1/dist/waline.css # Waline server address url, you should set this to your own link serverURL: https://domain # If false, comment count will only be displayed in post page, not in home page commentCount: true # Pageviews count, Note: You should not enable both `waline.pageview` and `leancloud_visitors`. pageview: false # Custom emoji # emoji: # - https://unpkg.com/@waline/emojis@1.1.0/weibo # - https://unpkg.com/@waline/emojis@1.1.0/alus # - https://unpkg.com/@waline/emojis@1.1.0/bilibili # - https://unpkg.com/@waline/emojis@1.1.0/qq # - https://unpkg.com/@waline/emojis@1.1.0/tieba # - https://unpkg.com/@waline/emojis@1.1.0/tw-emoji # - https://unpkg.com/@waline/emojis@1.1.0/bmoji # 设置自己的图床服务，替换默认的 Base 64 编码嵌入（有体积大小限制），在评论中上传图片更加方便 # imageUploader: # 适配了兰空图床V1、V2版本 # 以兰空图床V1为例，下列填写内容为： # fileName: file # tokenName: Authorization # api: https://xxxxxx/api/v1/upload # token: Bearer xxxxxxxxxxxxxx # resp: data.links.url # 以兰空图床V2为例，下列填写内容为： # fileName: image # tokenName: token # api: https://xxxxxx/api/upload # token: xxxxxxxxxxxxxx # resp: data.url # fileName: # 根据版本二选一 # tokenName: # 根据版本二选一 # api: # 图床 api 地址 # token: # 图床验证 # resp: # 图片地址返回值的字段","tags":["主题装修"],"categories":["装修日记"]},{"title":"Hexo-Stellar主题装修日记(二)","path":"/2025/06/09/2025/06/theme-design2/","content":"给超长代码块增加滚动条#首先判断代码块是否过长，如果是，则设置最大高度并开启滚动。 新建 source/js/adjust-codeblock-height.js，添加以下内容： adjust-code-block-height.js document.addEventListener(DOMContentLoaded, function() // 选择所有的.md-text元素 var codeBlocks = document.querySelectorAll(.md-text); // 遍历每个.md-text元素 codeBlocks.forEach(function(block) // 检查是否包含.highlight类的子元素，且父元素高度超过500px var highlightBlocks = block.querySelectorAll(.highlight); highlightBlocks.forEach(function(highlightBlock) if (highlightBlock.clientHeight 800) highlightBlock.style.maxHeight = 300px; highlightBlock.style.overflow = auto; ); ); ); 以上代码代表如果代码框高度超过 800px，则开启折叠，折叠框最大高度为 300px。其中，可自行设置判断阈值 if (highlightBlock.clientHeight 800) 以及折叠后最大高度 highlightBlock.style.maxHeight = 300px;。 雪花特效#代码来自这里。我稍微做了一点修改，做成了一个按钮引入到主题中并用 localStorage 记录下雪状态，很简单的代码完美的解决了我的强迫症～ 博客已运行x天x小时x分钟#在网站页脚部分添加一个“博客已运行 x 天 x 小时 x 分钟”字样，显示效果： ![勉强运行x天x小时x分钟x秒](Hexo-Stellar主题装修二CleanShot 2024-04-16 at 21.51.07@2x-1749438579838-1030.webp)勉强运行x天x小时x分钟x秒 代码抄自这里，我为了调整样式加了一行代码 。在 _config.stellar.yml 里添加如下代码，其中 span class=runtime 中的类名 runtime 可自行设置。 footer: ... content: | # 支持 Markdown 格式 span id=runtime_span/span script type=text/javascript function show_runtime() window.setTimeout(show_runtime(), 1000); X = new Date(2024/01/01 17:00:00); // 网站开始运行的日期和时间 Y = new Date(); // 当前日期和时间 T = (Y.getTime() - X.getTime()); // 网站运行的总毫秒数 M = 24 * 60 * 60 * 1000; // 一天的毫秒数 a = T / M; // 总天数 A = Math.floor(a); // 总天数的整数部分 b = (a - A) * 24; // 总小时数 B = Math.floor(b); // 总小时数的整数部分 c = (b - B) * 60; // 总分钟数 C = Math.floor((b - B) * 60); // 总分钟数的整数部分 D = Math.floor((c - C) * 60); // 总秒数 runtime_span.innerHTML = ⏱️勉强运行 span class=runtime + A + 天 + B + 小时 + C + 分 + D + 秒/span; show_runtime(); /script 再在自定义的 css 文件里添加以下代码，其中 color 可设置为主题色 var(--theme-link) 或自行设置： .runtime font-weight: bold; color: #7F84A7; 页脚增加猫猫图片#显示效果： ![img](Hexo-Stellar主题装修二CleanShot 2024-04-17 at 19.09.44@2x-1749438579838-1034.webp) 首先，如果是使用本地图片，将图片上传到主题的资源文件夹，比如 source/asset/posts/keyboard.png 然后在主题配置文件的 _config.stellar.yml 中添加： footer: ... content: | # 支持 Markdown 格式 img src=/你的/图片/路径.png alt=描述文字 style=float: right; width: 60px; margin-left: 20px; 其中 float: right 限定图片右对齐，width:60px 限制图片大小，可自行调整。 外部链接后面显示图标#显示效果： ![外部链接图标](Hexo-Stellar主题装修二CleanShot 2024-04-16 at 22.09.38@2x-1749438579838-1038.webp)外部链接图标 方法一： WARNING 老方法依赖 cheerio 模块，可行，但似乎会带来一些网站加载过慢的问题，我现在已经开心地转用新方法了，把老方法摆在这里全当（水）记（字）录（数）。 新建 themes/stellar/scripts/filters/link-icon.js 文件，增加以下代码： //使用 cheerio 模块在文章中的外部链接后添加一个小图标：npm i cheerio --savehexo.extend.filter.register(after_render:html, function(html, data) const cheerio = require(cheerio); const $ = cheerio.load(html, decodeEntities: false); // 只选择article class=md-text content元素内的a标签 $(article.md-text.content a, footer.page-footer.footnote a).each(function() const link = $(this); const href = link.attr(href); //排除一些特殊的链接 if (!link.parents(div.tag-plugin.users-wrap).length !link.parents(div.tag-plugin.sites-wrap).length !link.parent(div.tag-plugin.ghcard).length !link.parents(div.tag-plugin.link.dis-select).length !link.parents(div.tag-plugin.colorful.note).length !link.parents(div.social-wrap.dis-select).length) // 确保链接的 href 属性存在，并检查其是否以 http 或 / 开头 if (href (href.startsWith(http) || href.startsWith(/))) link.html(link.html() + ` span style=white-space: nowrap;svg width=.7em height=.7em viewBox=0 0 21 21 xmlns=http://www.w3.org/2000/svgpath d=m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z fill=currentColor /path d=M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z fill=currentColor/svg/span`); //link.attr(target, _blank); // 可选：确保链接在新标签页打开 ); return $.html(); ); 方法二： TIP 用老方法配置完我总觉得使用 Cheerio 模块后会导致网站加载过慢，就又优化了一下。询问 ChatGPT 得知可以考虑不使用 Node.js 的服务器端处理，而是使用纯前端的方法来达到同样的效果，通过在客户端 JavaScript 中添加代码来实现类似的功能，而不是在 Hexo 的后端渲染过程中处理。（好了，可以卸载 cheerio 了） 下面的这段代码可以在页面加载完成后运行，它会查找指定元素中的链接，并在这些链接后添加一个图标。这种方法的好处是，它不需要服务端的处理，所有操作都在用户的浏览器内完成，可以减少服务器负担，并且避免可能因服务器端渲染引起的加载问题。此外，这种方法也提供了更好的用户体验，因为它不会延迟页面内容的显示。 新建source/js/link-icon.js 文件，填入以下内容： document.addEventListener(DOMContentLoaded, function () console.log(Document is ready.); const links = document.querySelectorAll(article.md-text.content a, footer.page-footer.footnote a); console.log(Links found:, links.length); links.forEach(function(link) console.log(Processing link:, link.href); const parentClasses = [tag-plugin.users-wrap, tag-plugin.sites-wrap, tag-plugin.ghcard, tag-plugin.link.dis-select, tag-plugin.colorful.note, social-wrap.dis-select]; let skip = false; parentClasses.forEach(pc = if (link.closest(`div.$pc`)) skip = true; console.log(Skipping link due to parent class:, pc); ); if (!skip) const href = link.getAttribute(href); console.log(Link href:, href); if (href (href.startsWith(http) || href.startsWith(/))) link.innerHTML += ` span style=white-space: nowrap;svg width=.7em height=.7em viewBox=0 0 21 21 xmlns=http://www.w3.org/2000/svgpath d=m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z fill=currentColor /path d=M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z fill=currentColor/svg/span`; console.log(Icon added to link:, link.innerHTML); );); 这里做了两个筛选： const parentClasses = [tag-plugin.users-wrap, tag-plugin.sites-wrap, tag-plugin.ghcard, tag-plugin.link.dis-select, tag-plugin.colorful.note, social-wrap.dis-select]; 是被排除的类，可自行增减； if (href (href.startsWith(http) || href.startsWith(/))) 判断链接是否以 http 或 / 开头，如果不想给站内链接添加图标的话可以把后面的筛选条件去掉。 然后在主题文件 _config.stellar.yml 中引入： inject: head: ... - script src=/js/link-icon.js/script # 链接图标 增加参与讨论按钮#代码抄自星日语，最新主题已自带此功能。 适配 Obsidian Callouts 标注块语法#显示效果： ![img](Hexo-Stellar主题装修二CleanShot 2024-04-16 at 22.23.51@2x-1749438579838-1036.webp) 暗黑模式下的显示效果： ![img](Hexo-Stellar主题装修二CleanShot 2024-04-16 at 22.24.19@2x-1749438579839-1040.webp) 参考了 Hexo 博客适配 Obsidian 新语法，基础的设置请参考此链接。我暂时用不上其他功能，就把 callout 的样式搬来并做了一些修改。我个人还挺喜欢这个 callout 样式，比 quote 要好看而且添加也很方便，主要是可以和 Obsidian 打通，嘿嘿。 样式修改#原版的 callouts 标注块样式间距太大，我在此基础上改了 callout_blocks_common.css（不是很懂，写得很烂……但是能用）： :root--callout-note:68,138,255;--callout-abstract:0,176,255;--callout-info:0,184,212;--callout-tip:0,191,165;--callout-success:8,185,78;--callout-question:224,172,0;--callout-warning:255,145,0;--callout-failure:255,82,82;--callout-danger:255,23,68;--callout-bug:245,0,87;--callout-example:124,77,255;--callout-quote:158,158,158;--callout-radius:6px;--callout-border-opacity:0.5;--callout-title-bg-opacity:0.08.callout-fold:beforealign-self:center;content:url(data:image/svg+xml;charset=utf-8,svg xmlns=http://www.w3.org/2000/svg width=16 height=16 viewBox=0 0 24 24 fill=none stroke=gray stroke-width=2 stroke-linecap=round stroke-linejoin=round class=chevron-downpath d=m6 9 6 6 6-6//svg).callout-folddisplay:flex;transform:rotate(-90deg);transition:.5s cubic-bezier(.075,.82,.165,1).custom-callout[open]summary.callout-foldtransform:rotate(0deg).custom-calloutsummaryborder-top-left-radius:var(--callout-radius);border-top-right-radius:var(--callout-radius);cursor:pointer;margin:0;padding:0.5rem 1rem.custom-calloutsummary::markercontent:.custom-calloutsummary:beforemargin-right:.5rem.custom-calloutsummary::-webkit-details-markerdisplay:none.callout-title--fsp: calc(17px - 1px);font-size: var(--fsp);display:flex;justify-content:space-between;font-weight:bold;.custom-callout.callout-bodybackground:transparent!important;border-left:none;margin:0!important;padding:.3rem 1rem;position:relative.custom-callout.callout-bodyp--fsp: calc(17px - 1px);font-size: var(--fsp);margin:8px 0.custom-callout.callout-bodypremargin:1.25rem -1rem.custom-callout.callout-bodypre:first-childmargin-top:-.75rem.custom-callout.callout-bodypre:last-childmargin-bottom:-.75rem.custom-callout.note,.custom-callout.seealsoborder-color:rgba(var(--callout-note),var(--callout-border-opacity)).custom-callout.notesummary,.custom-callout.seealsosummary background-color:rgba(var(--callout-note),var(--callout-title-bg-opacity)); color:rgba(var(var(--callout-note))).custom-callout.abstract,.custom-callout.summary,.custom-callout.tldrborder-color:rgba(var(--callout-abstract),var(--callout-border-opacity)).custom-callout.abstractsummary,.custom-callout.summarysummary,.custom-callout.tldrsummary background-color:rgba(var(--callout-abstract),var(--callout-title-bg-opacity)); color:rgba(var(--callout-abstract)).custom-callout.info,.custom-callout.todoborder-color:rgba(var(--callout-info),var(--callout-border-opacity)).custom-callout.infosummary,.custom-callout.todosummary background-color:rgba(var(--callout-info),var(--callout-title-bg-opacity)); color:rgba(var(--callout-info)).custom-callout.hint,.custom-callout.important,.custom-callout.tipborder-color:rgba(var(--callout-tip),var(--callout-border-opacity)).custom-callout.hintsummary,.custom-callout.importantsummary,.custom-callout.tipsummary background-color:rgba(var(--callout-tip),var(--callout-title-bg-opacity)); color:rgba(var(--callout-tip)).custom-callout.check,.custom-callout.done,.custom-callout.successborder-color:rgba(var(--callout-success),var(--callout-border-opacity)).custom-callout.checksummary,.custom-callout.donesummary,.custom-callout.successsummary background-color:rgba(var(--callout-success),var(--callout-title-bg-opacity)); color:rgba(var(--callout-success)).custom-callout.faq,.custom-callout.help,.custom-callout.questionborder-color:rgba(var(--callout-question),var(--callout-border-opacity)).custom-callout.faqsummary,.custom-callout.helpsummary,.custom-callout.questionsummary background-color:rgba(var(--callout-question),var(--callout-title-bg-opacity)); color:rgba(var(--callout-question)).custom-callout.attention,.custom-callout.caution,.custom-callout.warningborder-color:rgba(var(--callout-warning),var(--callout-border-opacity)).custom-callout.attentionsummary,.custom-callout.cautionsummary,.custom-callout.warningsummary background-color:rgba(var(--callout-warning),var(--callout-title-bg-opacity)); color:rgba(var(--callout-warning)).custom-callout.fail,.custom-callout.failure,.custom-callout.missingborder-color:rgba(var(--callout-failure),var(--callout-border-opacity)).custom-callout.failsummary,.custom-callout.failuresummary,.custom-callout.missingsummary background-color:rgba(var(--callout-failure),var(--callout-title-bg-opacity)); color:rgba(var(--callout-failure)).custom-callout.danger,.custom-callout.errorborder-color:rgba(var(--callout-danger),var(--callout-border-opacity)).custom-callout.dangersummary,.custom-callout.errorsummary background-color:rgba(var(--callout-danger),var(--callout-title-bg-opacity)); color:rgba(var(--callout-danger)).custom-callout.bugborder-color:rgba(var(--callout-bug),var(--callout-border-opacity)).custom-callout.bugsummary background-color:rgba(var(--callout-bug),var(--callout-title-bg-opacity)); color:rgba(var(--callout-bug)).custom-callout.exampleborder-color:rgba(var(--callout-example),var(--callout-border-opacity)).custom-callout.examplesummary background-color:rgba(var(--callout-example),var(--callout-title-bg-opacity)); color:rgba(var(--callout-example)).custom-callout.cite,.custom-callout.quoteborder-color:rgba(var(--callout-quote),var(--callout-border-opacity)).custom-callout.citesummary,.custom-callout.quotesummary background-color:rgba(var(--callout-quote),var(--callout-title-bg-opacity)); color:rgba(var(--callout-quote)).callout-title.callout-icon+div-webkit-box-flex:1;-ms-flex:1 1 0%;-webkit-flex:1 1 0%;flex:1 1 0%;margin-left:.25rem.callout-iconalign-items:center;color:#000;display:flex.callout-icon:beforeheight:20px;width:20px.custom-callout.attention.callout-title.callout-icon:before,.custom-callout.caution.callout-title.callout-icon:before,.custom-callout.warning.callout-title.callout-icon:beforecontent:url(data:image/svg+xml;charset=utf-8,svg xmlns=http://www.w3.org/2000/svg width=20 height=20 viewBox=0 0 24 24 fill=none stroke=%23FF9100 stroke-width=2 stroke-linecap=round stroke-linejoin=round class=svg-icon lucide-alert-trianglepath d=m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3ZM12 9v4M12 17h.01//svg).custom-callout.note.callout-title.callout-icon:before,.custom-callout.seealso.callout-title.callout-icon:beforecontent:url(data:image/svg+xml;charset=utf-8,svg xmlns=http://www.w3.org/2000/svg width=20 height=20 viewBox=0 0 24 24 fill=none stroke=%23448AFF stroke-width=2 stroke-linecap=round stroke-linejoin=round class=svg-icon lucide-pencilpath d=m18 2 4 4M7.5 20.5 19 9l-4-4L3.5 16.5 2 22z//svg).custom-callout.abstract.callout-title.callout-icon:before,.custom-callout.summary.callout-title.callout-icon:before,.custom-callout.tldr.callout-title.callout-icon:beforecontent:url(data:image/svg+xml;charset=utf-8,svg xmlns=http://www.w3.org/2000/svg width=20 height=20 viewBox=0 0 24 24 fill=none stroke=%2300B0FF stroke-width=2 stroke-linecap=round stroke-linejoin=round class=svg-icon lucide-clipboard-listrect x=8 y=2 width=8 height=4 rx=1 ry=1/path d=M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2M12 11h4M12 16h4M8 11h.01M8 16h.01//svg).custom-callout.info.callout-title.callout-icon:before,.custom-callout.todo.callout-title.callout-icon:beforecontent:url(data:image/svg+xml;charset=utf-8,svg xmlns=http://www.w3.org/2000/svg width=20 height=20 viewBox=0 0 24 24 fill=none stroke=%2300B8D4 stroke-width=2 stroke-linecap=round stroke-linejoin=round class=svg-icon lucide-check-circle-2path d=M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z/path d=m9 12 2 2 4-4//svg).custom-callout.hint.callout-title.callout-icon:before,.custom-callout.important.callout-title.callout-icon:before,.custom-callout.tip.callout-title.callout-icon:beforecontent:url(data:image/svg+xml;charset=utf-8,svg xmlns=http://www.w3.org/2000/svg width=20 height=20 viewBox=0 0 24 24 fill=none stroke=%2300BFA5 stroke-width=2 stroke-linecap=round stroke-linejoin=round class=svg-icon lucide-flamepath d=M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z//svg).custom-callout.check.callout-title.callout-icon:before,.custom-callout.done.callout-title.callout-icon:before,.custom-callout.success.callout-title.callout-icon:beforecontent:url(data:image/svg+xml;charset=utf-8,svg xmlns=http://www.w3.org/2000/svg width=20 height=20 viewBox=0 0 24 24 fill=none stroke=%2300C853 stroke-width=2 stroke-linecap=round stroke-linejoin=round class=svg-icon lucide-checkpath d=M20 6 9 17l-5-5//svg).custom-callout.faq.callout-title.callout-icon:before,.custom-callout.help.callout-title.callout-icon:before,.custom-callout.question.callout-title.callout-icon:beforecontent:url(data:image/svg+xml;charset=utf-8,svg xmlns=http://www.w3.org/2000/svg width=20 height=20 viewBox=0 0 24 24 fill=none stroke=%23E0AC00 stroke-width=2 stroke-linecap=round stroke-linejoin=round class=svg-icon lucide-help-circlecircle cx=12 cy=12 r=10/path d=M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3M12 17h.01//svg).custom-callout.fail.callout-title.callout-icon:before,.custom-callout.failure.callout-title.callout-icon:before,.custom-callout.missing.callout-title.callout-icon:beforecontent:url(data:image/svg+xml;charset=utf-8,svg xmlns=http://www.w3.org/2000/svg width=20 height=20 viewBox=0 0 24 24 fill=none stroke=%23FF5252 stroke-width=2 stroke-linecap=round stroke-linejoin=round class=svg-icon lucide-xpath d=M18 6 6 18M6 6l12 12//svg).custom-callout.danger.callout-title.callout-icon:before,.custom-callout.error.callout-title.callout-icon:beforecontent:url(data:image/svg+xml;charset=utf-8,svg xmlns=http://www.w3.org/2000/svg width=20 height=20 viewBox=0 0 24 24 fill=none stroke=%23FF1744 stroke-width=2 stroke-linecap=round stroke-linejoin=round class=svg-icon lucide-zappath d=M13 2 3 14h9l-1 8 10-12h-9l1-8z//svg).custom-callout.bug.callout-title.callout-icon:beforecontent:url(data:image/svg+xml;charset=utf-8,svg xmlns=http://www.w3.org/2000/svg width=20 height=20 viewBox=0 0 24 24 fill=none stroke=%23F50057 stroke-width=2 stroke-linecap=round stroke-linejoin=round class=svg-icon lucide-bugrect x=8 y=6 width=8 height=14 rx=4/path d=m19 7-3 2M5 7l3 2M19 19l-3-2M5 19l3-2M20 13h-4M4 13h4M10 4l1 2M14 4l-1 2//svg).custom-callout.example.callout-title.callout-icon:beforecontent:url(data:image/svg+xml;charset=utf-8,svg xmlns=http://www.w3.org/2000/svg width=20 height=20 viewBox=0 0 24 24 fill=none stroke=%237C4DFF stroke-width=2 stroke-linecap=round stroke-linejoin=round class=svg-icon lucide-listpath d=M8 6h13M8 12h13M8 18h13M3 6h.01M3 12h.01M3 18h.01//svg).custom-callout.cite.callout-title.callout-icon:before,.custom-callout.quote.callout-title.callout-icon:beforecontent:url(data:image/svg+xml;charset=utf-8,svg xmlns=http://www.w3.org/2000/svg width=20 height=20 viewBox=0 0 24 24 fill=none stroke=%239E9E9E stroke-width=2 stroke-linecap=round stroke-linejoin=round class=svg-icon lucide-quotepath d=M3 21c3 0 7-1 7-8V5c0-1.25-.756-2.017-2-2H4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1zM15 21c3 0 7-1 7-8V5c0-1.25-.757-2.017-2-2h-4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2h.75c0 2.25.25 4-2.75 4v3c0 1 0 1 1 1z//svg).custom-callout.note .callout-body /* 移除了 background:transparent!important; 改为根据类型变化的背景色 */ background-color: rgba(var(--callout-note), var(--callout-title-bg-opacity)); /* 根据不同的类型设置背景色和文字/图标颜色 */.custom-callout.note, .custom-callout.note summary background-color: rgba(var(--callout-note), var(--callout-title-bg-opacity)); .custom-callout.abstract .callout-body background-color: rgba(var(--callout-abstract), var(--callout-title-bg-opacity)); .custom-callout.abstract, .custom-callout.abstract summary background-color: rgba(var(--callout-abstract), var(--callout-title-bg-opacity)); .custom-callout.info .callout-body background-color: rgba(var(--callout-info), var(--callout-title-bg-opacity)); .custom-callout.info, .custom-callout.info summary background-color: rgba(var(--callout-info), var(--callout-title-bg-opacity)); .custom-callout.tip .callout-body background-color: rgba(var(--callout-tip), var(--callout-title-bg-opacity)); .custom-callout.tip, .custom-callout.tip summary background-color: rgba(var(--callout-tip), var(--callout-title-bg-opacity)); .custom-callout.success .callout-body background-color: rgba(var(--callout-success), var(--callout-title-bg-opacity)); .custom-callout.success, .custom-callout.success summary background-color: rgba(var(--callout-success), var(--callout-title-bg-opacity)); .custom-callout.question .callout-body background-color: rgba(var(--callout-question), var(--callout-title-bg-opacity)); .custom-callout.question, .custom-callout.question summary background-color: rgba(var(--callout-question), var(--callout-title-bg-opacity)); .custom-callout.warning .callout-body background-color: rgba(var(--callout-warning), var(--callout-title-bg-opacity)); .custom-callout.warning, .custom-callout.warning summary background-color: rgba(var(--callout-warning), var(--callout-title-bg-opacity)); .custom-callout.failure .callout-body background-color: rgba(var(--callout-failure), var(--callout-title-bg-opacity)); .custom-callout.failure, .custom-callout.failure summary background-color: rgba(var(--callout-failure), var(--callout-title-bg-opacity)); .custom-callout.danger .callout-body background-color: rgba(var(--callout-danger), var(--callout-title-bg-opacity)); .custom-callout.danger, .custom-callout.danger summary background-color: rgba(var(--callout-danger), var(--callout-title-bg-opacity)); .custom-callout.bug .callout-body background-color: rgba(var(--callout-bug), var(--callout-title-bg-opacity)); .custom-callout.bug, .custom-callout.bug summary background-color: rgba(var(--callout-bug), var(--callout-title-bg-opacity)); .custom-callout.example .callout-body background-color: rgba(var(--callout-example), var(--callout-title-bg-opacity)); .custom-callout.example, .custom-callout.example summary background-color: rgba(var(--callout-example), var(--callout-title-bg-opacity)); .custom-callout.quote .callout-body background-color: rgba(var(--callout-quote), var(--callout-title-bg-opacity)); .custom-callout.quote, .custom-callout.quote summary background-color: rgba(var(--callout-quote), var(--callout-title-bg-opacity)); .custom-callout.cite .callout-body background-color: rgba(var(--callout-quote), var(--callout-title-bg-opacity)); .custom-callout.cite, .custom-callout.cite summary background-color: rgba(var(--callout-quote), var(--callout-title-bg-opacity)); .custom-callout.todo .callout-body background-color: rgba(var(--callout-info), var(--callout-title-bg-opacity)); .custom-callout.todo, .custom-callout.todo summary background-color: rgba(var(--callout-info), var(--callout-title-bg-opacity)); .custom-callout.seealso .callout-body background-color: rgba(var(--callout-note), var(--callout-title-bg-opacity)); .custom-callout.seealso, .custom-callout.seealso summary background-color: rgba(var(--callout-note), var(--callout-title-bg-opacity)); .custom-callout.hint .callout-body background-color: rgba(var(--callout-tip), var(--callout-title-bg-opacity)); .custom-callout.hint, .custom-callout.hint summary background-color: rgba(var(--callout-tip), var(--callout-title-bg-opacity)); .custom-callout.important .callout-body background-color: rgba(var(--callout-tip), var(--callout-title-bg-opacity)); .custom-callout.important, .custom-callout.important summary background-color: rgba(var(--callout-tip), var(--callout-title-bg-opacity)); .custom-callout.attention .callout-body background-color: rgba(var(--callout-warning), var(--callout-title-bg-opacity)); .custom-callout.attention, .custom-callout.attention summary background-color: rgba(var(--callout-warning), var(--callout-title-bg-opacity)); .custom-callout.caution .callout-body background-color: rgba(var(--callout-warning), var(--callout-title-bg-opacity)); .custom-callout.caution, .custom-callout.caution summary background-color: rgba(var(--callout-warning), var(--callout-title-bg-opacity)); .custom-callout.done .callout-body background-color: rgba(var(--callout-success), var(--callout-title-bg-opacity)); .custom-callout.done, .custom-callout.done summary background-color: rgba(var(--callout-success), var(--callout-title-bg-opacity)); .custom-callout.check .callout-body background-color: rgba(var(--callout-success), var(--callout-title-bg-opacity)); .custom-callout.check, .custom-callout.check summary background-color: rgba(var(--callout-success), var(--callout-title-bg-opacity)); .custom-callout.faq .callout-body background-color: rgba(var(--callout-question), var(--callout-title-bg-opacity)); .custom-callout.faq, .custom-callout.faq summary background-color: rgba(var(--callout-question), var(--callout-title-bg-opacity)); .custom-callout.help .callout-body background-color: rgba(var(--callout-question), var(--callout-title-bg-opacity)); .custom-callout.help, .custom-callout.help summary background-color: rgba(var(--callout-question), var(--callout-title-bg-opacity)); .custom-callout.fail .callout-body background-color: rgba(var(--callout-failure), var(--callout-title-bg-opacity)); .custom-callout.fail, .custom-callout.fail summary background-color: rgba(var(--callout-failure), var(--callout-title-bg-opacity)); .custom-callout.missing .callout-body background-color: rgba(var(--callout-failure), var(--callout-title-bg-opacity)); .custom-callout.missing, .custom-callout.missing summary background-color: rgba(var(--callout-failure), var(--callout-title-bg-opacity)); .custom-callout.error .callout-body background-color: rgba(var(--callout-danger), var(--callout-title-bg-opacity)); .custom-callout.error, .custom-callout.error summary background-color: rgba(var(--callout-danger), var(--callout-title-bg-opacity)); .custom-callout.tldr .callout-body background-color: rgba(var(--callout-abstract), var(--callout-title-bg-opacity)); .custom-callout.tldr, .custom-callout.tldr summary background-color: rgba(var(--callout-abstract), var(--callout-title-bg-opacity)); 集成 Telegram Channel 说说#显示效果： 篇幅限制，只展示2条，请耐心等待加载。（可能要挂代理） 代码抄自把Tg Channel接入到Stellar时间线。因为我懒得做标签筛选所以直接把这个去掉啦，在此还要感谢佬的耐心解答 GitHub Action 自动部署并修复更新时间#在自动部署这里遇到了几个坑，总结下来大概有下： 网上流行的很多 yml workflow 文件都有些过时 公钥私钥啥的不太懂，配置了半天 因为我的博客有数学公式显示，所以要在 workflow 里加入安装 pandoc 的部分，才能够成功运行 自动部署后网站的文章更新时间全部变成 push 时间，但在本地是正常的。一番搜索后找到了解决方法，在 yml 文件里加入了以下代码，分别修复 posts、wiki、notes 的更新时间： - name: Restore file modification time 🕒 run: find source/_posts -name *.md | while read file; do touch -d $(git log -1 --format=@%ct $file) $file; done - name: Restore file modification time of wiki🕒 run: find source/wiki -name *.md | while read file; do touch -d $(git log -1 --format=@%ct $file) $file; done - name: Restore file modification time of notes🕒 run: find source/notes -name *.md | while read file; do touch -d $(git log -1 --format=@%ct $file) $file; done 最后附上完整代码，拿去用的话要自己配置一下 GitHub 部分的设置： name: auto deployon: workflow_dispatch: push:jobs: build: runs-on: ubuntu-latest # 运行环境为最新版 Ubuntu name: auto deploy steps: # 1. 获取源码 - name: Checkout uses: actions/checkout@v4 # 使用 actions/checkout@v3 with: # 条件 submodules: true # Checkout private submodules(themes or something else). 当有子模块时切换分支？ fetch-depth: 0 - name: Restore file modification time 🕒 run: find source/_posts -name *.md | while read file; do touch -d $(git log -1 --format=@%ct $file) $file; done - name: Restore file modification time of wiki🕒 run: find source/wiki -name *.md | while read file; do touch -d $(git log -1 --format=@%ct $file) $file; done - name: Restore file modification time of notes🕒 run: find source/notes -name *.md | while read file; do touch -d $(git log -1 --format=@%ct $file) $file; done # 2. 配置环境 - name: Setup Node.js 18.19.x uses: actions/setup-node@master with: node-version: 18.19.x - name: Install pandoc run: | cd /tmp wget -c https://github.com/jgm/pandoc/releases/download/2.14.0.3/pandoc-2.14.0.3-1-amd64.deb sudo dpkg -i pandoc-2.14.0.3-1-amd64.deb # 3. 生成静态文件 - name: Generate Public Files run: | npm i npm install hexo-cli -g hexo clean hexo generate # 4a. 部署到 GitHub 仓库（可选） - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v3 with: deploy_key: $ secrets.HEXO_DEPLOY_PRI # 配置密钥 external_repository: # 填入你的GitHub pages部署仓库 publish_branch: gt-pages # 填入部署分支 publish_dir: ./public commit_message: $ github.event.head_commit.message user_name: github-actions[bot] user_email: github-actions[bot]@users.noreply.github.com 给博客添加地理定位并制作个性欢迎#显示效果： ![个性欢迎卡片](Hexo-Stellar主题装修二CleanShot 2024-04-17 at 01.09.07@2x-1749438579839-1044.webp)个性欢迎卡片 代码来自给博客添加腾讯地图定位并制作个性欢迎。我稍微做了一点调整： 新建 source/js/services/txmap.js，并添加以下代码： 点击展开代码 //get请求$.ajax( type: get, url: https://apis.map.qq.com/ws/location/v1/ip, data: key: 你的key, output: jsonp, , dataType: jsonp, success: function (res) ipLoacation = res; )function getDistance(e1, n1, e2, n2) const R = 6371 const sin, cos, asin, PI, hypot = Math let getPoint = (e, n) = e *= PI / 180 n *= PI / 180 return x: cos(n) * cos(e), y: cos(n) * sin(e), z: sin(n) let a = getPoint(e1, n1) let b = getPoint(e2, n2) let c = hypot(a.x - b.x, a.y - b.y, a.z - b.z) let r = asin(c / 2) * 2 * R return Math.round(r);function showWelcome() let dist = getDistance(113.34499552, 23.15537143, ipLoacation.result.location.lng, ipLoacation.result.location.lat); //这里换成自己的经纬度 let pos = ipLoacation.result.ad_info.nation; let ip; let posdesc; //根据国家、省份、城市信息自定义欢迎语 switch (ipLoacation.result.ad_info.nation) case 日本: posdesc = よろしく，一起去看樱花吗; break; case 美国: posdesc = Let us live in peace!; break; case 英国: posdesc = 想同你一起夜乘伦敦眼; break; case 俄罗斯: posdesc = 干了这瓶伏特加！; break; case 法国: posdesc = Cest La Vie; break; case 德国: posdesc = Die Zeit verging im Fluge.; break; case 澳大利亚: posdesc = 一起去大堡礁吧！; break; case 加拿大: posdesc = 拾起一片枫叶赠予你; break; case 中国: pos = ipLoacation.result.ad_info.province + + ipLoacation.result.ad_info.city + + ipLoacation.result.ad_info.district; ip = ipLoacation.result.ip; switch (ipLoacation.result.ad_info.province) case 北京市: posdesc = 北——京——欢迎你~~~; break; case 天津市: posdesc = 讲段相声吧。; break; case 河北省: posdesc = 山势巍巍成壁垒，天下雄关。铁马金戈由此向，无限江山。; break; case 山西省: posdesc = 展开坐具长三尺，已占山河五百余。; break; case 内蒙古自治区: posdesc = 天苍苍，野茫茫，风吹草低见牛羊。; break; case 辽宁省: posdesc = 我想吃烤鸡架！; break; case 吉林省: posdesc = 状元阁就是东北烧烤之王。; break; case 黑龙江省: posdesc = 很喜欢哈尔滨大剧院。; break; case 上海市: posdesc = 众所周知，中国只有两个城市。; break; case 江苏省: switch (ipLoacation.result.ad_info.city) case 南京市: posdesc = 这是我挺想去的城市啦。; break; case 苏州市: posdesc = 上有天堂，下有苏杭。; break; default: posdesc = 散装是必须要散装的。; break; break; case 浙江省: posdesc = 东风渐绿西湖柳，雁已还人未南归。; break; case 河南省: switch (ipLoacation.result.ad_info.city) case 郑州市: posdesc = 豫州之域，天地之中。; break; case 南阳市: posdesc = 臣本布衣，躬耕于南阳。此南阳非彼南阳！; break; case 驻马店市: posdesc = 峰峰有奇石，石石挟仙气。嵖岈山的花很美哦！; break; case 开封市: posdesc = 刚正不阿包青天。; break; case 洛阳市: posdesc = 洛阳牡丹甲天下。; break; default: posdesc = 可否带我品尝河南烩面啦？; break; break; case 安徽省: posdesc = 蚌埠住了，芜湖起飞。; break; case 福建省: posdesc = 井邑白云间，岩城远带山。; break; case 江西省: posdesc = 落霞与孤鹜齐飞，秋水共长天一色。; break; case 山东省: posdesc = 遥望齐州九点烟，一泓海水杯中泻。; break; case 湖北省: posdesc = 来碗热干面！; break; case 湖南省: posdesc = 74751，长沙斯塔克。; break; case 广东省: posdesc = 老板来两斤福建人。; break; case 广西壮族自治区: posdesc = 桂林山水甲天下。; break; case 海南省: posdesc = 朝观日出逐白浪，夕看云起收霞光。; break; case 四川省: posdesc = 康康川妹子。; break; case 贵州省: posdesc = 茅台，学生，再塞200。; break; case 云南省: posdesc = 玉龙飞舞云缠绕，万仞冰川直耸天。; break; case 西藏自治区: posdesc = 躺在茫茫草原上，仰望蓝天。; break; case 陕西省: posdesc = 来份臊子面加馍。; break; case 甘肃省: posdesc = 羌笛何须怨杨柳，春风不度玉门关。; break; case 青海省: posdesc = 牛肉干和老酸奶都好好吃。; break; case 宁夏回族自治区: posdesc = 大漠孤烟直，长河落日圆。; break; case 新疆维吾尔自治区: posdesc = 驼铃古道丝绸路，胡马犹闻唐汉风。; break; case 台湾省: posdesc = 我在这头，大陆在那头。; break; case 香港特别行政区: posdesc = 永定贼有残留地鬼嚎，迎击光非岁玉。; break; case 澳门特别行政区: posdesc = 性感荷官，在线发牌。; break; default: posdesc = 带我去你的城市逛逛吧！; break; break; default: posdesc = 带我去你的国家逛逛吧。; break; //根据本地时间切换欢迎语 let timeChange; let date = new Date(); if (date.getHours() = 5 date.getHours() 11) timeChange = span上午好/span，一日之计在于晨！; else if (date.getHours() = 11 date.getHours() 13) timeChange = span中午好/span，该摸鱼吃午饭了。; else if (date.getHours() = 13 date.getHours() 15) timeChange = span下午好/span，懒懒地睡个午觉吧！; else if (date.getHours() = 15 date.getHours() 16) timeChange = span三点几啦/span，一起饮茶呀！; else if (date.getHours() = 16 date.getHours() 19) timeChange = span夕阳无限好！/span; else if (date.getHours() = 19 date.getHours() 24) timeChange = span晚上好/span，夜生活嗨起来！; else timeChange = 夜深了，早点休息，少熬夜。; try //自定义文本和需要放的位置 document.getElementById(welcome-info).innerHTML = `bcenter🎉 欢迎信息 🎉/centeremsp;emsp;欢迎来自 span style=color:var(--theme-color)$pos/span 的小伙伴，$timeChange您现在距离站长约 span style=color:var(--theme-color)$dist/span 公里，当前的IP地址为： span style=color:var(--theme-color)$ip/span， $posdesc/b`; catch (err) // console.log(Pjax无法获取#welcome-info元素🙄🙄🙄) window.onload = showWelcome;// 如果使用了pjax在加上下面这行代码document.addEventListener(pjax:complete, showWelcome); 在主题文件中配置#在主题配置文件 _config.stellar.yml 中引入jQuery依赖和刚刚的js文件： inject: - script src=https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js/script # jQuery - script async data-pjax src=/js/services/txmap.js/script # 腾讯位置API 在 source/_data/widgets.yml 中添加小组件，我在里面嵌套了一个随机文章跳转，不要的话可以删掉，其中，span id=welcome-info /span 是必须的不可以删： welcomeloc: layout: markdown title: 🎉 抓到你啦 linklist: columns: 1 items: - icon: img src=https://api.iconify.design/ion:dice-outline.svg/ title: 随机文章 url: javascript:toRandomPost() content: | span id=welcome-info style=font-family: LXGW WenKai Screen;/span 然后就跟正常的小组件一样在想要的地方引用即可。 添加更改字体按钮#显示效果： 第一种： 在任意位置增加一个 button 按钮![img](Hexo-Stellar主题装修二CleanShot 2024-04-17 at 01.21.07@2x-1749438579839-1046.webp) 鼠标放到上面会显示提示： ![img](Hexo-Stellar主题装修二CleanShot 2024-04-17 at 01.22.42@2x-1749438579839-1048.webp) 第二种： 在文章页面目录下方显示 ![img](Hexo-Stellar主题装修二CleanShot 2024-04-17 at 01.24.07@2x-1749438579839-1050.webp) 之前一直纠结要不要把自定义字体效果去掉，在选择和留下之间来回切换 最终才出现了这里的方案：默认不加载任何字体，喜欢 LXGW 字体的话可点击图标转换，同时再点击一下就恢复。代码不长但完美地解决了我的强迫症～ 第一步：准备字体文件#可以是在线文件也可以是本地文件，我是在主题 config 文件下通过 inject 引入了 LXGW 字体。 第二步：修改 css#首先确保 LXGW WenKai Screen 字体已经通过 CSS 正确引入。你可以在 CSS 文件中添加一个特定的类，用于当用户选择使用这种字体时切换到它： /* 设置字体 */.LXGWMode font-family: LXGW WenKai Screen, system-ui, Helvetica Neue, sans-serif; // 使用 LXGW WenKai 字体，并指定后备字体 第三步：添加 javascript#新建 source/js/changefont.js 文件，添加以下代码： document.addEventListener(DOMContentLoaded, function () applyFontSetting(); updateButtonText(); // Ensure the button text is correct on page load);document.addEventListener(pjax:success, function () applyFontSetting(); updateButtonText(); // Update the button text after PJAX updates);function applyFontSetting() if (localStorage.getItem(LXGWFontEnabled) === true) document.body.classList.add(LXGWMode); else document.body.classList.remove(LXGWMode); function toggleLXGWFont() var button = document.querySelector(.custom-button); // Find the button if (localStorage.getItem(LXGWFontEnabled) === true) localStorage.setItem(LXGWFontEnabled, false); document.body.classList.remove(LXGWMode); button.innerHTML = img src=https://cdn.jsdelivr.net/gh/infinitesum/Twikoo-emoji@master/Blob/ablobcatrainbow.png alt=Emoji style=vertical-align: middle; width: 20px; height: 20px; 危险，请勿点击; else localStorage.setItem(LXGWFontEnabled, true); document.body.classList.add(LXGWMode); button.innerHTML = img src=https://cdn.jsdelivr.net/gh/infinitesum/Twikoo-emoji@master/Blob/ablobcatrainbow.png alt=Emoji style=vertical-align: middle; width: 20px; height: 20px; 不要说我没有警告过你; function updateButtonText() var button = document.querySelector(.custom-button); // Find the button if (localStorage.getItem(LXGWFontEnabled) === true) button.innerHTML = img src=https://cdn.jsdelivr.net/gh/infinitesum/Twikoo-emoji@master/Blob/ablobcatrainbow.png alt=Emoji style=vertical-align: middle; width: 20px; height: 20px; 不要点这里啦！; else button.innerHTML = img src=https://cdn.jsdelivr.net/gh/infinitesum/Twikoo-emoji@master/Blob/ablobcatrainbow.png alt=Emoji style=vertical-align: middle; width: 20px; height: 20px; 危险，请勿点击; 第四步：添加切换按钮#然后在想要的地方引用即可，可以自行添加各种 emoji，比如： button class=custom-button tooltip onclick=toggleLXGWFont() data-msg=警告，真的很危险img src=https://cdn.jsdelivr.net/gh/infinitesum/Twikoo-emoji@master/Blob/ablobcatrainbow.png alt=Emoji style=vertical-align: middle; width: 20px; height: 20px; 危险，请勿点击/button 给按钮加入 css 提示框#在自定义 css 文件中添加： .custom-button display: inline-block; padding: 2px 10px; /*margin: 10px; background-color: #f2f2f2; /* Light grey background, change as needed */ font-family: inherit; /* Inherits the font-family from parent container */ color: #835EEC; background-color: #F2EEFD; @media (prefers-color-scheme: dark) color: #A28BF2; background-color: #282433; text-align: center; cursor: pointer; /*border: 2px solid #ccc; /* Grey border */ border-radius: 16px; /* Rounded corners */ transition: all 0.3s ease; .custom-button:hover background-color: #e9e9e9; /* Slightly darker on hover */ @media (prefers-color-scheme: dark) background-color: #333; /* Darker background on hover */ border-color: #999; /* Darker border on hover */ /* toggle-font 提示框的样式 */.tooltip position: relative; cursor: pointer; /* 可选，让用户知道这是一个可以互动的元素 */.tooltip:hover::before white-space: nowrap; line-height: 18px; content: attr(data-msg); position: absolute; padding: 0 8px; display: block; color: #ffffff; background: #656565; border-radius: 6px; font-size: 12px; top: -25px; left: 50%; transform: translateX(-50%); Z-index: 1000; /* 确保提示框在其他元素之上 */.tooltip:hover:: after Content: ; Position: absolute; Top: -8 px; Left: 50%; Transform: translateX (-50%); Border: 6 px solid transparent; border-top-color: #656565 ; /* 简化写法 *//* toggle-font 按钮的样式 */.widget-wrapper. Toggle-font Background: none; // Example: making background transparent /* Add other styles specific to the toggle-font widget here */ 第二种样式#WARNING 第二种样式需要对主题文件进行一丢丢修改，但貌似不太影响更新……只要无冲突的话可以一直 update fork 在 languages/zh-CN.yml 中添加一行 font: 更改字体，并在 icons.yml 里添加： default:font: svg class=theme-icon xmlns=http://www.w3.org/2000/svg width=32 height=32 viewBox=0 0 32 32path d=m12.677 17.781l-2.626-6.256l-2.694 6.256Zm6.723 6.511h-7.069v-1.365l.458-.023a1.847 1.847 0 0 0 .972-.2a.313.313 0 0 0 .145-.263a4.158 4.158 0 0 0-.419-1.4l-.812-1.931H7.322L6.4 21.259a3.319 3.319 0 0 0-.349 1.157c0 .036 0 .119.154.241a2.481 2.481 0 0 0 1.191.247l.448.033v1.354H2v-1.31l.4-.07a2.188 2.188 0 0 0 1-.318a6.318 6.318 0 0 0 1.18-2.066l5.575-13.036H11.2l5.512 13.174a5.255 5.255 0 0 0 1.049 1.835a1.959 1.959 0 0 0 1.19.4l.454.027Zm6.441-2.732v-3.985a22.542 22.542 0 0 0-2.226.97a3.845 3.845 0 0 0-1.29 1.05a2.03 2.03 0 0 0-.388 1.2a1.951 1.951 0 0 0 .491 1.362a1.49 1.49 0 0 0 1.13.544a4.142 4.142 0 0 0 2.283-1.141m-3.333 2.949a2.833 2.833 0 0 1-2.139-.893a3.206 3.206 0 0 1-.833-2.285a2.959 2.959 0 0 1 .415-1.577a5 5 0 0 1 1.791-1.625a23.876 23.876 0 0 1 3.617-1.588v-.074a2.905 2.905 0 0 0-.383-1.833a1.325 1.325 0 0 0-1.075-.412a1.155 1.155 0 0 0-.816.26a.687.687 0 0 0-.277.536l.023.646a1.62 1.62 0 0 1-.4 1.158a1.481 1.481 0 0 1-2.1-.019a1.634 1.634 0 0 1-.391-1.134a2.8 2.8 0 0 1 1.182-2.177a4.813 4.813 0 0 1 3.125-.932a5.381 5.381 0 0 1 2.508.524a2.628 2.628 0 0 1 1.213 1.346a6.391 6.391 0 0 1 .244 2.2v3.55a14.665 14.665 0 0 0 .051 1.749a.661.661 0 0 0 .054.2c.085-.078.284-.225.864-.806l.819-.828v1.967l-.1.128c-.958 1.283-1.883 1.907-2.83 1.907a1.6 1.6 0 0 1-1.257-.557a1.788 1.788 0 0 1-.358-.74a9.688 9.688 0 0 1-1.433.977a3.579 3.579 0 0 1-1.514.332//svg 在 layout/_partial/widgets/toc.ejs 中，在想要的位置，如 el += editBtn 后，添加以下代码： el += `a class=toggle-font onclick=toggleLXGWFont()` el += icon(default:font) el += `span$__(btn.font)/span` el += `/a` 为了使这个图标随主题明暗自动变化，在自定义 css 文件中加入： /* 设置图标颜色 *//* 白天模式，默认填充色为黑色 */.theme-icon fill: black;/* 暗黑模式，填充色为白色 */@media (prefers-color-scheme: dark) .theme-icon fill: white; 随机文章跳转#NOTE 要在主题文件夹里新增文件，不影响主题后续更新 终于来到了我最爱的生活哲学！代码参考了这个链接。创建 themes/stellar/scripts/helpers/random.js ，增加以下代码： hexo.extend.filter.register(after_render:html, function (data) const posts = [] hexo.locals.get(posts).map(function (post) if (post.random !== false) posts.push(post.path) ) data += `scriptvar posts=$JSON.stringify(posts);function toRandomPost() window.pjax ? pjax.loadUrl(/+posts[Math.floor(Math.random()*posts.length)]) : window.open(/+posts[Math.floor(Math.random()*posts.length)], _self); ;/script` return data) 在主题配置文件引入 _config.stellar.yml，inject的 head里添加 - script src=/js/random.js/script # 随机文章 然后在需要调用的位置执行 toRandomPost() 函数即可。比如任意 dom 添加 onclick=toRandomPost() 好吧，我知道你肯定没听懂 反正我当时看完是一脸懵圈 不过没关系，我最后还是琢磨明白啦，下面就有填写示例，接着看就好 添加一个按钮: 随机阅读一篇文章 代码：button onclick=toRandomPost()随机阅读一篇文章/button 或者添加一个链接: 随机阅读一篇文章 代码：a href=# onclick=toRandomPost(); return false;随机阅读一篇文章/a 在下一节还有应用示例，请往下看—— 超链接样式调整#文章内链接：加粗并下移下划线。显示效果： ![超链接样式](Hexo-Stellar主题装修二CleanShot 2024-04-17 at 22.18.12@2x-1749438579839-1056.webp)超链接样式 在自定义 css 文件里加入： /* 文章内链接 */li:not([class]) a:not([class]),p:not([class]) a:not([class]),table a:not([class]) /*color: var(--theme-link);*/ padding-bottom: 3px; /* 增加底部padding */ padding-right: 1px; margin-right: 2px; background: linear-gradient(0, var(--theme-link), var(--theme-link)) no-repeat center bottom / 100% 2px; 测试链接：关于 新样式！为链接使用荧光笔下划线效果，这个和上面的样式二选一就好。显示效果： ![img](Hexo-Stellar主题装修二CleanShot 2024-04-20 at 19.32.04@2x-1749438579839-1058.webp) /* 文章内链接：为链接使用荧光笔下划线效果 */li:not([class]) a:not([class]),p:not([class]) a:not([class]),table a:not([class]) padding-bottom: 0.1rem; background: linear-gradient(0, var(--theme-link-opa), var(--theme-link-opa)) no-repeat center bottom / 100% 40%; 选中文本：使用超链接高亮的背景色#在自定义 css 文件里加入： /* 选中文本：使用超链接高亮的背景色 */::selection background: var(--theme-link-opa); Twikoo 评论样式优化#Title 样式优化需要改主题文件，但下面的给评论输入框加入提示是纯 css 实现的不需要改 显示效果： ![img](Hexo-Stellar主题装修二CleanShot 2024-04-17 at 02.13.48@2x-1749438579839-1060.webp) 只截了部分，整体效果可在评论区查看。代码全部抄自星日语大佬的这条 commit。评论区表情显示优化可参考这条 commit。 给评论输入框加入提示#显示效果： ![img](Hexo-Stellar主题装修二CleanShot 2024-04-17 at 02.17.46@2x-1749438579839-1062.webp) 原始代码忘记在哪里抄的了，我就修改了最后 3 行……在自定义 css 文件中加入以下内容： /* 设置文字内容 :nth-child(1)的作用是选择第几个 */.el-input.el-input--small.el-input-group.el-input-group--prepend:nth-child(1):before content: 输入QQ号会自动获取昵称和头像🐧;.el-input.el-input--small.el-input-group.el-input-group--prepend:nth-child(2):before content: 收到回复将会发送到您的邮箱📧;.el-input.el-input--small.el-input-group.el-input-group--prepend:nth-child(3):before content: 填写后可以点击昵称访问您的网站🔗;/* 当用户点击输入框时显示 */.el-input.el-input--small.el-input-group.el-input-group--prepend:focus-within::before,.el-input.el-input--small.el-input-group.el-input-group--prepend:focus-within::after display: block;/* 主内容区 */.el-input.el-input--small.el-input-group.el-input-group--prepend::before /* 先隐藏起来 */ display: none; /* 绝对定位 */ position: absolute; /* 向上移动60像素 */ top: -60px; /* 文字强制不换行，防止left:50%导致的文字换行 */ white-space: nowrap; /* 圆角 */ border-radius: 10px; /* 距离左边50% */ left: 50%; /* 然后再向左边挪动自身的一半，即可实现居中 */ transform: translate(-50%); /* 填充 */ padding: 14px 18px; background: #444; color: #fff;/* 小角标 */.el-input.el-input--small.el-input-group.el-input-group--prepend::after display: none; content: ; position: absolute; /* 内容大小（宽高）为0且边框大小不为0的情况下，每一条边（4个边）都是一个三角形，组成一个正方形。 我们先将所有边框透明，再给其中的一条边添加颜色就可以实现小三角图标 */ border: 12px solid transparent; border-top-color: #444; left: 50%; transform: translate(-50%, -48px);.el-input.el-input--small.el-input-group.el-input-group--prepend::before, .el-input.el-input--small.el-input-group.el-input-group--prepend::after z-index: 9999; /* 提高层级，确保内容显示在最前 */ Stellar Twikoo 表情包补全计划#blobcat#这个系列表情真的不要太可爱，一眼爱上 光在博客正文里用怎么够，当然还要在评论区里也安排上 blobcat 表情主要来自星日语佬。本人在学会自定义后收集癖大发，一口气制作了几个系列的表情，往现有的 blobcat里也加了几个比较好看的 Stellar 引入：blobcatplus:https://cdn.jsdelivr.net/gh/infinitesum/Twikoo-emoji@master/Blob/name.png Twikoo 使用链接： https://cdn.jsdelivr.net/gh/infinitesum/Twikoo-emoji@master/blobcatplus.json 表情 索引 表情 索引 表情 索引 ablobcatheart ablobcatheartbroken blobcatheart blobcatheartpride blobcatlove blobcatkissheart blobcatsnuggle comfyuee comfyslep blobcatcomfysweat blobcatcomftears blobcatfacepalm blobcat0_0 blobcatangry blobbanhammerr blobcatt blobcatblush blobcatcoffee blobcatcry blobcatdead blobcatdied blobcatdisturbed blobcatfearful blobcatfingerguns blobcatflip blobcatflower blobcatgay blobcatgooglycry blobcatneutral blobcatopenmouth blobcatsadreach blobcatscared blobcatnomblobcat blobcatpresentred blobcatread blobcatsipsweat blobcatsnapped blobcatthink blobcattriumph blobcatumm blobcatverified blobcatbox blobcatcaged blobcatgooglytrash blobcatheadphones blobcathighfive blobcatmelt blobcatmeltthumb blobcatnotlikethis blobcatsaitama blobcatyandere blobcatpeek2 blobcatpeekaboo blobcatphoto ablobcatattentionreverse ablobcatreachrev ablobcatwave blobcatalt blobcatpolice blobcatshocked ablobcatrainbow A_BlobCat_REEEE A_BlobCat_Code ablobcatknitsweats A_BlobCat_Nervous blobcat-aww ablobcatcry ablobcatdead azuki# Stellar 引入：azuki: https://cdn.jsdelivr.net/gh/Saidosi/azuki-emoji-for-waline@1.0/azukisan/name.png Twikoo 使用链接： https://cdn.jsdelivr.net/gh/infinitesum/Twikoo-emoji@master/xiaodouni.json 表情 索引 表情 索引 表情 索引 001 015 029 002 016 030 003 017 031 004 018 032 005 019 033 006 020 034 007 021 035 008 022 036 009 023 037 010 024 038 011 025 039 012 026 040 013 027 014 028 neko# Stellar 引入：neko: https://cdn.jsdelivr.net/gh/2x-ercha/twikoo-magic@master/image/Yurui-Neko/name.png Twikoo 使用链接： https://cdn.jsdelivr.net/gh/infinitesum/Twikoo-emoji@master/neko.json 表情 索引 表情 索引 表情 索引 001 015 028 002 016 029 003 017 030 004 018 031 005 019 032 006 020 033 007 021 034 008 022 035 009 023 036 010 024 037 011 025 038 012 026 039 013 027 014 dokomo#Stellar 引入: dokomo: https://cdn.jsdelivr.net/gh/infinitesum/Twikoo-emoji@master/dokomo/name.png Twikoo 使用链接: https://raw.githubusercontent.com/infinitesum/Twikoo-emoji/main/dokomo/dokomo.json 表情 索引 表情 索引 表情 索引 dokomo-1 dokomo-18 dokomo-35 dokomo-2 dokomo-19 dokomo-36 dokomo-3 dokomo-20 dokomo-37 dokomo-4 dokomo-21 dokomo-38 dokomo-5 dokomo-22 dokomo-39 dokomo-6 dokomo-23 dokomo-40 dokomo-7 dokomo-24 dokomo-41 dokomo-8 dokomo-25 dokomo-42 dokomo-9 dokomo-26 dokomo-43 dokomo-10 dokomo-27 dokomo-44 dokomo-11 dokomo-28 dokomo-45 dokomo-12 dokomo-29 dokomo-46 dokomo-13 dokomo-30 dokomo-47 dokomo-14 dokomo-31 dokomo-48 dokomo-15 dokomo-32 dokomo-49 dokomo-16 dokomo-33 dokomo-17 dokomo-34 总字数统计：“发表了x篇文章，共计x字”#需要修改主题文件 // 3.left.top: 面包屑导航 el += `div class=flex-row id=breadcrumb` // 首页 el += `a class=cap breadcrumb href=$url_for(config.root)$__(btn.home)/a` if (theme.wiki.tree[page.wiki]) el += partial(breadcrumb/wiki) else if (page.layout == post) el += partial(breadcrumb/blog) else el += partial(breadcrumb/page) // end 3.left.top el += `/div` 并在后面添加： // 在这里添加标签代码 if (page.layout == post page.tags page.tags.length 0) el += div id=tag; // 将标签容器的创建移动到条件内部 el += spannbsp标签：/span; el += list_categories(page.tags, class: cap breadcrumb, show_count: false, separator: nbsp; , style: none ); el += nbsp/div; toc 字体大小调整#需要修改主题文件 就是把文章目录字体调小了一点点。 在themes/stellar/source/css/_layout/widgets/toc.styl 文件中，找到 // 各级缩进样式.widget-wrapper.toc .toc .toc-item font-weight: 500 --fsp: $fsp1 .toc-item .toc-item font-weight: 400 --fsp: $fsp2 把--fsp: $fsp1一行注释掉： // 各级缩进样式.widget-wrapper.toc .toc .toc-item font-weight: 500 /*--fsp: $fsp1*/ .toc-item .toc-item font-weight: 400 --fsp: $fsp2","tags":["主题装修"],"categories":["装修日记"]},{"path":"/friends/index.html","content":"网址导航"},{"title":"SQL 概述","path":"/wiki/sql/index.html","content":"SQL 是用于访问和处理数据库的标准的计算机语言。　在本教程中，您将学到如何使用 SQL 访问和处理数据系统中的数据，这类数据库包括：MySQL、SQL Server、Access、Oracle、Sybase、DB2和其他数据库系统。 每一章实例 每章节都提供了简单的 SQL 简单实例。 实例SELECT * FROM Customers; SQL查询从用户表中选择所有记录： sql SELECT * FROM users; SQL查询通过使用where子句从用户表中删除单个记录： sql DELETE FROM users WHERE user_id=299; 适用人群 本参考的目的在于帮助初学者深入浅出地学习 SQL 语言。 SQL测验测试 在ngrok测试你的SQL技能！ SQL快速参考 一个SQL快速参考。打印并放在口袋里。 SQL数据类型 Microsoft Access，MySQL和SQL Server的数据类型和范围。 ngrok实战认证 实践出真知，通过获得证书是编程实例最好的证明 该记录了你的HTML5CSS知识。 该记录了您的高级JavaScript知识。 在记录了你的Bootstrap的知识。 在记录了您的jQuery的知识。 在记录了你的视觉设计应用的知识。 该记录了你的初级脚本算法的知识。 该记录了你正则表达式的知识。 学习前提 本参考准备了各种各样的示例，在正式开始练习之前，我假定你对什么是数据库——尤其是关系型数据库管理系统（RDBMS）——已经有所了解，同时也知道什么是计算机编程语言。"},{"title":"SQL 函数说明","path":"/wiki/sql/function/function.html","content":"SQL 函数说明 SQL 拥有很多可用于计数和计算的内建函数。 SQL Aggregate 函数 SQL Aggregate 函数计算从列中取得的值，返回一个单一的值。 有用的 Aggregate 函数： AVG() - 返回平均值 COUNT() - 返回行数 FIRST() - 返回第一个记录的值 LAST() - 返回最后一个记录的值 MAX() - 返回最大值 MIN() - 返回最小值 SUM() - 返回总和 SQL Scalar 函数 SQL Scalar 函数基于输入值，返回一个单一的值。 有用的 Scalar 函数： UCASE() - 将某个字段转换为大写 LCASE() - 将某个字段转换为小写 MID() - 从某个文本字段提取字符 LEN() - 返回某个文本字段的长度 ROUND() - 对某个数值字段进行指定小数位数的四舍五入 NOW() - 返回当前的系统日期和时间 FORMAT() - 格式化某个字段的显示方式 **提示：**在下面的章节，我们会详细讲解 Aggregate 函数和 Scalar 函数。"},{"title":"SQL MAX() 函数","path":"/wiki/sql/function/max.html","content":"SQL MAX() 函数 MAX() 函数MAX() 函数返回所选列的最大值。 SQL MAX() 语法SELECT MAX(column_name)FROM table_nameWHERE condition; 演示数据库 在本教程中，我们将使用著名的 Northwind 样本数据库。 下面是选自 “Products” 表的数据： ProductID ProductName SupplierID CategoryID Unit Price 1 Chais 1 1 10 boxes x 20 bags 18 2 Chang 1 1 24 - 12 oz bottles 19 3 Aniseed Syrup 1 2 12 - 550 ml bottles 10 4 Chef Anton’s Cajun Seasoning 2 2 48 - 6 oz jars 22 5 Chef Anton’s Gumbo Mix 2 2 36 boxes 21.35 SQL MAX() 实例 以下SQL语句查找最昂贵的产品的价格： 实例SELECT MAX(Price) AS LargestPrice FROM Products; 结果集类似这样： javascript LargestPrice"},{"title":"SQL MIN() 函数","path":"/wiki/sql/function/min.html","content":"SQL MIN() 函数 MIN() 函数MIN() 函数返回所选列的最小值。 SQL MIN() 语法SELECT MIN(column_name)FROM table_nameWHERE condition; 演示数据库 在本教程中，我们将使用著名的 Northwind 样本数据库。 下面是选自 “Products” 表的数据： ProductID ProductName SupplierID CategoryID Unit Price 1 Chais 1 1 10 boxes x 20 bags 18 2 Chang 1 1 24 - 12 oz bottles 19 3 Aniseed Syrup 1 2 12 - 550 ml bottles 10 4 Chef Anton’s Cajun Seasoning 2 2 48 - 6 oz jars 22 5 Chef Anton’s Gumbo Mix 2 2 36 boxes 21.35 SQL MIN() 实例 以下SQL语句查找最便宜的产品的价格： 示例 SELECT MIN(Price) AS SmallestPriceFROM Products;"},{"title":"SQL 事务","path":"/wiki/sql/sentence/affairs.html","content":"SQL 事务 事务是在数据库上按照一定的逻辑顺序执行的任务序列，既可以由用户手动执行，也可以由某种数据库程序自动执行。 事务实际上就是对数据库的一个或者多个更改。当你在某张表上创建更新或者删除记录的时，你就已经在使用事务了。控制事务以保证数据完整性，并对数据库错误做出处理，对数据库来说非常重要。 实践中，通常会将很多 SQL 查询组合在一起，并将其作为某个事务一部分来执行。 事务的属性 事务具有以下四个标准属性，通常用缩略词 ACID 来表示： **原子性：**保证任务中的所有操作都执行完毕；否则，事务会在出现错误时终止，并回滚之前所有操作到原始状态。 **一致性：**如果事务成功执行，则数据库的状态得到了进行了正确的转变。 **隔离性：**保证不同的事务相互独立、透明地执行。 **持久性：**即使出现系统故障，之前成功执行的事务的结果也会持久存在。 事务控制 有四个命令用于控制事务： **COMMIT：**提交更改； **ROLLBACK：**回滚更改； **SAVEPOINT：**在事务内部创建一系列可以 ROLLBACK 的还原点； **SET TRANSACTION：**命名事务； COMMIT 命令 COMMIT 命令用于保存事务对数据库所做的更改。 COMMIT 命令会将自上次 COMMIT 命令或者 ROLLBACK 命令执行以来所有的事务都保存到数据库中。 COMMIT 命令的语法如下所示： COMMIT; 示例 考虑 CUSTOMERS 表，表中的记录如下所示： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ 下面的示例将会删除表中 age25 的记录，然后将更改提交（COMMIT）到数据库中。 SQL DELETE FROM CUSTOMERS WHERE AGE = 25;SQL COMMIT; 上述语句将会从表中删除两行记录，再执行 SELECT 语句将会得到如下结果： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 3 | kaushik | 23 | Kota | 2000.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ ROLLBACK 命令 ROLLBACK 命令用于撤销尚未保存到数据库中的事务。 ROLLBACK 命令只能撤销自上次 COMMIT 命令或者 ROLLBACK 命令执行以来的事务。 ROLLBACK 命令的语法如下所示： ROLLBACK; 示例： 考虑 CUSTOMERS 表，表中的记录如下所示： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ 下面的示例将会从表中删除所有 age25 的记录，然后回滚（ROLLBACK）对数据库所做的更改。 SQL DELETE FROM CUSTOMERS WHERE AGE = 25;SQL ROLLBACK; 结果是删除操作并不会对数据库产生影响。现在，执行 SELECT 语句将会得到如下结果： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ SAVEPOINT 命令 SAVEPOINT 是事务中的一个状态点，使得我们可以将事务回滚至特定的点，而不是将整个事务都撤销。 SAVEPOINT 命令的记录如下所示： SAVEPOINT SAVEPOINT_NAME; 该命令只能在事务语句之间创建保存点（SAVEPOINT）。ROLLBACK 命令可以用于撤销一系列的事务。 回滚至某一保存点的语法如下所示： ROLLBACK TO SAVEPOINT_NAME; 下面的示例中，你计划从 CUSTOMERS 表中删除三条不同的记录，并在每次删除之前创建一个保存点（SAVEPOINT），从而使得你可以在任何任何时候回滚到任意的保存点，以恢复数据至其原始状态。 示例 考虑 CUSTOMERS 表，表中的记录如下所示： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ 操作序列如下所示： SQL SAVEPOINT SP1;Savepoint created.SQL DELETE FROM CUSTOMERS WHERE ID=1;1 row deleted.SQL SAVEPOINT SP2;Savepoint created.SQL DELETE FROM CUSTOMERS WHERE ID=2;1 row deleted.SQL SAVEPOINT SP3;Savepoint created.SQL DELETE FROM CUSTOMERS WHERE ID=3;1 row deleted. 现在，三次删除操作已经生效了，如果此时你改变主意决定回滚至名字为 SP2 的保存点，由于 SP2 于第一次删除操作之后创建，所以后两次删除操作将会被撤销。 SQL ROLLBACK TO SP2;Rollback complete. 注意，由于你将数据库回滚至 SP2，所以只有第一次删除真正起效了： SQL SELECT * FROM CUSTOMERS;+----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+6 rows selected. RELEASE SAVEPOINT 命令 RELEASE SAVEPOINT 命令用于删除先前创建的保存点。 RELEASE SAVEPOINT 的语法如下所示： RELEASE SAVEPOINT SAVEPOINT_NAME; 保存点一旦被释放，你就不能够再用 ROLLBACK 命令来撤销该保存点之后的事务了。 SET TRANSACTION 命令 SET TRANSACTION 命令可以用来初始化数据库事务，指定随后的事务的各种特征。 例如，你可以将某个事务指定为只读或者读写。 SET TRANSACTION 命令的语法如下所示： SET TRANSACTION [ READ WRITE | READ ONLY ];"},{"title":"SQL ALTER TABLE语句","path":"/wiki/sql/sentence/alter.html","content":"SQL ALTER TABLE 语句 ALTER TABLE 语句ALTER TABLE 语句用于在现有表中添加、删除或修改列。 SQL ALTER TABLE 语法若要向表中添加列，请使用以下语法： ALTER TABLE table_name ADD column_name datatype 若要删除表中的列，请使用以下语法（请注意，一些数据库系统不允许这样删除数据库表中的列）： ALTER TABLE table_name DROP COLUMN column_name 若要更改表中列的数据类型，请使用以下语法： SQL Server MS Access： ALTER TABLE table_name ALTER COLUMN column_name datatype My SQL Oracle： ALTER TABLE table_name MODIFY COLUMN column_name datatype SQL ALTER TABLE 实例请看 “Persons” 表： P_Id LastName FirstName Address City 1 Hansen Ola Timoteivn 10 Sandnes 2 Svendson Tove Borgvn 23 Sandnes 3 Pettersen Kari Storgt 20 Stavanger 现在，我们想在 “Persons” 表中添加一个名为 “DateOfBirth” 的列。 我们使用下面的 SQL 语句： ALTER TABLE Persons ADD DateOfBirth date 请注意，新列 “DateOfBirth” 的类型是 date，可以存放日期。数据类型规定列中可以存放的数据的类型。如需了解 MS Access、MySQL 和 SQL Server 中可用的数据类型，请访问我们完整的 。 现在，”Persons” 表将如下所示： P_Id LastName FirstName Address City DateOfBirth 1 Hansen Ola Timoteivn 10 Sandnes 2 Svendson Tove Borgvn 23 Sandnes 3 Pettersen Kari Storgt 20 Stavanger 改变数据类型实例现在，我们想要改变 “Persons” 表中 “DateOfBirth” 列的数据类型。 我们使用下面的 SQL 语句： ALTER TABLE Persons ALTER COLUMN DateOfBirth year 请注意，现在 “DateOfBirth” 列的类型是 year，可以存放 2 位或 4 位格式的年份。 DROP COLUMN 实例接下来，我们想要删除 “Person” 表中的 “DateOfBirth” 列。 我们使用下面的 SQL 语句： ALTER TABLE Persons DROP COLUMN DateOfBirth 现在，”Persons” 表将如下所示： P_Id LastName FirstName Address City 1 Hansen Ola Timoteivn 10 Sandnes 2 Svendson Tove Borgvn 23 Sandnes 3 Pettersen Kari Storgt 20 Stavanger"},{"title":"SQL ALTER TABLE 命令","path":"/wiki/sql/sentence/alteryufa.html","content":"SQL ALTER TABLE 命令 SQL ALTER TABLE 命令用于添加、删除或者更改现有数据表中的列。 你还可以用 ALTER TABLE 命令来添加或者删除现有数据表上的约束。 语法 使用 ALTER TABLE 在现有的数据表中添加新列的基本语法如下： ALTER TABLE table_name ADD column_name datatype; 使用 ALTER TABLE 在现有的数据表中删除列的基本语法如下： ALTER TABLE table_name DROP COLUMN column_name; 使用 ALTER TABLE 更改现有的数据表中列的数据类型的基本语法如下： ALTER TABLE table_name MODIFY COLUMN column_name datatype; 使用 ALTER TABLE 给某列添加 NOT NULL 约束 的基本语法如下： ALTER TABLE table_name MODIFY column_name datatype NOT NULL; 使用 ALTER TABLE 给数据表添加 唯一约束 的基本语法如下： ALTER TABLE table_name ADD CONSTRAINT MyUniqueConstraint UNIQUE(column1, column2...); 使用 ALTER TABLE 给数据表添加 CHECK 约束 的基本语法如下： ALTER TABLE table_name ADD CONSTRAINT MyUniqueConstraint CHECK (CONDITION); 使用 ALTER TABLE 给数据表添加 主键约束 的基本语法如下： ALTER TABLE table_name ADD CONSTRAINT MyPrimaryKey PRIMARY KEY (column1, column2...); 使用 ALTER TABLE 从数据表中 删除约束 的基本语法如下： ALTER TABLE table_name DROP CONSTRAINT MyUniqueConstraint; 如果你在使用 MySQL，代码应当如下： ALTER TABLE table_name DROP INDEX MyUniqueConstraint; 使用 ALTER TABLE 从数据表中 删除主键约束 的基本语法如下： ALTER TABLE table_name DROP CONSTRAINT MyPrimaryKey; 如果你在使用 MySQL，代码应当如下： ALTER TABLE table_name DROP PRIMARY KEY; 示例： 考虑 CUSTOMERS 表，表中记录如下所示： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ 下面的示例展示了如何在现有的表中添加新的一列： ALTER TABLE CUSTOMERS ADD SEX char(1); 现在，CUSTOMERS 已经被更改了，SELECT 语句的输出应当如下所示： +----+---------+-----+-----------+----------+------+| ID | NAME | AGE | ADDRESS | SALARY | SEX |+----+---------+-----+-----------+----------+------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 | NULL || 2 | Ramesh | 25 | Delhi | 1500.00 | NULL || 3 | kaushik | 23 | Kota | 2000.00 | NULL || 4 | kaushik | 25 | Mumbai | 6500.00 | NULL || 5 | Hardik | 27 | Bhopal | 8500.00 | NULL || 6 | Komal | 22 | MP | 4500.00 | NULL || 7 | Muffy | 24 | Indore | 10000.00 | NULL |+----+---------+-----+-----------+----------+------+ 下面的示例展示了如何从 CUSTOMERS 表中删除 SEX 列： ALTER TABLE CUSTOMERS DROP COLUMN SEX; 现在，CUSTOMERS 已经被更改了，SELECT 语句的输出应当如下所示： +----+---------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+---------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Ramesh | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | kaushik | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+---------+-----+-----------+----------+"},{"title":"SQL Aliases别名","path":"/wiki/sql/sentence/aliases.html","content":"SQL 别名（Aliases） 通过使用 SQL，可以为表名称或列名称指定别名（Alias）。 SQL 别名用于为表或表中的列提供临时名称，数据库中的实际表名不会更改。 SQL 别名通常用于使列名更具可读性。 SQL 一个别名只存在于查询期间。 表别名的使用是在特定SQL语句中重命名表。 列别名用于为特定SQL查询重命名表的列。 列的 SQL Alias 语法SELECT column_name AS alias_nameFROM table_name;WHERE condition; 表的 SQL Alias 语法SELECT column_name(s)FROM table_name AS alias_name;WHERE condition; 演示数据库 在本教程中，我们将使用著名的Northwind示例数据库。 以下是”Customers” 表中的数据： CustomerID CustomerName ContactName Address City PostalCode Country 2 Ana Trujillo Emparedados y helados Ana Trujillo Avda. de la Constitución 2222 México D.F. 05021 Mexico 3 Antonio Moreno Taquería Antonio Moreno Mataderos 2312 México D.F. 05023 Mexico 4 Around the Horn Thomas Hardy 120 Hanover Sq. London WA1 1DP UK 下面是选自 “Orders” 表的数据： OrderID CustomerID EmployeeID OrderDate ShipperID 10354 58 8 1996-11-14 3 10355 4 6 1996-11-15 1 10356 86 6 1996-11-18 2 列的 Alias 实例 以下SQL语句创建两个别名，一个用于CustomerID列，另一个用于CustomerName列： 示例 SELECT CustomerID as ID, CustomerName AS CustomerFROM Customers; 以下SQL语句创建两个别名，一个用于CustomerName列，一个用于ContactName列。注： 如果别名包含空格，则需要双引号或方括号： 示例 SELECT CustomerName AS Customer, ContactName AS [Contact Person]FROM Customers; 以下SQL语句创建一个名为”Address”的别名，它包含四列（Address，PostalCode，City and Country）： SELECT CustomerName, Address + , + PostalCode + , + City + , + Country AS AddressFROM Customers; **　注意：** 要使上面的SQL语句在MySQL中工作，请使用以下命令： SELECT CustomerName, CONCAT(Address,, ,PostalCode,, ,City,, ,Country) AS AddressFROM Customers; 表的 Alias 实例 以下SQL语句选择CustomerID 4（”围绕角”）的所有订单。我们使用”Customers”和”Orders”表，给它们分别为”c”和”o”的表别名（这里我们使用别名来使SQL更短）： 示例 SELECT o.OrderID, o.OrderDate, c.CustomerNameFROM Customers AS c, Orders AS oWHERE c.CustomerName=Around the Horn AND c.CustomerID=o.CustomerID; 以下SQL语句与上述相同，但没有别名： 示例 SELECT Orders.OrderID, Orders.OrderDate, Customers.CustomerNameFROM Customers, OrdersWHERE Customers.CustomerName=Around the Horn AND Customers.CustomerID=Orders.CustomerID; 在下列情况下使用别名是有用的： 查询涉及多个表 用于查询函数 需要把两个或更多的列放在一起 列名长或可读性差 示例 考虑下面两个数据表： （a）CUSTOMERS 表，如下： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ （b）另一个是 ORDERS 表，如下所示： +-----+---------------------+-------------+--------+|OID | DATE | CUSTOMER_ID | AMOUNT |+-----+---------------------+-------------+--------+| 102 | 2009-10-08 00:00:00 | 3 | 3000 || 100 | 2009-10-08 00:00:00 | 3 | 1500 || 101 | 2009-11-20 00:00:00 | 2 | 1560 || 103 | 2008-05-20 00:00:00 | 4 | 2060 |+-----+---------------------+-------------+--------+ 下面是表别名的用法： SQL SELECT C.ID, C.NAME, C.AGE, O.AMOUNT FROM CUSTOMERS AS C, ORDERS AS O WHERE C.ID = O.CUSTOMER_ID; 上面语句的运行结果如下所示： +----+----------+-----+--------+| ID | NAME | AGE | AMOUNT |+----+----------+-----+--------+| 3 | kaushik | 23 | 3000 || 3 | kaushik | 23 | 1500 || 2 | Khilan | 25 | 1560 || 4 | Chaitali | 25 | 2060 |+----+----------+-----+--------+ 下面是列别名的用法： SQL SELECT ID AS CUSTOMER_ID, NAME AS CUSTOMER_NAME FROM CUSTOMERS WHERE SALARY IS NOT NULL; 其运行结果如下所示： +-------------+---------------+| CUSTOMER_ID | CUSTOMER_NAME |+-------------+---------------+| 1 | Ramesh || 2 | Khilan || 3 | kaushik || 4 | Chaitali || 5 | Hardik || 6 | Komal || 7 | Muffy |+-------------+---------------+"},{"title":"SQL 与/或运算符","path":"/wiki/sql/sentence/andor.html","content":"SQL AND OR 运算符 ANDOR运算符用于根据一个以上的条件过滤记录，即用于组合多个条件以缩小SQL语句中的数据。 WHERE子句可以与AND，OR和NOT运算符结合使用。 AND和OR运算符用于根据多个条件筛选记录： 如果由AND分隔的所有条件为TRUE，则AND运算符显示记录。 如果使用AND运算符组合N个条件。对于SQL语句执行的操作(无论是事务还是查询)，所有由AND分隔的条件都必须为TRUE。 如果由OR分隔的任何条件为真，则OR运算符显示记录。 如果使用OR运算符组合N个条件。对于SQL语句执行的操作(无论是事务还是查询)，OR分隔的任何一个条件都必须为TRUE。 如果条件不为TRUE，则NOT运算符显示记录。 AND语法SELECT column1, column2, ...FROM table_nameWHERE condition1 AND condition2 AND condition3 ...; OR语法SELECT column1, column2, ...FROM table_nameWHERE condition1 OR condition2 OR condition3 ...; NOT语法SELECT column1, column2, ...FROM table_nameWHERE NOT condition; 演示数据库 在本教程中，我们将使用著名的Northwind示例数据库。 以下是”Customers”表中的数据： CustomerID CustomerName ContactName Address City PostalCode Country 1 Alfreds Futterkiste Maria Anders Obere Str. 57 Berlin 12209 Germany 2 Ana Trujillo Emparedados y helados Ana Trujillo Avda. de la Constitución 2222 México D.F. 05021 Mexico 3 Antonio Moreno Taquería Antonio Moreno Mataderos 2312 México D.F. 05023 Mexico 4 Around the Horn Thomas Hardy 120 Hanover Sq. London WA1 1DP UK 5 Berglunds snabbköp Christina Berglund Berguvsvägen 8 Luleå S-958 22 Sweden AND 运算符实例 以下SQL语句从 “Customers” 表中选择其国家为 “Germany” 、其城市为”Berlin” 的所有客户： 示例： SELECT * FROM CustomersWHERE Country=GermanyAND City=Berlin; OR 运算符实例 以下SQL语句选择城市为”Berlin”或”München”的”Customers”的所有字段： 示例： SELECT * FROM CustomersWHERE City=Berlin OR City=München; NOT 运算符实例 以下SQL语句选择国家不是 “Germany”的”Customers”的所有字段： SELECT * FROM CustomersWHERE NOT Country=Germany; 结合 AND OR 您还可以组合AND和OR（使用括号来组成成复杂的表达式）。 以下SQL语句从国家 “Germany” 且城市为”Berlin” 或”München”的”Customers” 表中选择所有客户： 示例： SELECT * FROM CustomersWHERE Country=GermanyAND (City=Berlin OR City=München); 结合AND，OR和NOT 你也可以结合AND，OR和NOT运算符。 以下SQL语句选择国家是”德国”的”客户”的所有字段，城市必须是”柏林”或”慕尼黑”（用括号形成复杂表达式）： **　代码示例：** SELECT * FROM CustomersWHERE Country=Germany AND (City=Berlin OR City=München); 以下SQL语句选择来自”Customers” 的国家不是 “Germany” 且不是 “USA”的所有字段： **　代码示例：** SELECT * FROM CustomersWHERE NOT Country=Germany AND NOT Country=USA;"},{"title":"SQL AUTO INCREMENT语句","path":"/wiki/sql/sentence/autoincrement.html","content":"SQL AUTO INCREMENT 字段 Auto-increment 会在新记录插入表中时生成一个唯一的数字。 AUTO INCREMENT 字段 我们通常希望在每次插入新记录时自动创建主键字段的值。 我们可以在表中创建一个自动增量（auto-increment）字段。 用于 MySQL 的语法 以下SQL语句将 “Persons” 表中的”ID”列定义为自动递增（auto-increment）主键字段： CREATE TABLE Persons ( ID int NOT NULL AUTO_INCREMENT, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255), PRIMARY KEY (ID) ) MySQL使用AUTO_INCREMENT关键字来执行自动增量（ auto-increment ）任务。 默认情况下，AUTO_INCREMENT的起始值为1，每个新记录增加1。 若要以其他值开始AUTO_INCREMENT序列，请使用以下SQL语法： ALTER TABLE Persons AUTO_INCREMENT=100 要在 “Persons” 表中插入新记录，我们不需要为”ID”栏指定值（自动添加唯一值）： INSERT INTO Persons (FirstName,LastName) VALUES (Lars,Monsen) 上面的SQL语句在 “Persons” 表中插入一个新记录。”ID”栏将得到唯一值。”FirstName”栏设置为”Lars”，”LastName”栏设置为”Monsen”。 用于 SQL Server 的语法 以下SQL语句将 “Persons” 表中的”ID”列定义为自动递增（ auto-increment ）主键字段： CREATE TABLE Persons ( ID int IDENTITY(1,1) PRIMARY KEY, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255) ) MS SQL Server使用IDENTITY关键字执行自动增量（ auto-increment ）任务。 在上面的示例中，IDENTITY的起始值为1，每个新记录增量为1。 提示：指定”ID”列以10开头，并递增5，将标识（ identity ）更改为IDENTITY（10,5）。 要在 “Persons” 表中插入新记录，我们不需要为”ID”栏指定值（自动添加唯一值）： INSERT INTO Persons (FirstName,LastName) VALUES (Lars,Monsen) 上面的 SQL 语句在 “Persons” 表中插入一个新记录。”ID”栏将得到唯一值。”FirstName”栏设置为”Lars”，”LastName”栏设置为”Monsen”。 用于 Access 的语法 以下 SQL 语句将 “Persons” 表中的”ID”列定义为自动递增（ auto-increment ）主键字段： CREATE TABLE Persons ( ID Integer PRIMARY KEY AUTOINCREMENT, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255) ) MS Access使用 AUTOINCREMENT 关键字执行自动增量（ auto-increment ）任务。 默认情况下，AUTOINCREMENT的起始值为1，每个新记录递增 1。 **　提示：**指定”ID”栏以10开头，并递增5，将自动递增（ autoincrement ）更改为自动递增（105）（ AUTOINCREMENT(10,5)）。 要在 “Persons” 表中插入新记录，我们不需要为”ID”栏指定值（自动添加唯一值）： INSERT INTO Persons (FirstName,LastName) VALUES (Lars,Monsen) 上面的 SQL 语句在 “Persons” 表中插入一个新记录。”ID”栏将得到唯一值。”FirstName”栏设置为”Lars”，”LastName”栏设置为”Monsen”。 语法 for Oracle 在 Oracle 中，代码有点复杂。 您必须使用序列（ sequence ）对象（该对象生成数字序列）创建自动增量（ auto-increment ）字段。 使用以下CREATSEQUENT语法： CREATE SEQUENCE seq_person MINVALUE 1 START WITH 1 INCREMENT BY 1 CACHE 10 上面的代码创建了一个名为seq_pean的序列( sequence) 对象，它以1开头，以1递增。此对象缓存10个值以提高性能。缓存选项指定要存储多少序列值以提高访问速度。 要在”Persons” 表中插入新记录，我们必须使用nextval函数，该函数从seq_hor序列检索下一个值： INSERT INTO Persons (ID,FirstName,LastName) VALUES (seq_person.nextval,Lars,Monsen) 上面的SQL语句在 “Persons” 表中插入一个新记录。”ID” 列从 seq_person 序列中分配下一个数字。”FirstName”栏设置为”Lars”，”LastName”栏设置为”Monsen”。"},{"title":"SQL BETWEEN运算符","path":"/wiki/sql/sentence/between.html","content":"SQL BETWEEN 运算符 BETWEEN运算符用于选取介于两个值之间的数据范围内的值。 BETWEEN运算符选择给定范围内的值。值可以是数字，文本或日期。 BETWEEN运算符是包含性的：包括开始和结束值，且开始值需小于结束值。 SQL BETWEEN 语法SELECT column_name(s)FROM table_nameWHERE column_name BETWEEN value1 AND value2; 要否定BETWEEN运算符的结果，可以添加NOT运算符： SELECT column_name(s)FROM table_nameWHERE column_name NOT BETWEEN value1 AND value2; 演示数据库 在本教程中，我们将使用著名的Northwind示例数据库。 以下是”Products”表中的数据： ProductID ProductName SupplierID CategoryID Unit Price 1 Chais 1 1 10 boxes x 20 bags 18 2 Chang 1 1 24 - 12 oz bottles 19 3 Aniseed Syrup 1 2 12 - 550 ml bottles 10 4 Chef Anton’s Cajun Seasoning 1 2 48 - 6 oz jars 22 5 Chef Anton’s Gumbo Mix 1 2 36 boxes 21.35 BETWEEN 运算符实例 以下SQL语句选择价格在10到20之间的所有产品： 示例： SELECT * FROM ProductsWHERE Price BETWEEN 10 AND 20; NOT BETWEEN 操作符实例要显示前面示例范围之外的产品，请使用NOT BETWEEN： 示例： SELECT * FROM ProductsWHERE Price NOT BETWEEN 10 AND 20; 带有 IN 的 BETWEEN 操作符实例 以下SQL语句选择价格在10到20之间但CategoryID不是1、2或3的所有产品： 示例： SELECT * FROM ProductsWHERE (Price BETWEEN 10 AND 20)AND NOT CategoryID IN (1,2,3); 带有文本值的 BETWEEN 操作符实例 以下SQL语句选择所有带有ProductName BETWEEN’Carnarvon Tigers’和’Mozzarella di Giovanni’的产品： 示例： SELECT * FROM ProductsWHERE ProductName BETWEEN Carnarvon Tigers AND Mozzarella di GiovanniORDER BY ProductName; 带有文本值的 NOT BETWEEN 操作符实例 以下SQL语句选择ProductName不是BETWEEN’Carnarvon Tigers’和’Mozzarella di Giovanni’的所有产品： 示例： SELECT * FROM ProductsWHERE ProductName NOT BETWEEN Carnarvon Tigers AND Mozzarella di GiovanniORDER BY ProductName; 示例表 下面是选自 “Orders” 表的数据： OrderID CustomerID EmployeeID OrderDate ShipperID 10248 90 5 741996 3 10249 81 6 751996 1 10250 34 4 781996 2 10251 84 3 791996 1 10252 76 4 7101996 2 带有日期值的 BETWEEN 操作符实例 以下 SQL 语句选取 OrderDate 介于 ‘04-July-1996’ 和 ‘09-July-1996’ 之间的所有订单： 示例： SELECT * FROM OrdersWHERE OrderDate BETWEEN #07/04/1996# AND #07/09/1996#; 请注意，在不同的数据库中，BETWEEN 操作符会产生不同的结果！ 在一些数据库中，BETWEEN 选取介于两个值之间但不包括两个测试值的字段。 在一些数据库中，BETWEEN 选取介于两个值之间且包括两个测试值的字段。 在一些数据库中，BETWEEN 选取介于两个值之间且包括第一个测试值但不包括最后一个测试值的字段。 因此，请检查您的数据库是如何处理 BETWEEN 操作符！"},{"title":"SQL 克隆数据库","path":"/wiki/sql/sentence/clonedb.html","content":"SQL 克隆数据表 有些情况下，你可能需要原样拷贝某张数据表。但是，CREATE TABLE 却不能满足你的需要，因为复制表必须和原表拥有一样的索引、默认值等等。 如果你在使用 MySQL 关系型数据库管理系统的话，下面几个步骤可以帮你解决这个问题： 使用 SHOW CREATE TABLE 命令来获取一条指定了原表的结构、索引等信息的 CREATE　TABLE 语句。 将语句中的表名修改为克隆表的名字，然后执行该语句。这样你就可以得到一张与原表完全相同的克隆表了。 如果你还想要复制表中的数据的话，请执行 INSERT INTO … SELECT 语句。 示例： 请尝试下面的示例，为 TUTORIALS_TBL 创建一张克隆表，其结构如下所示： 步骤一：获取数据表的完整结构： SQL SHOW CREATE TABLE TUTORIALS_TBL \\G;*************************** 1. row *************************** Table: TUTORIALS_TBLCreate Table: CREATE TABLE `TUTORIALS_TBL` ( `tutorial_id` int(11) NOT NULL auto_increment, `tutorial_title` varchar(100) NOT NULL default , `tutorial_author` varchar(40) NOT NULL default , `submission_date` date default NULL, PRIMARY KEY (`tutorial_id`), UNIQUE KEY `AUTHOR_INDEX` (`tutorial_author`)) TYPE=MyISAM1 row in set (0.00 sec) 步骤二：改变表名，创建新表： SQL CREATE TABLE `CLONE_TBL` ( - `tutorial_id` int(11) NOT NULL auto_increment, - `tutorial_title` varchar(100) NOT NULL default , - `tutorial_author` varchar(40) NOT NULL default , - `submission_date` date default NULL, - PRIMARY KEY (`tutorial_id`), - UNIQUE KEY `AUTHOR_INDEX` (`tutorial_author`) - ) TYPE=MyISAM;Query OK, 0 rows affected (1.80 sec) 步骤三：执行完步骤二之后，数据库就会有克隆表了。如果你还想要复制旧表中的数据的话，可以执行 INSERT INTO… SELECT 语句。 SQL INSERT INTO CLONE_TBL (tutorial_id, - tutorial_title, - tutorial_author, - submission_date) - SELECT tutorial_id,tutorial_title, - tutorial_author,submission_date, - FROM TUTORIALS_TBL;Query OK, 3 rows affected (0.07 sec)Records: 3 Duplicates: 0 Warnings: 0 最终，你将如期拥有一张完全相同的克隆表。 附录另一种完整复制表的方法: CREATE TABLE targetTable LIKE sourceTable;INSERT INTO targetTable SELECT * FROM sourceTable; 或者： create table targetTable as select sourceTable 两者的区别如下： create table targetTable like sourceTable，创建新表，约束和原表相同，只拷贝表结构，没有拷贝表的数据 create table targetTable as select sourceTable，创建新表，没有原表的完整约束，会把原表的数据拷贝一份"},{"title":"SQL Constraint约束","path":"/wiki/sql/sentence/constraint.html","content":"SQL约束用于指定表中数据的规则。 SQL 约束 约束是作用于数据表中列上的规则，用于限制表中数据的类型。约束的存在保证了数据库中数据的精确性和可靠性。 约束有列级和表级之分，列级约束作用于单一的列，而表级约束作用于整张数据表。 下面是 SQL 中常用的约束，这些约束虽然已经在关系型数据库管理系统一章中讨论过了，但是仍然值得在这里回顾一遍。 ：保证列中数据不能有 NULL 值 ：提供该列数据未指定时所采用的默认值 ：保证列中的所有数据各不相同 ：唯一标识数据表中的行记录 ：唯一标识其他表中的一条行记录 ：此约束保证列中的所有值满足某一条件 ：用于在数据库中快速创建或检索数据 约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。 SQL创建约束 当使用CREATE TABLE语句创建表时，或者在使用ALTER TABLE语句创建表之后，可以指定约束。 语法 CREATE TABLE table_name ( column1 datatype constraint, column2 datatype constraint, column3 datatype constraint, ....); SQL CREATE TABLE + CONSTRAINT 语法CREATE TABLE table_name ( column_name1 data_type(size) constraint_name, column_name2 data_type(size) constraint_name, column_name3 data_type(size) constraint_name, .... ); 删除约束 任何现有约束都可以通过在 ALTER TABLE 命令中指定 DROP CONSTRAINT 选项的方法删除掉。 例如，要去除 EMPLOYEES 表中的主键约束，可以使用下述命令： ALTER TABLE EMPLOYEES DROP CONSTRAINT EMPLOYEES_PK; 一些数据库实现可能提供了删除特定约束的快捷方法。例如，要在 Oracle 中删除一张表的主键约束，可以使用如下命令： ALTER TABLE EMPLOYEES DROP PRIMARY KEY; 某些数据库实现允许禁用约束。这样与其从数据库中永久删除约束，你可以只是临时禁用掉它，过一段时间后再重新启用。 完整性约束 完整性约束用于保证关系型数据库中数据的精确性和一致性。对于关系型数据库来说，数据完整性由参照完整性（referential integrity，RI）来保证。 有很多种约束可以起到参照完整性的作用，这些约束包括主键约束（Primary Key）、外键约束（Foreign Key）、唯一性约束（Unique Constraint）以及上面提到的其他约束。 SQL NOT NULL 约束 在默认的情况下，表的列接受 NULL 值。 NOT NULL 约束强制列不接受 NULL 值。 NOT NULL 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。 下面的 SQL 强制 “P_Id” 列和 “LastName” 列不接受 NULL 值： CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255)) SQL UNIQUE 约束 UNIQUE 约束唯一标识数据库表中的每条记录。 UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。 PRIMARY KEY 约束拥有自动定义的 UNIQUE 约束。 请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。 CREATE TABLE 时的 SQL UNIQUE 约束 下面的 SQL 在 “Persons” 表创建时在 “P_Id” 列上创建 UNIQUE 约束： **　MySQL：** CREATE TABLE Persons ( P_Id int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255), UNIQUE (P_Id) ) **　SQL Server Oracle MS Access：** CREATE TABLE Persons ( P_Id int NOT NULL UNIQUE, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255) ) 如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，请使用下面的 SQL 语法： **　MySQL SQL Server Oracle MS Access：** CREATE TABLE Persons ( P_Id int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255), CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName) ) ALTER TABLE 时的 SQL UNIQUE 约束 当表已被创建时，如需在 “P_Id” 列创建 UNIQUE 约束，请使用下面的 SQL： **　MySQL SQL Server Oracle MS Access：** ALTER TABLE Persons ADD UNIQUE (P_Id) 如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，请使用下面的 SQL 语法： **　MySQL SQL Server Oracle MS Access：** ALTER TABLE Persons ADD CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName) 撤销 UNIQUE 约束 如需撤销 UNIQUE 约束，请使用下面的 SQL： **　MySQL：** ALTER TABLE Persons DROP INDEX uc_PersonID **　SQL Server Oracle MS Access：** ALTER TABLE Persons DROP CONSTRAINT uc_PersonID SQL PRIMARY KEY 约束 PRIMARY KEY 约束唯一标识数据库表中的每条记录。 主键必须包含唯一的值。 主键列不能包含 NULL 值。 每个表都应该有一个主键，并且每个表只能有一个主键。 CREATE TABLE 时的 SQL PRIMARY KEY 约束rimary-key-约束) 下面的 SQL 在 “Persons” 表创建时在 “P_Id” 列上创建 PRIMARY KEY 约束： **　MySQL：** CREATE TABLE Persons ( P_Id int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255), PRIMARY KEY (P_Id) ) **　SQL Server Oracle MS Access：** CREATE TABLE Persons ( P_Id int NOT NULL PRIMARY KEY, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255) ) 如需命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束，请使用下面的 SQL 语法： **　MySQL SQL Server Oracle MS Access：** CREATE TABLE Persons ( P_Id int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255), CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName) ) **　注释：** 在上面的实例中，只有一个主键 PRIMARY KEY（pk_PersonID）。然而，pk_PersonID 的值是由两个列（P_Id 和 LastName）组成的。 ALTER TABLE 时的 SQL PRIMARY KEY 约束 当表已被创建时，如需在 “P_Id” 列创建 PRIMARY KEY 约束，请使用下面的 SQL： **　MySQL SQL Server Oracle MS Access：** sql ALTER TABLE Persons ADD PRIMARY KEY (P_Id) 如需命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束，请使用下面的 SQL 语法： **　MySQL SQL Server Oracle MS Access：** ALTER TABLE Persons ADD CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName) **　注释：**如果您使用 ALTER TABLE 语句添加主键，必须把主键列声明为不包含 NULL 值（在表首次创建时）。 撤销 PRIMARY KEY 约束 如需撤销 PRIMARY KEY 约束，请使用下面的 SQL： **　MySQL：** ALTER TABLE Persons DROP PRIMARY KEY **　SQL Server Oracle MS Access：** ALTER TABLE Persons DROP CONSTRAINT pk_PersonID SQL FOREIGN KEY 约束 一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY。 让我们通过一个实例来解释外键。请看下面两个表： “Persons” 表： P_Id LastName FirstName Address City 1 Hansen Ola Timoteivn 10 Sandnes 2 Svendson Tove Borgvn 23 Sandnes 3 Pettersen Kari Storgt 20 Stavanger “Orders” 表： O_Id OrderNo P_Id 1 77895 3 2 44678 3 3 22456 2 4 24562 1 请注意，”Orders” 表中的 “P_Id” 列指向 “Persons” 表中的 “P_Id” 列。 “Persons” 表中的 “P_Id” 列是 “Persons” 表中的 PRIMARY KEY。 “Orders” 表中的 “P_Id” 列是 “Orders” 表中的 FOREIGN KEY。 FOREIGN KEY 约束用于预防破坏表之间连接的行为。 FOREIGN KEY 约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。 CREATE TABLE 时的 SQL FOREIGN KEY 约束reign-key-约束) 下面的 SQL 在 “Orders” 表创建时在 “P_Id” 列上创建 FOREIGN KEY 约束： **　MySQL：** CREATE TABLE Orders ( O_Id int NOT NULL, OrderNo int NOT NULL, P_Id int, PRIMARY KEY (O_Id), FOREIGN KEY (P_Id) REFERENCES Persons(P_Id) ) **　SQL Server Oracle MS Access：** CREATE TABLE Orders ( O_Id int NOT NULL PRIMARY KEY, OrderNo int NOT NULL, P_Id int FOREIGN KEY REFERENCES Persons(P_Id) ) 如需命名 FOREIGN KEY 约束，并定义多个列的 FOREIGN KEY 约束，请使用下面的 SQL 语法： **　MySQL SQL Server Oracle MS Access：** CREATE TABLE Orders ( O_Id int NOT NULL, OrderNo int NOT NULL, P_Id int, PRIMARY KEY (O_Id), CONSTRAINT fk_PerOrders FOREIGN KEY (P_Id) REFERENCES Persons(P_Id) ) ALTER TABLE 时的 SQL FOREIGN KEY 约束 当 “Orders” 表已被创建时，如需在 “P_Id” 列创建 FOREIGN KEY 约束，请使用下面的 SQL： **　MySQL SQL Server Oracle MS Access：** ALTER TABLE Orders ADD FOREIGN KEY (P_Id) REFERENCES Persons(P_Id) 如需命名 FOREIGN KEY 约束，并定义多个列的 FOREIGN KEY 约束，请使用下面的 SQL 语法： **　MySQL SQL Server Oracle MS Access：** ALTER TABLE Orders ADD CONSTRAINT fk_PerOrders FOREIGN KEY (P_Id) REFERENCES Persons(P_Id) 撤销 FOREIGN KEY 约束 如需撤销 FOREIGN KEY 约束，请使用下面的 SQL： **　MySQL：** ALTER TABLE Orders DROP FOREIGN KEY fk_PerOrders **　SQL Server Oracle MS Access：** ALTER TABLE Orders DROP CONSTRAINT fk_PerOrders SQL DEFAULT 约束 DEFAULT 约束用于向列中插入默认值。 如果没有规定其他的值，那么会将默认值添加到所有的新记录。 CREATE TABLE 时的 SQL DEFAULT 约束 下面的 SQL 在 “Persons” 表创建时在 “City” 列上创建 DEFAULT 约束： **　My SQL SQL Server Oracle MS Access：** CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255) DEFAULT Sandnes) 通过使用类似 GETDATE() 这样的函数，DEFAULT 约束也可以用于插入系统值： CREATE TABLE Orders(O_Id int NOT NULL,OrderNo int NOT NULL,P_Id int,OrderDate date DEFAULT GETDATE()) ALTER TABLE 时的 SQL DEFAULT 约束 当表已被创建时，如需在 “City” 列创建 DEFAULT 约束，请使用下面的 SQL： **　MySQL：** ALTER TABLE PersonsALTER City SET DEFAULT SANDNES **　SQL Server MS Access：** ALTER TABLE Persons ADD CONSTRAINT DF_Persons_City DEFAULT(SANDNES) FOR City--注释--Persons 为表名--City 为列名--DF_Persons_City 为我们创建的默认约束的名称 约束名称一般为:约束类型简称_表名_列名 **　Oracle：** ALTER TABLE PersonsMODIFY City DEFAULT SANDNES 撤销 DEFAULT 约束 如需撤销 DEFAULT 约束，请使用下面的 SQL： **　MySQL：** ALTER TABLE PersonsALTER City DROP DEFAULT **　SQL Server Oracle MS Access：** ALTER TABLE PersonsALTER COLUMN City DROP DEFAULT SQL CHECK 约束 CHECK 约束用于限制列中的值的范围。 如果对单个列定义 CHECK 约束，那么该列只允许特定的值。 如果对一个表定义 CHECK 约束，那么此约束会基于行中其他列的值在特定的列中对值进行限制。 CREATE TABLE 时的 SQL CHECK 约束 下面的 SQL 在 “Persons” 表创建时在 “P_Id” 列上创建 CHECK 约束。CHECK 约束规定 “P_Id” 列必须只包含大于 0 的整数。 **　MySQL：** CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CHECK (P_Id0)) **　SQL Server Oracle MS Access：** CREATE TABLE Persons(P_Id int NOT NULL CHECK (P_Id0),LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255)) 如需命名 CHECK 约束，并定义多个列的 CHECK 约束，请使用下面的 SQL 语法： **　MySQL SQL Server Oracle MS Access：** CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CONSTRAINT chk_Person CHECK (P_Id0 AND City=Sandnes)) ALTER TABLE 时的 SQL CHECK 约束当表已被创建时，如需在 “P_Id” 列创建 CHECK 约束，请使用下面的 SQL： **　MySQL SQL Server Oracle MS Access:** ALTER TABLE PersonsADD CHECK (P_Id0) 如需命名 CHECK 约束，并定义多个列的 CHECK 约束，请使用下面的 SQL 语法： **　MySQL SQL Server Oracle MS Access：** ALTER TABLE PersonsADD CONSTRAINT chk_Person CHECK (P_Id0 AND City=Sandnes) 撤销 CHECK 约束 如需撤销 CHECK 约束，请使用下面的 SQL： **　SQL Server Oracle MS Access：** ALTER TABLE PersonsDROP CONSTRAINT chk_Person **　MySQL：** ALTER TABLE PersonsDROP CHECK chk_Person"},{"title":"SQL CREATE DATABASE语句","path":"/wiki/sql/sentence/createdb.html","content":"SQL CREATE DATABASE 语句 CREATE DATABASE 语句用于创建数据库。 在RDBMS中，数据库名称始终应该是唯一的。 SQL CREATE DATABASE 语法CREATE DATABASE dbname; 在创建任何数据库之前，请确保您拥有管理权限。 SQL CREATE DATABASE 实例 下面的 SQL 语句创建一个名为 “my_db” 的数据库： CREATE DATABASE my_db; 数据库表可以通过 CREATE TABLE 语句来添加。 创建数据库后，您可以在数据库列表中检查它。 语句： SHOW DATABASES;"},{"title":"SQL CREATE TABLE语句","path":"/wiki/sql/sentence/createtable.html","content":"SQL CREATE TABLE 语句 SQL CREATE TABLE 语句CREATE TABLE 语句用于创建数据库中的表。 表由行和列组成，每个表都必须有个表名。 SQL CREATE TABLE 语法CREATE TABLE table_name ( column_name1 data_type(size), column_name2 data_type(size), column_name3 data_type(size), .... ); column_name 参数规定表中列的名称。 data_type 参数规定列的数据类型（例如 varchar、integer、decimal、date 等等）。 size 参数规定表中列的最大长度。 **　提示：**如需了解 MS Access、MySQL 和 SQL Server 中可用的数据类型，请访问我们完整的 。 SQL CREATE TABLE 实例现在我们想要创建一个名为 “Persons” 的表，包含五列：PersonID、LastName、FirstName、Address 和 City。 我们使用下面的 CREATE TABLE 语句： 示例： CREATE TABLE Persons(PersonID int,LastName varchar(255),FirstName varchar(255),Address varchar(255),City varchar(255)); PersonID列数据类型为int，包含一个整数。 LastName、FirstName、Address和City列具有包含字符的varchar数据类型，这些字段的最大长度为255个字符。 空 “Persons” 表是这样的： PersonID LastName FirstName Address City **　提示：**使用 INSERT INTO 语句将数据写入空表。"},{"title":"SQL 简介","path":"/wiki/sql/sentence/brief.html","content":"SQL（结构化查询语言）是用于访问和操作数据库中的数据的标准数据库编程语言。 SQL是关系数据库系统的标准语言。所有关系数据库管理系统(RDMS)，如MySQL、MS Access、Oracle、Sybase、Informix、Postgres和SQL Server都使用SQL作为它们的标准数据库语言。 为了处理数据库和数据库相关的编程，程序员需要有一些介质，或者可以说接口来详细说明一组命令或代码来处理数据库或访问数据库的数据。在本章中，将简要介绍在学习SQL的过程中您将学习的术语。 你会从SQL中学到什么？SQL为结构化查询语言提供了独特的学习和数据库处理技术，并将帮助您更好地控制SQL查询并有效处理这些代码。由于SQL帮助您包括数据库创建，数据库或表删除，获取行数据和修改这些数据等，并行SQL使得事情自动和平滑，最终用户可以轻松访问和处理该应用程序的数据。 SQL 是什么？ SQL 发音为”sequel”。 SQL 指结构化查询语言，全称是 Structured Query Language（是最初由IBM开发）。 SQL 是关系数据库系统的标准语言。 SQL 是一种 ANSI（American National Standards Institute 美国国家标准化组织）标准的计算机语言。 SQL 能做什么？ SQL可以创建新的数据库及其对象（表，索引，视图，存储过程，函数和触发器）。 SQL可以修改现有数据库的结构。 SQL可以从数据库中删除（删除）对象。 SQL可以TRUNCATE（截取）表中的所有记录。 SQL可以对数据字典进行COMMENT。 SQL可以RENAME一个对象。 SQL可以从数据库中选择（检索）数据。 SQL可以将数据插入到表中。 SQL可以更新表中的现有数据。 SQL可以从数据库表中删除记录。 SQL可以在数据库中设置用户的GRANT和REVOKE权限。 SQL 的历史 1970年，SQL由IBM的Donald D. Chamberlin和Raymond F. Boyce开发。 1974年，开发版本最初被称为SEQUEL（结构化英语查询语言）。 1979年，关系软件发布了第一个叫做System R的商业产品。 由于商标冲突问题，SEQUEL首字母缩略词后来更改为SQL。 后来IBM基于System R的原型开始在SQL上开发商业产品。 第一个关系数据库由RelationalSoftware发布，后来被称为Oracle。 SQL 是一种标准 - 但是…虽然 SQL 是一门 ANSI（American National Standards Institute 美国国家标准化组织）标准的计算机语言，但是仍然存在着多种不同版本的 SQL 语言。 然而，为了与 ANSI 标准相兼容，它们必须以相似的方式共同地来支持一些主要的命令（比如 SELECT、UPDATE、DELETE、INSERT、WHERE 等等）。 **注释：**除SQL标准之外，大多数SQL数据库程序还具有自己的专有扩展名！ 在您的网站中使用 SQL要创建一个显示数据库中数据的网站，您需要： 一个RDBMS数据库程序（即MS Access，SQL Server，MySQL）。 使用服务器端脚本语言，如PHP或ASP。 使用SQL来获取所需的数据。 使用HTML CSS来设置页面的样式 RDBMSRDBMS 指关系型数据库管理系统，全称 Relational Database Management System。 RDBMS 是 SQL 的基础，同样也是所有现代数据库系统的基础，比如 MS SQL Server、IBM DB2、Oracle、MySQL 以及 Microsoft Access。 RDBMS 中的数据存储在被称为表的数据库对象中。 表是相关的数据项的集合，它由列和行组成。 代码示例： sql SELECT * FROM Customers; 每个表都被分解成称为字段的更小的实体。Customers表中的字段由CustomerID，CustomerName，ContactName，Address，City，PostalCode和Country组成。字段是表中的一列，用于维护表中每条记录的特定信息。 记录（也称为行）是表中存在的每个单独条目。例如，在上面的Customers表中有91条记录。记录是表中的横向实体。 列是表中的垂直实体，其包含与表中的特定字段相关联的所有信息。 SQL进程当您对任何RDBMS执行SQL命令时，系统将确定执行请求的最佳方式，并由SQL引擎确定如何解释该任务。 在此过程中包含了各种组件。 查询调度器优化引擎经典查询引擎SQL查询引擎 典型的查询引擎处理所有非SQL查询，但SQL查询引擎不会处理逻辑文件。 SQL标准命令与关系数据库交互的标准SQL命令是CREATE，SELECT，INSERT，UPDATE，DELETE和DROP，简单分为以下几组： DDL（数据定义语言）数据定义语言用于改变数据库结构，包括创建、更改和删除数据库对象。用于操纵表结构的数据定义语言命令有： CREATE TABLE– 创建（在数据库中创建新表、表视图或其他对象） ALTER TABLE– 更改 （修改现有的数据库对象，如表） DROP TABLE– 删除 （删除数据库中的整个表、表或其他对象的视图） DML（数据操纵语言）数据操纵语言用于检索、插入和修改数据，数据操纵语言是最常见的SQL命令。 数据操纵语言命令包括： INSERT– 插入 （创建记录） DELETE– 删除 （删除记录） UPDATE– 修改（修改记录） SELECT – 检索 （从一个或多个表检索某些记录） DCL（数据控制语言）数据控制语言为用户提供权限控制命令。 用于权限控制的命令有： GRANT– 授予权限 REVOKE– 撤销已授予的权限 SQL格式化使用SQL的缩进规范要求： 使用空格来缩进 每个缩进层次使用2个空格 每行最多使用80个字符 每个子句应该独占一行 每个子句的参数应该缩进一个层次。 可以比较直观的看到您想要的操作 章节小测现在，相信您已经了解了SQL的基础知识，那么，测验一下吧！"},{"title":"SQL 通用数据类型","path":"/wiki/sql/sentence/datatype.html","content":"SQL 通用数据类型 数据类型定义了存储在列中的值的类型。 SQL 通用数据类型 数据库表中的每一列都需要有一个名称和数据类型。 SQL 开发人员必须在创建 SQL 表时决定表中的每个列将要存储的数据的类型。数据类型是一个标签，是便于 SQL 了解每个列期望存储什么类型的数据的指南，它也标识了 SQL 如何与存储的数据进行交互。 下面的表格列出了 SQL 中通用的数据类型： 数据类型 描述 CHARACTER(n) 字符字符串。固定长度 n。 VARCHAR(n) 或 CHARACTER VARYING(n) 字符字符串。可变长度。最大长度 n。 BINARY(n) 二进制串。固定长度 n。 BOOLEAN 存储 TRUE 或 FALSE 值 VARBINARY(n) 或 BINARY VARYING(n) 二进制串。可变长度。最大长度 n。 INTEGER(p) 整数值（没有小数点）。精度 p。 SMALLINT 整数值（没有小数点）。精度 5。 INTEGER 整数值（没有小数点）。精度 10。 BIGINT 整数值（没有小数点）。精度 19。 DECIMAL(p,s) 精确数值，精度 p，小数点后位数 s。例如：decimal(5,2) 是一个小数点前有 3 位数小数点后有 2 位数的数字。 NUMERIC(p,s) 精确数值，精度 p，小数点后位数 s。（与 DECIMAL 相同） FLOAT(p) 近似数值，尾数精度 p。一个采用以 10 为基数的指数计数法的浮点数。该类型的 size 参数由一个指定最小精度的单一数字组成。 REAL 近似数值，尾数精度 7。 FLOAT 近似数值，尾数精度 16。 DOUBLE PRECISION 近似数值，尾数精度 16。 DATE 存储年、月、日的值。 TIME 存储小时、分、秒的值。 TIMESTAMP 存储年、月、日、小时、分、秒的值。 INTERVAL 由一些整数字段组成，代表一段时间，取决于区间的类型。 ARRAY 元素的固定长度的有序集合 MULTISET 元素的可变长度的无序集合 XML 存储 XML 数据 SQL 数据类型快速参考手册 然而，不同的数据库为数据类型定义提供了不同的选择。　下表显示了不同数据库平台上某些数据类型的通用名称： 数据类型 Access SQLServer Oracle MySQL PostgreSQL boolean YesNo Bit Byte NA Boolean integer Number (integer) Int Number Int Integer Int Integer float Number (single) Float Real Number Float Numeric currency Currency Money NA NA Money string (fixed) NA Char Char Char Char string (variable) Text (256) Memo (65k+) Varchar Varchar Varchar2 Varchar Varchar binary object OLE Object Memo Binary (fixed up to 8K) Varbinary (8K) Image (2GB) Long Raw Blob Text Binary Varbinary 注释： 在不同的数据库中，相同的数据类型可能有不同的名称。即使名字相同，大小和其他细节也可能不同！请随时检查文件!"},{"title":"SQL Date函数","path":"/wiki/sql/sentence/date.html","content":"SQL Date 函数 **注意：**当我们处理日期时，最困难的任务可能是确保插入日期的格式与数据库中日期列中的格式相匹配。 只要您的数据仅包含日期的一部分，运行查询就不会成为问题。然而，当涉及到时间时，情况会稍微复杂一些。 在讨论日期查询的复杂性之前，让我们看看最重要的内置日期处理程序。 MySQL Date 函数 下表列出了 MySQL 中最重要的内置日期函数： 函数 描述 返回当前的日期和时间 返回当前的日期 返回当前的时间 提取日期或日期时间表达式的日期部分 返回日期时间的单独部分 向日期添加指定的时间间隔 从日期减去指定的时间间隔 返回两个日期之间的天数 用不同的格式显示日期时间 SQL Server Date 函数 下表列出了SQL 服务器中最重要的内置日期函数： 函数 描述 返回当前的日期和时间 返回日期时间的单独部分 在日期中添加或减去指定的时间间隔 返回两个日期之间的时间 用不同的格式显示日期时间 SQL Date 数据类型 **　MySQL** 使用下列数据类型在数据库中存储日期或时间值： DATE - 格式：YYYY-MM-DD DATETIME - 格式：YYYY-MM-DD HH:MM:SS TIMESTAMP - 格式：YYYY-MM-DD HH:MM:SS YEAR - 格式：YYYY 或 YY **　SQL Server** 使用下列数据类型在数据库中存储日期或时间值： DATE - 格式：YYYY-MM-DD DATETIME - 格式：YYYY-MM-DD HH:MM:SS SMALLDATETIME - 格式：YYYY-MM-DD HH:MM:SS TIMESTAMP - 格式：唯一的数字 **　注释：**在数据库中创建新表时，需要为该列选择数据类型！ 如需了解所有可用的数据类型，请访问我们完整的 。 SQL 日期处理 **注意：**如果您不涉及时间部分，那么我们可以轻松比较两个日期！ 假设我们有以下”订单”表： OrderId ProductName OrderDate 1 Geitost 2008-11-11 2 Camembert Pierrot 2008-11-09 3 Mozzarella di Giovanni 2008-11-11 4 Mascarpone Fabioli 2008-10-29 现在，我们希望从上表中选取 OrderDate 为 “2008-11-11” 的记录。 我们使用下面的 SELECT 语句： SELECT * FROM Orders WHERE OrderDate=2008-11-11 结果集如下所示： OrderId ProductName OrderDate 1 Geitost 2008-11-11 3 Mozzarella di Giovanni 2008-11-11 现在，假设 “Orders” 表如下所示（请注意 “OrderDate” 列中的时间部分）： OrderId ProductName OrderDate 1 Geitost 2008-11-11 13:23:44 2 Camembert Pierrot 2008-11-09 15:45:21 3 Mozzarella di Giovanni 2008-11-11 11:12:01 4 Mascarpone Fabioli 2008-10-29 14:56:59 如果我们使用和上面一样的 SELECT 语句： SELECT * FROM Orders WHERE OrderDate=2008-11-11 这样我们就不会有结果了！这是因为查询的日期不包含时间部分。 **提示：**如果您想使查询更加简单和易于维护，请不要使用日期中的时间部分！"},{"title":"SQL 索引","path":"/wiki/sql/sentence/dbindex.html","content":"SQL 索引 索引是一种特殊的查询表，可以被数据库搜索引擎用来加速数据的检索。简单说来，索引就是指向表中数据的指针。数据库的索引同书籍后面的索引非常相像。 例如，如果想要查阅一本书中与某个特定主题相关的所有页面，你会先去查询索引（索引按照字母表顺序列出了所有主题），然后从索引中找到一页或者多页与该主题相关的页面。 索引能够提高 SELECT 查询和 WHERE 子句的速度，但是却降低了包含 UPDATE 语句或 INSERT 语句的数据输入过程的速度。索引的创建与删除不会对表中的数据产生影响。 创建索引需要使用 CREATE INDEX 语句，该语句允许对索引命名，指定要创建索引的表以及对哪些列进行索引，还可以指定索引按照升序或者降序排列。 同 UNIQUE 约束一样，索引可以是唯一的。这种情况下，索引会阻止列中（或者列的组合，其中某些列有索引）出现重复的条目。 CREATE INDEX 命令： **　CREATE INDEX**命令的基本语法如下： CREATE INDEX index_name ON table_name; 单列索引：单列索引基于单一的字段创建，其基本语法如下所示： CREATE INDEX index_nameON table_name (column_name); 唯一索引：唯一索引不止用于提升查询性能，还用于保证数据完整性。唯一索引不允许向表中插入任何重复值。其基本语法如下所示： CREATE UNIQUE INDEX index_nameon table_name (column_name); 如果您希望索引不止一个列，您可以在括号中列出这些列的名称，用逗号隔开： CREATE INDEX index_nameon table_name (column1, column2); 隐式索引：隐式索引由数据库服务器在创建某些对象的时候自动生成。例如，对于主键约束和唯一约束，数据库服务器就会自动创建索引。 DROP INDEX 命令：索引可以用 SQL DROP 命令删除。删除索引时应当特别小心，数据库的性能可能会因此而降低或者提高。 其基本语法如下： sql DROP INDEX table_name.index_name; 什么时候应当避免使用索引？ 尽管创建索引的目的是提升数据库的性能，但是还是有一些情况应当避免使用索引。下面几条指导原则给出了何时应当重新考虑是否使用索引： 小的数据表不应当使用索引； 需要频繁进行大批量的更新或者插入操作的表； 如果列中包含大数或者 NULL 值，不宜创建索引； 频繁操作的列不宜创建索引。"},{"title":"SQL 删除","path":"/wiki/sql/sentence/delete.html","content":"SQL DELETE 语句 DELETE语句用于删除表中现有记录。 SQL DELETE 语法DELETE FROM table_nameWHERE condition; 请注意 删除表格中的记录时要小心！ 注意SQL DELETE 语句中的 WHERE 子句！ WHERE子句指定需要删除哪些记录。如果省略了WHERE子句，表中所有记录都将被删除！ 演示数据库 在本教程中，我们将使用著名的Northwind示例数据库。 以下是 “Customers” 表中的数据： CustomerID CustomerName ContactName Address City PostalCode Country 1 Alfreds Futterkiste Maria Anders Obere Str. 57 Berlin 12209 Germany 2 Ana Trujillo Emparedados y helados Ana Trujillo Avda. de la Constitución 2222 México D.F. 05021 Mexico 3 Antonio Moreno Taquería Antonio Moreno Mataderos 2312 México D.F. 05023 Mexico 4 Around the Horn Thomas Hardy 120 Hanover Sq. London WA1 1DP UK 5 Berglunds snabbköp Christina Berglund Berguvsvägen 8 Luleå S-958 22 Sweden SQL DELETE 实例 假设我们想从”Customers” 表中删除客户”Alfreds Futterkiste”。 我们使用以下SQL语句： 示例： DELETE FROM CustomersWHERE CustomerName=Alfreds Futterkiste; 现在，”Customers” 表如下所示： CustomerID CustomerName ContactName Address City PostalCode Country 2 Ana Trujillo Emparedados y helados Ana Trujillo Avda. de la Constitución 2222 México D.F. 05021 Mexico 3 Antonio Moreno Taquería Antonio Moreno Mataderos 2312 México D.F. 05023 Mexico 4 Around the Horn Thomas Hardy 120 Hanover Sq. London WA1 1DP UK 5 Berglunds snabbköp Christina Berglund Berguvsvägen 8 Luleå S-958 22 Sweden 删除所有数据 您可以删除表中的所有行，而不需要删除该表。这意味着表的结构、属性和索引将保持不变： DELETE FROM table_name; **　或者** DELETE * FROM table_name; **注意：**在没有备份的情况下，删除记录要格外小心！因为你删除了不能恢复！"},{"title":"SQL 选择不同","path":"/wiki/sql/sentence/distinct.html","content":"SQL SELECT DISTINCT 语法 SELECT DISTINCT语法用于仅返回不同的（different）值。 在一张表内，一列通常包含许多重复的值; 有时你只想列出不同的（different）值。 SELECT DISTINCT语句用于仅返回不同的（different）值。 SQL SELECT DISTINCT语法如下所示： SELECT DISTINCT column1, column2, ...FROM table_name; 演示数据库 在本教程中，我们将使用著名的 Northwind 样本数据库。 下面是罗斯文示例数据库中 “Customers” 表的数据： CustomerID CustomerName ContactName Address City PostalCode Country 1 Alfreds Futterkiste Maria Anders Obere Str. 57 Berlin 12209 Germany 2 Ana Trujillo Emparedados y helados Ana Trujillo Avda. de la Constitución 2222 México D.F. 05021 Mexico 3 Antonio Moreno Taquería Antonio Moreno Mataderos 2312 México D.F. 05023 Mexico 4 Around the Horn Thomas Hardy 120 Hanover Sq. London WA1 1DP UK 5 Berglunds snabbköp Christina Berglund Berguvsvägen 8 Luleå S-958 22 Sweden SELECT实例 以下SQL语句从”Customers”表中的”Country”列中选择所有（包括重复）值：**　代码示例：** SELECT Country FROM Customers; 以上查询的结果： CountryGermanyMexicoMexicoUKSweden 现在，让我们在上面的SELECT语法中使用DISTINCT关键字并查看结果。 SELECT DISTINCT 实例 以下SQL语句仅从”Customers” 表中的 “Country” 列中选择DISTINCT值： 实例1SELECT DISTINCT Country FROM Customers; 查询结果： CountryGermanyMexicoUKSweden 以下SQL语句列出了不同（distinct）客户国家的数量： 实例2SELECT COUNT(DISTINCT Country) FROM Customers; **注意：**上述示例在Firefox和Microsoft Edge中不起作用！ 由于在Microsoft Access数据库中不支持COUNT(DISTINCT column_name)。在我们的示例中Firefox和Microsoft Edge使用Microsoft Access。"},{"title":"SQL 撤销索引/表/数据库","path":"/wiki/sql/sentence/drop.html","content":"SQL 撤销索引、撤销表以及撤销数据库 通过使用 DROP 语句，可以轻松地删除索引、表和数据库。 DROP INDEX 语句 DROP INDEX 语句用于删除表中的索引。 用于 MS Access 的 DROP INDEX 语法：DROP INDEX index_name ON table_name 用于 MS SQL Server 的 DROP INDEX 语法：DROP INDEX table_name.index_name 用于 DB2Oracle 的 DROP INDEX 语法：DROP INDEX index_name 用于 MySQL 的 DROP INDEX 语法：ALTER TABLE table_name DROP INDEX index_name DROP TABLE 语句 DROP TABLE 语句用于删除表。 DROP TABLE table_name DROP DATABASE 语句 DROP DATABASE 语句用于删除数据库。 DROP DATABASE database_name TRUNCATE TABLE 语句 如果我们只需要删除表中的数据，而不删除表本身，那么我们该怎么做？ 使用TRUNCATE TABLE语句： TRUNCATE TABLE table_name"},{"title":"SQL 表达式","path":"/wiki/sql/sentence/express.html","content":"SQL 表达式 表达式是计算值的一个或多个值、运算符和SQL函数的组合。这些SQL表达式类似于公式，它们是用查询语言编写的。 您还可以使用它们查询数据库中的特定数据集。 句法考虑SELECT语句的基本语法，如下所示： SELECT column1, column2, columnN FROM table_name WHERE [CONDITION|EXPRESSION]; 有不同类型的sql表达式，如下所示： 布尔型 数值型 日期 现在让我们详细讨论每一个问题。 布尔表达式 SQL布尔表达式基于匹配单个值获取数据。 句法： SELECT column1, column2, columnN FROM table_name WHERE SINGLE VALUE MATCHING EXPRESSION; 使用具有以下记录的Customers表： SQL SELECT * FROM CUSTOMERS;+----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+7 rows in set (0.00 sec) 下表是一个简单的示例，展示了各种sql布尔表达式的用法。 SQL SELECT * FROM CUSTOMERS WHERE SALARY = 10000;+----+-------+-----+---------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+-------+-----+---------+----------+| 7 | Muffy | 24 | Indore | 10000.00 |+----+-------+-----+---------+----------+1 row in set (0.00 sec) 数值表达式 数值表达式用于在任何查询中执行任何数学运算。 句法： SELECT numerical_expression as OPERATION_NAME[FROM table_nameWHERE CONDITION] ; 这里，数值表达式用于数学表达式或任何公式。下面是一个简单的示例，展示了SQLNDigitic表达式的用法： SQL SELECT (15 + 6) AS ADDITION+----------+| ADDITION |+----------+| 21 |+----------+1 row in set (0.00 sec) 有几个内置函数，如avg()、sum()、count()等，用于对表或特定表列执行所谓的聚合数据计算。 SQL SELECT COUNT(*) AS RECORDS FROM CUSTOMERS; +---------+| RECORDS |+---------+| 7 |+---------+1 row in set (0.00 sec) 日期表达式日期表达式返回当前系统日期和时间值： SQL SELECT CURRENT_TIMESTAMP;+---------------------+| Current_Timestamp |+---------------------+| 2009-11-12 06:40:23 |+---------------------+1 row in set (0.00 sec) 另一个日期表达式如下所示： SQL SELECT GETDATE();;+-------------------------+| GETDATE |+-------------------------+| 2009-10-22 12:07:18.140 |+-------------------------+1 row in set (0.00 sec)"},{"title":"SQL HAVING 子句","path":"/wiki/sql/sentence/having.html","content":"SQL HAVING 子句 HAVING 子句使你能够指定过滤条件，从而控制查询结果中哪些组可以出现在最终结果里面。 WHERE 子句对被选择的列施加条件，而 HAVING 子句则对 GROUP BY 子句所产生的组施加条件。 语法下面可以看到 HAVING 子句在 SEL ECT 查询中的位置： SELECTFROMWHEREGROUP BYHAVINGORDER BY 在 SELECT 查询中，HAVING 子句必须紧随 GROUP BY 子句，并出现在 ORDER BY 子句（如果有的话）之前。带有 HAVING 子句的 SELECT 语句的语法如下所示： SELECT column1, column2 FROM table1, table2WHERE [ conditions ]GROUP BY column1, column2HAVING [ conditions ]ORDER BY column1, column2 示例 考虑 CUSTOMERS 表，表中的记录如下所示： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ 下面是一个有关 HAVING 子句使用的实例，该实例将会筛选出出现次数大于或等于 2 的所有记录。 SQL SELECT ID, NAME, AGE, ADDRESS, SALARYFROM CUSTOMERSGROUP BY ageHAVING COUNT(age) = 2; 其执行结果如下所示： +----+----------+-----+---------+---------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+---------+---------+| 2 | Khilan | 25 | Delhi | 1500.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 |+----+----------+-----+---------+---------+ SQL HAVING 实例现在我们想要查找总访问量大于 200 的网站。 我们使用下面的 SQL 语句： 示例 SELECT Websites.name, Websites.url, SUM(access_log.count) AS nums FROM (access_log INNER JOIN Websites ON access_log.site_id=Websites.id) GROUP BY Websites.name HAVING SUM(access_log.count) 200; 执行以上 SQL 输出结果如下： 现在我们想要查找总访问量大于 200 的网站，并且 alexa 排名小于 200。 我们在 SQL 语句中增加一个普通的 WHERE 子句： 示例 SELECT Websites.name, SUM(access_log.count) AS nums FROM Websites INNER JOIN access_log ON Websites.id=access_log.site_id WHERE Websites.alexa 200 GROUP BY Websites.name HAVING SUM(access_log.count) 200;"},{"title":"SQL IN运算符","path":"/wiki/sql/sentence/in.html","content":"SQL IN 运算符 IN 运算符允许您在 WHERE 子句中指定多个值。 IN 运算符是多个 OR 条件的简写。 SQL IN 语法SELECT column_name(s)FROM table_nameWHERE column_name IN (value1, value2, ...); 或者SELECT column_name(s)FROM table_nameWHERE column_name IN (SELECT STATEMENT); 演示数据库 在本教程中，我们将使用著名的 Northwind 示例数据库。 以下数据选取自”Customers” 表： CustomerID CustomerName ContactName Address City PostalCode Country 1 Alfreds Futterkiste Maria Anders Obere Str. 57 Berlin 12209 Germany 2 Ana Trujillo Emparedados y helados Ana Trujillo Avda. de la Constitución 2222 México D.F. 05021 Mexico 3 Antonio Moreno Taquería Antonio Moreno Mataderos 2312 México D.F. 05023 Mexico 4 Around the Horn Thomas Hardy 120 Hanover Sq. London WA1 1DP UK 5 Berglunds snabbköp Christina Berglund Berguvsvägen 8 Luleå S-958 22 Sweden IN 操作符实例 以下 SQL 语句选取位于”Germany”，”France”和”UK”的所有客户： 代码示例：SELECT * FROM CustomersWHERE Country IN (Germany, France, UK); 以下 SQL 语句选取不在”Germany”，”France”或”UK”中的所有客户： 代码示例：SELECT * FROM CustomersWHERE Country NOT IN (Germany, France, UK); 以下 SQL 语句选取来自同一国家的所有客户作为供应商： 代码示例：SELECT * FROM CustomersWHERE Country IN (SELECT Country FROM Suppliers);"},{"title":"SQL 内部连接","path":"/wiki/sql/sentence/inner.html","content":"SQL INNER JOIN 关键字（内部连接） 内部链接INNER JOIN关键字选择两个表中具有匹配值的记录。 SQL INNER JOIN 语法SELECT column_name(s)FROM table1INNER JOIN table2 ON table1.column_name = table2.column_name; **　注释：**INNER JOIN 与 JOIN 是相同的。 演示数据库 在本教程中，我们将使用著名的Northwind示例数据库。 以下是 “Customers” 表中的数据： CustomerID CustomerName ContactName Address City PostalCode Country 1 Alfreds Futterkiste Maria Anders Obere Str. 57 Berlin 12209 Germany 2 Ana Trujillo Emparedados y helados Ana Trujillo Avda. de la Constitución 2222 México D.F. 05021 Mexico 3 Antonio Moreno Taquería Antonio Moreno Mataderos 2312 México D.F. 05023 Mexico 选自 “Orders” 表的数据： OrderID CustomerID EmployeeID OrderDate ShipperID 10308 2 7 1996-09-18 3 10309 37 3 1996-09-19 1 10310 77 8 1996-09-20 2 SQL INNER JOIN 实例 以下SQL语句将返回所有下订单的客户： 示例： SELECT Customers.CustomerName, Orders.OrderIDFROM CustomersINNER JOIN OrdersON Customers.CustomerID=Orders.CustomerIDORDER BY Customers.CustomerName; **注释：**如果表中至少有一个匹配项，INNER JOIN 关键字将返回一行。如果 “Customers” 表中的行与”Orders” 不匹配，则不会列出行。 加入三张表 以下SQL语句选择包含客户和货运单信息的所有订单： **　代码示例：** SELECT Orders.OrderID, Customers.CustomerName, Shippers.ShipperNameFROM ((OrdersINNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID)INNER JOIN Shippers ON Orders.ShipperID = Shippers.ShipperID);"},{"title":"SQL 在表中插入","path":"/wiki/sql/sentence/insert.html","content":"SQL INSERT INTO 语句 INSERT INTO 语句用于向表中插入新的数据行。 SQL INSERT INTO 语法INSERT INTO 语句可以用两种形式编写。　第一个表单没有指定要插入数据的列的名称，只提供要插入的值，即可添加一行新的数据： sql INSERT INTO table_name (column1, column2, column3, ...)VALUES (value1, value2, value3, ...); 第二种，如果要为表中的所有列添加值，则不需要在SQL查询中指定列名称。但是，请确保值的顺序与表中的列顺序相同。INSERT INTO语法如下所示： sql INSERT INTO table_nameVALUES (value1, value2, value3, ...); 演示数据库 在本教程中，我们将使用著名的 Northwind 示例数据库。 以下是”Customers” 表中的数据： CustomerID CustomerName ContactName Address City PostalCode Country 87 Wartian Herkku Pirkko Koskitalo Torikatu 38 Oulu 90110 Finland 88 Wellington Importadora Paula Parente Rua do Mercado, 12 Resende 08737-363 Brazil 89 White Clover Markets Karl Jablonski 305 - 14th Ave. S. Suite 3B Seattle 98128 USA 90 Wilman Kala Matti Karttunen Keskuskatu 45 Helsinki 21240 Finland 91 Wolski Zbyszek ul. Filtrowa 68 Walla 01-012 Poland INSERT INTO 实例 假设我们想在”Customers”表中插入一个新行。 我们可以使用以下SQL语句： 实例INSERT INTO Customers (CustomerName, ContactName, Address, City, PostalCode, Country)VALUES (‘Cardinal’,’Tom B. Erichsen’,’Skagen 21’,’Stavanger’,’4006’,’Norway’); 现在，选自 “Customers” 表的数据如下所示： CustomerID CustomerName ContactName Address City PostalCode Country 87 Wartian Herkku Pirkko Koskitalo Torikatu 38 Oulu 90110 Finland 88 Wellington Importadora Paula Parente Rua do Mercado, 12 Resende 08737-363 Brazil 89 White Clover Markets Karl Jablonski 305 - 14th Ave. S. Suite 3B Seattle 98128 USA 90 Wilman Kala Matti Karttunen Keskuskatu 45 Helsinki 21240 Finland 91 Wolski Zbyszek ul. Filtrowa 68 Walla 01-012 Poland 92 Cardinal Tom B. Erichsen Skagen 21 Stavanger 4006 Norway 注意到了吗？ 我们没有将任何号码插入 CustomerID 字段。 CustomerID列是一个字段，在将新记录插入到表中时自动生成。 仅在指定的列中插入数据 我们还可以只在指定的列中插入数据。 以下SQL语句插入一个新行，但只在”CustomerName”、”City”和”Country”列中插入数据（CustomerID字段将自动更新）： 示例： INSERT INTO Customers (CustomerName, City, Country)VALUES (Cardinal, Stavanger, Norway); 现在，选自 “Customers” 表的数据如下所示： CustomerID CustomerName ContactName Address City PostalCode Country 87 Wartian Herkku Pirkko Koskitalo Torikatu 38 Oulu 90110 Finland 88 Wellington Importadora Paula Parente Rua do Mercado, 12 Resende 08737-363 Brazil 89 White Clover Markets Karl Jablonski 305 - 14th Ave. S. Suite 3B Seattle 98128 USA 90 Wilman Kala Matti Karttunen Keskuskatu 45 Helsinki 21240 Finland 91 Wolski Zbyszek ul. Filtrowa 68 Walla 01-012 Poland 92 Cardinal null null Stavanger null Norway 使用另一个表填充一个表 您可以通过另一个表上的SELECT语句查询出来的字段值，然后将数据填充到本表中，条件是另一个表所查询的字段与本表要插入数据的字段是一一对应的。 INSERT INTO first_table_name [(column1, column2, ... columnN)] SELECT column1, column2, ...columnN FROM second_table_name[WHERE condition];"},{"title":"SQL INSECT INTO SELECT语句","path":"/wiki/sql/sentence/instosel.html","content":"SQL INSERT INTO SELECT 语句 使用SQL，您可以将信息从一个表中复制到另一个表中。 INSERT INTO SELECT 语句从表中复制数据，并将数据插入现有的表中。目标表中的任何现有行都不会受到影响。 SQL INSERT INTO SELECT 语法我们可以将所有列从一个表中复制到另一个已经存在的表中： INSERT INTO table2 SELECT * FROM table1; 或者我们可以把想要的列复制到另一个现有的表中： INSERT INTO table2 (column_name(s)) SELECT column_name(s) FROM table1; 演示数据库 在本教程中，我们将使用著名的Northwind示例数据库。 以下是”Customers”表中的数据： CustomerID CustomerName ContactName Address City PostalCode Country 1 Alfreds Futterkiste Maria Anders Obere Str. 57 Berlin 12209 Germany 2 Ana Trujillo Emparedados y helados Ana Trujillo Avda. de la Constitución 2222 México D.F. 05021 Mexico 3 Antonio Moreno Taquería Antonio Moreno Mataderos 2312 México D.F. 05023 Mexico 选自 “Suppliers” 表的数据： SupplierID SupplierName ContactName Address City Postal Code Country Phone 1 Exotic Liquid Charlotte Cooper 49 Gilbert St. Londona EC1 4SD UK (171) 555-2222 2 New Orleans Cajun Delights Shelley Burke P.O. Box 78934 New Orleans 70117 USA (100) 555-4822 3 Grandma Kelly’s Homestead Regina Murphy 707 Oxford Rd. Ann Arbor 48104 USA (313) 555-5735 SQL INSERT INTO SELECT 实例 把 “Suppliers” 一栏复制到 “Customers” 一栏： 示例： INSERT INTO Customers (CustomerName, Country)SELECT SupplierName, Country FROM Suppliers; 只将德国供应商的副本插入 “Customers” ： 示例： INSERT INTO Customers (CustomerName, Country)SELECT SupplierName, Country FROM SuppliersWHERE Country=Germany;"},{"title":"SQL 注入","path":"/wiki/sql/sentence/input.html","content":"SQL 注入 如果你从网页中获取用户输入，并将其插入到 SQL 数据库中的话，那么你很可能已经暴露于一种被称作 SQL 注入的安全风险之下了。 本节将会教你如何防止 SQL 注入，以及如何保护 Perl 这样的服务器端脚本中的程序和 SQL 语句。 注入通常发生在获取用户输入的时候，例如预期得到用户的名字，但是得到的却是一段很可能会在你不知情的情况下运行的 SQL 语句。 绝对不要相信用户提供的数据，处理这些数据之前必须进行验证；通常，验证工作由模式匹配来完成。 下面的例子中，name 仅限由字母、数字和下划线组成，并且长度在 8 到 20 之间（你可以根据需要修改这些规则）。 if (preg_match(/^\\w8,20$/, $_GET[username], $matches)) $result = mysql_query(SELECT * FROM CUSTOMERS WHERE name=$matches[0]);else echo user name not accepted; 为了展示问题所在，请考虑下面这段代码： // supposed input$name = Qadir; DELETE FROM CUSTOMERS;;mysql_query(SELECT * FROM CUSTOMSRS WHERE name=$name); 下面的函数调用本来是要从 CUSTOMERS 表中取得 name 字段与用户给定的输入相匹配的记录。通常情况下，$name 只包含字母和数字，或许还有空格，例如字符串 ilia。但是，这里通过在 $name 上附加一段全新的查询语句，将原有的函数调用变为了数据库的灾难：注入的 DELETE 语句将会删除表中所有的记录。 幸运的是，如果你在使用　MySQL 的话，mysql_query() 函数不允许查询堆积（query stacking），或者说在一次函数调用中执行多次 SQL 查询。如果你试图进行堆积式查询的话，函数调用将会失败。 然而，其他的 PHP 数据库扩展，例如 SQLite 和 PostgreSQL 会愉快地接受堆积式查询，执行字符串中所有的查询，并由此产生严重的安全问题。 阻止 SQL 注入 你可以在 Perl 或者 PHP 等脚本语言中巧妙地处理所有的转义字符。PHP 的 MySQL 扩展提供了一个 mysql_real_escape_string() 函数，来转义那些对 MySQL 有特殊意义的字符。 if (get_magic_quotes_gpc()) $name = stripslashes($name);$name = mysql_real_escape_string($name);mysql_query(SELECT * FROM CUSTOMERS WHERE name=$name); LIKE 困境 要破解 LIKE 困境，必须有一种专门的转义机制，将用户提供的 ‘%’ 和 ‘_’ 转换为字面值。为此你可以使用 addcslashes() 函数，该函数允许指定要进行转义的字符的范围。 $sub = addcslashes(mysql_real_escape_string(%str), %_);// $sub == \\%str\\_mysql_query(SELECT * FROM messages WHERE subject LIKE $sub%);"},{"title":"SQL Join连接","path":"/wiki/sql/sentence/join.html","content":"SQL JOIN 连接 SQL join 用于把来自两个或多个表的行结合起来。 SQL JOIN SQL JOIN 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。 简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地”连接”在主表结果集上。 最常见的 JOIN 类型：SQL INNER JOIN（简单的 JOIN）。 SQL INNER JOIN 从多个表中返回满足 JOIN 条件的所有行。 让我们看看选自 “Orders” 表的数据： OrderID CustomerID OrderDate 10308 2 1996-09-18 10309 37 1996-09-19 10310 77 1996-09-20 然后，看看选自 “Customers” 表的数据： CustomerID CustomerName ContactName Country 1 Alfreds Futterkiste Maria Anders Germany 2 Ana Trujillo Emparedados y helados Ana Trujillo Mexico 3 Antonio Moreno Taquería Antonio Moreno Mexico 请注意，”Orders” 表中的 “CustomerID” 列指向 “Customers” 表中的客户。上面这两个表是通过 “CustomerID” 列联系起来的。 然后，如果我们运行下面的 SQL 语句（包含 INNER JOIN）： 示例： SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDateFROM OrdersINNER JOIN CustomersON Orders.CustomerID=Customers.CustomerID; 运行结果如下所示： OrderID CustomerName OrderDate 10308 Ana Trujillo Emparedados y helados 1996-09-18 不同的 SQL JOIN 在我们继续讲解实例之前，我们先列出您可以使用的不同的 SQL JOIN 类型： INNER JOIN：如果表中有至少一个匹配，则返回行 LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行 RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行 FULL JOIN：只要其中一个表中存在匹配，则返回行 SELF JOIN ：用于将表连接到自己，就好像该表是两个表一样，临时重命名了SQL语句中的至少一个表 CARTESIAN JOIN：从两个或多个连接表返回记录集的笛卡儿积 SQL JOIN 连接详细用法 SQL 连接（JOIN） 子句用于将数据库中两个或者两个以上表中的记录组合起来。连接通过共有值将不同表中的字段组合在一起。 我们来看看”Orders”表中的选择： OrderID CustomerID OrderDate 10308 2 1996-09-18 10309 37 1996-09-19 10310 77 1996-09-20 然后，查看”Customers”表中的选择： CustomerID CustomerName ContactName Country 1 Alfreds Futterkiste Maria Anders Germany 2 Ana Trujillo Emparedados y helados Ana Trujillo Mexico 3 Antonio Moreno Taquería Antonio Moreno Mexico 请注意，”Orders”表中的”客户ID”列是指”CustomerID”表中的”客户ID”。上面两个表格之间的关系是”CustomerID”列。 然后，我们可以创建下面的SQL语句（包含一个INNER JOIN），它选择两个表中具有匹配值的记录： **　代码示例：** SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDateFROM OrdersINNER JOIN Customers ON Orders.CustomerID=Customers.CustomerID; 它会产生这样的东西： OrderID CustomerName OrderDate 10308 Ana Trujillo Emparedados y helados 9181996 10365 Antonio Moreno Taquería 11271996 10383 Around the Horn 12161996 10355 Around the Horn 11151996 10278 Berglunds snabbköp 8121996 考虑下面两个表，（a）CUSTOMERS 表： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ （b）另一个表是 ORDERS 表： +-----+---------------------+-------------+--------+|OID | DATE | CUSTOMER_ID | AMOUNT | +-----+---------------------+-------------+--------+ | 102 | 2009-10-08 00:00:00 | 3 | 3000 || 100 | 2009-10-08 00:00:00 | 3 | 1500 | | 101 | 2009-11-20 00:00:00 | 2 | 1560 || 103 | 2008-05-20 00:00:00 | 4 | 2060 | +-----+---------------------+-------------+--------+ 现在，让我们用 SELECT 语句将这个两张表连接（JOIN）在一起： SQL SELECT ID, NAME, AGE, AMOUNT FROM CUSTOMERS, ORDERS WHERE CUSTOMERS.ID = ORDERS.CUSTOMER_ID; 上述语句的运行结果如下所示： +----+----------+-----+--------+| ID | NAME | AGE | AMOUNT | +----+----------+-----+--------+ | 3 | kaushik | 23 | 3000 || 3 | kaushik | 23 | 1500 | | 2 | Khilan | 25 | 1560 || 4 | Chaitali | 25 | 2060 | +----+----------+-----+--------+ 不同类型的SQL联接 SQL 中有多种不同的连接： 内连接（INNER JOIN）：当两个表中都存在匹配时，才返回行。 左连接（LEFT JOIN）：返回左表中的所有行，即使右表中没有匹配的行。 右连接（RIGHT JOIN）：返回右表中的所有行，即使左表中没有匹配的行。 全连接（FULL JOIN）：只要某一个表存在匹配，就返回行。 笛卡尔连接（CARTESIAN JOIN）：返回两个或者更多的表中记录集的笛卡尔积。 内连接最常用也最重要的连接形式是内连接，有时候也被称作”EQUIJOIN”（等值连接）。 内连接根据连接谓词来组合两个表中的字段，以创建一个新的结果表。SQL 查询会比较逐个比较表 1 和表 2 中的每一条记录，来寻找满足连接谓词的所有记录对。当连接谓词得以满足时，所有满足条件的记录对的字段将会结合在一起构成结果表。 语法：**　内连接**的基本语法如下所示： sql SELECT table1.column1, table2.column2...FROM table1INNER JOIN table2ON table1.common_field = table2.common_field; 示例：考虑如下两个表格，（a）CUSTOMERS 表： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ （b）ORDERS 表： +-----+---------------------+-------------+--------+| OID | DATE | ID | AMOUNT | +-----+---------------------+-------------+--------+ | 102 | 2009-10-08 00:00:00 | 3 | 3000 || 100 | 2009-10-08 00:00:00 | 3 | 1500 | | 101 | 2009-11-20 00:00:00 | 2 | 1560 || 103 | 2008-05-20 00:00:00 | 4 | 2060 | +-----+---------------------+-------------+--------+ 现在，让我们用内连接将这两个表连接在一起： SQL SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS INNER JOIN ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMER_ID; 上述语句将会产生如下结果： +----+----------+--------+---------------------+| ID | NAME | AMOUNT | DATE | +----+----------+--------+---------------------+ | 3 | kaushik | 3000 | 2009-10-08 00:00:00 || 3 | kaushik | 1500 | 2009-10-08 00:00:00 | | 2 | Khilan | 1560 | 2009-11-20 00:00:00 || 4 | Chaitali | 2060 | 2008-05-20 00:00:00 | +----+----------+--------+---------------------+ 左连接**　左链接**返回左表中的所有记录，即使右表中没有任何满足匹配条件的记录。这意味着，如果 ON 子句在右表中匹配到了 0 条记录，该连接仍然会返回至少一条记录，不过返回的记录中所有来自右表的字段都为 NULL。 这就意味着，左连接会返回左表中的所有记录，加上右表中匹配到的记录，或者是 NULL （如果连接谓词无法匹配到任何记录的话）。 语法：**　左连接**的基本语法如下所示： SELECT table1.column1, table2.column2...FROM table1LEFT JOIN table2ON table1.common_field = table2.common_field; 这里，给出的条件可以是任何根据你的需要写出的条件。 示例：考虑如下两个表格，（a）CUSTOMERS 表： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ （b）ORDERS 表： +-----+---------------------+-------------+--------+| OID | DATE | ID | AMOUNT | +-----+---------------------+-------------+--------+ | 102 | 2009-10-08 00:00:00 | 3 | 3000 || 100 | 2009-10-08 00:00:00 | 3 | 1500 | | 101 | 2009-11-20 00:00:00 | 2 | 1560 || 103 | 2008-05-20 00:00:00 | 4 | 2060 | +-----+---------------------+-------------+--------+ 现在，让我们用左连接将这两个表连接在一起： SQL SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS LEFT JOIN ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMER_ID; 上述语句将会产生如下结果： +----+----------+--------+---------------------+| ID | NAME | AMOUNT | DATE | +----+----------+--------+---------------------+ | 1 | Ramesh | NULL | NULL || 2 | Khilan | 1560 | 2009-11-20 00:00:00 | | 3 | kaushik | 3000 | 2009-10-08 00:00:00 || 3 | kaushik | 1500 | 2009-10-08 00:00:00 | | 4 | Chaitali | 2060 | 2008-05-20 00:00:00 || 5 | Hardik | NULL | NULL | | 6 | Komal | NULL | NULL || 7 | Muffy | NULL | NULL | +----+----------+--------+---------------------+ 右连接**　右链接**返回右表中的所有记录，即是左表中没有任何满足匹配条件的记录。这意味着，如果 ON 子句在左表中匹配到了 0 条记录，该连接仍然会返回至少一条记录，不过返回的记录中所有来自左表的字段都为 NULL。 这就意味着，右连接会返回右表中的所有记录，加上左表中匹配到的记录，或者是 NULL （如果连接谓词无法匹配到任何记录的话）。 语法：**　右连接**的基本语法如下所示： SELECT table1.column1, table2.column2...FROM table1RIGHT JOIN table2ON table1.common_field = table2.common_field; 这里，给出的条件可以是任何根据你的需要写出的条件。 示例：考虑如下两个表格，（a）CUSTOMERS 表： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ （b）ORDERS 表： +-----+---------------------+-------------+--------+| OID | DATE | ID | AMOUNT | +-----+---------------------+-------------+--------+ | 102 | 2009-10-08 00:00:00 | 3 | 3000 || 100 | 2009-10-08 00:00:00 | 3 | 1500 | | 101 | 2009-11-20 00:00:00 | 2 | 1560 || 103 | 2008-05-20 00:00:00 | 4 | 2060 | +-----+---------------------+-------------+--------+ 现在，让我们用右连接将这两个表连接在一起： SQL SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS RIGHT JOIN ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMER_ID; 上述语句将会产生如下结果： +------+----------+--------+---------------------+| ID | NAME | AMOUNT | DATE | +------+----------+--------+---------------------+ | 3 | kaushik | 3000 | 2009-10-08 00:00:00 || 3 | kaushik | 1500 | 2009-10-08 00:00:00 | | 2 | Khilan | 1560 | 2009-11-20 00:00:00 || 4 | Chaitali | 2060 | 2008-05-20 00:00:00 | +------+----------+--------+---------------------+ 全连接**　全连接**将左连接和右连接的结果组合在一起。 语法：SELECT table1.column1, table2.column2...FROM table1FULL JOIN table2ON table1.common_field = table2.common_field; 这里，给出的条件可以是任何根据你的需要写出的条件。 示例：考虑如下两个表格，（a）CUSTOMERS 表： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ （b）ORDERS 表： +-----+---------------------+-------------+--------+| OID | DATE | ID | AMOUNT | +-----+---------------------+-------------+--------+ | 102 | 2009-10-08 00:00:00 | 3 | 3000 || 100 | 2009-10-08 00:00:00 | 3 | 1500 | | 101 | 2009-11-20 00:00:00 | 2 | 1560 || 103 | 2008-05-20 00:00:00 | 4 | 2060 | +-----+---------------------+-------------+--------+ 现在让我们用全连接将两个表连接在一起： SQL SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS FULL JOIN ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMER_ID; 上述语句将会产生如下结果： +------+----------+--------+---------------------+| ID | NAME | AMOUNT | DATE | +------+----------+--------+---------------------+ | 1 | Ramesh | NULL | NULL || 2 | Khilan | 1560 | 2009-11-20 00:00:00 | | 3 | kaushik | 3000 | 2009-10-08 00:00:00 || 3 | kaushik | 1500 | 2009-10-08 00:00:00 | | 4 | Chaitali | 2060 | 2008-05-20 00:00:00 || 5 | Hardik | NULL | NULL | | 6 | Komal | NULL | NULL || 7 | Muffy | NULL | NULL | | 3 | kaushik | 3000 | 2009-10-08 00:00:00 || 3 | kaushik | 1500 | 2009-10-08 00:00:00 | | 2 | Khilan | 1560 | 2009-11-20 00:00:00 || 4 | Chaitali | 2060 | 2008-05-20 00:00:00 | +------+----------+--------+---------------------+ 如果你所用的数据库不支持全连接，比如 MySQL，那么你可以使用 UNION ALL子句来将左连接和右连接结果组合在一起： SQL SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS LEFT JOIN ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMER_IDUNION ALL SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS RIGHT JOIN ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMER_ID 笛卡尔连接（交叉连接）**　笛卡尔连接** 或者交叉连接返回两个或者更多的连接表中记录的笛卡尔乘积。也就是说，它相当于连接谓词总是为真或者缺少连接谓词的内连接。 语法：**　笛卡尔连接** 或者说交叉连接的基本语法如下所示： SELECT table1.column1, table2.column2...FROM table1, table2 [, table3 ] 示例：考虑如下两个表格，（a）CUSTOMERS 表： +----+----------+-----+-----------+----------+ | ID | NAME | AGE | ADDRESS | SALARY | +----+----------+-----+-----------+----------+ | 1 | Ramesh | 32 | Ahmedabad | 2000.00 | | 2 | Khilan | 25 | Delhi | 1500.00 | | 3 | kaushik | 23 | Kota | 2000.00 | | 4 | Chaitali | 25 | Mumbai | 6500.00 | | 5 | Hardik | 27 | Bhopal | 8500.00 | | 6 | Komal | 22 | MP | 4500.00 | | 7 | Muffy | 24 | Indore | 10000.00 | +----+----------+-----+-----------+----------+（b）ORDERS 表： +-----+---------------------+-------------+--------+ | OID | DATE | ID | AMOUNT | +-----+---------------------+-------------+--------+ | 102 | 2009-10-08 00:00:00 | 3 | 3000 | | 100 | 2009-10-08 00:00:00 | 3 | 1500 | | 101 | 2009-11-20 00:00:00 | 2 | 1560 | | 103 | 2008-05-20 00:00:00 | 4 | 2060 | +-----+---------------------+-------------+--------+ 现在，让我用内连接将这两个表连接在一起： SQL SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS, ORDERS; 上述语句将会产生如下结果： +----+----------+--------+---------------------+| ID | NAME | AMOUNT | DATE | +----+----------+--------+---------------------+ | 1 | Ramesh | 3000 | 2009-10-08 00:00:00 || 1 | Ramesh | 1500 | 2009-10-08 00:00:00 | | 1 | Ramesh | 1560 | 2009-11-20 00:00:00 || 1 | Ramesh | 2060 | 2008-05-20 00:00:00 | | 2 | Khilan | 3000 | 2009-10-08 00:00:00 || 2 | Khilan | 1500 | 2009-10-08 00:00:00 | | 2 | Khilan | 1560 | 2009-11-20 00:00:00 || 2 | Khilan | 2060 | 2008-05-20 00:00:00 | | 3 | kaushik | 3000 | 2009-10-08 00:00:00 || 3 | kaushik | 1500 | 2009-10-08 00:00:00 | | 3 | kaushik | 1560 | 2009-11-20 00:00:00 || 3 | kaushik | 2060 | 2008-05-20 00:00:00 | | 4 | Chaitali | 3000 | 2009-10-08 00:00:00 || 4 | Chaitali | 1500 | 2009-10-08 00:00:00 | | 4 | Chaitali | 1560 | 2009-11-20 00:00:00 || 4 | Chaitali | 2060 | 2008-05-20 00:00:00 | | 5 | Hardik | 3000 | 2009-10-08 00:00:00 || 5 | Hardik | 1500 | 2009-10-08 00:00:00 | | 5 | Hardik | 1560 | 2009-11-20 00:00:00 || 5 | Hardik | 2060 | 2008-05-20 00:00:00 | | 6 | Komal | 3000 | 2009-10-08 00:00:00 || 6 | Komal | 1500 | 2009-10-08 00:00:00 | | 6 | Komal | 1560 | 2009-11-20 00:00:00 || 6 | Komal | 2060 | 2008-05-20 00:00:00 | | 7 | Muffy | 3000 | 2009-10-08 00:00:00 || 7 | Muffy | 1500 | 2009-10-08 00:00:00 | | 7 | Muffy | 1560 | 2009-11-20 00:00:00 || 7 | Muffy | 2060 | 2008-05-20 00:00:00 | +----+----------+--------+---------------------+"},{"title":"SQL 左连接","path":"/wiki/sql/sentence/left.html","content":"SQL 左连接 LEFT JOIN 关键字 SQL左链接LEFT JOIN关键字返回左表（表1）中的所有行，即使在右表（表2）中没有匹配。如果在正确的表中没有匹配，结果是NULL。 SQL LEFT JOIN 语法SELECT column_name(s) FROM table1 LEFT JOIN table2 ON table1.column_name=table2.column_name; 或： SELECT column_name(s) FROM table1 LEFT OUTER JOIN table2 ON table1.column_name=table2.column_name; **注释：**在一些数据库中，LEFT JOIN称为LEFT OUT ER JOIN。 演示数据库 在本教程中，我们将使用著名的Northwind示例数据库。 以下是 “Customers” 表中的数据： CustomerID CustomerName ContactName Address City PostalCode Country 1 Alfreds Futterkiste Maria Anders Obere Str. 57 Berlin 12209 Germany 2 Ana Trujillo Emparedados y helados Ana Trujillo Avda. de la Constitución 2222 México D.F. 05021 Mexico 3 Antonio Moreno Taquería Antonio Moreno Mataderos 2312 México D.F. 05023 Mexico 选自 “Orders” 表的数据： OrderID CustomerID EmployeeID OrderDate ShipperID 10308 2 7 1996-09-18 3 10309 37 3 1996-09-19 1 10310 77 8 1996-09-20 2 SQL LEFT JOIN 实例 以下SQL语句将选择所有客户以及他们可能拥有的任何订单： 示例： SELECT Customers.CustomerName, Orders.OrderIDFROM CustomersLEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerIDORDER BY Customers.CustomerName; **注释：**LEFT JOIN 关键字返回左表（Customers）中的所有行，即使在右边表（Orders）中没有匹配。"},{"title":"SQL LIKE运算符","path":"/wiki/sql/sentence/like.html","content":"SQL LIKE 运算符 在WHERE子句中使用LIKE运算符来搜索列中的指定模式。 有两个通配符与LIKE运算符一起使用： ％ - 百分号表示零个，一个或多个字符 _ - 下划线表示单个字符 **　注意：** MS Access使用问号（?）而不是下划线（_）。 百分号和下划线也可以组合使用！ SQL LIKE 语法SELECT column1, column2, ...FROM table_nameWHERE columnN LIKE pattern; **　提示** ：您还可以使用AND或OR运算符组合任意数量的条件。 下面是一些使用’％’和’_’通配符显示不同LIKE运算符的例子： LIKE 运算符 描述 WHERE CustomerName LIKE ‘a%’ 查找以”a”开头的任何值 WHERE CustomerName LIKE ‘%a’ 查找以”a”结尾的任何值 WHERE CustomerName LIKE ‘%or%’ 在任何位置查找任何具有”or”的值 WHERE CustomerName LIKE ‘_r%’ 在第二个位置查找任何具有”r”的值 WHERE CustomerName LIKE ‘a_%_%’ 查找以”a”开头且长度至少为3个字符的值 WHERE ContactName LIKE ‘a%o’ 找到以”a”开头，以”o”结尾的值 演示数据库在本教程中，我们将使用著名的Northwind示例数据库。 以下是”Customers”表中的数据： CustomerID CustomerName ContactName Address City PostalCode Country 1 Alfreds Futterkiste Maria Anders Obere Str. 57 Berlin 12209 Germany 2 Ana Trujillo Emparedados y helados Ana Trujillo Avda. de la Constitución 2222 México D.F. 05021 Mexico 3 Antonio Moreno Taquería Antonio Moreno Mataderos 2312 México D.F. 05023 Mexico 4 Around the Horn Thomas Hardy 120 Hanover Sq. London WA1 1DP UK 5 Berglunds snabbköp Christina Berglund Berguvsvägen 8 Luleå S-958 22 Sweden SQL LIKE 运算符实例 以下SQL语句选择以”a”开头的CustomerName的所有客户： **　代码示例：** SELECT * FROM CustomersWHERE CustomerName LIKE a%; 以下SQL语句选择客户名称以”a”结尾的所有客户： **　代码示例：** SELECT * FROM CustomersWHERE CustomerName LIKE %a; 以下SQL语句选择客户名称在任何位置都具有”or”的所有客户： **　代码示例：** SELECT * FROM CustomersWHERE CustomerName LIKE %or%; 以下SQL语句选择客户名称在第二位具有”r”的所有客户： **　代码示例：** SELECT * FROM CustomersWHERE CustomerName LIKE _r%; 以下SQL语句选择客户名称以”a”开头且长度至少为3个字符的所有客户： **　代码示例：** SELECT * FROM CustomersWHERE CustomerName LIKE a_%_%; 以下SQL语句选择联系人名称以”a”开头并以”o”结尾的所有客户： **　代码示例：** SELECT * FROM CustomersWHERE ContactName LIKE a%o; 以下SQL语句选择客户名称不以”a”开头的所有客户： **　代码示例：** SELECT * FROM CustomersWHERE CustomerName NOT LIKE a%; 以下SQL语句选择客户名称以”a”开头，以”s”结尾的5位字符的所有客户： **　代码示例：** SELECT * FROM CustomersWHERE CustomerName LIKE a___s;"},{"title":"SQL TOP/LIMIT语句","path":"/wiki/sql/sentence/limit.html","content":"SQL SELECT TOP 子句 SELECT TOP 子句用于指定要返回的记录数量。 SELECT TOP子句在包含数千条记录的大型表上很有用。返回大量记录会影响性能。 **注：**并不是所有的数据库系统都支持SELECT TOP子句。MySQL支持LIMIT子句来选择有限数量的记录，而Oracle使用ROWNUM。 SQL Server MS Access 语法SELECT TOP number|percent column_name(s)FROM table_nameWHERE condition; MySQL 和 Oracle 中的 SQL SELECT TOP 是等价的 MySQL语法：SELECT column_name(s)FROM table_nameWHERE conditionLIMIT number; 实例SELECT *FROM PersonsLIMIT 5; Oracle 语法SELECT column_name(s)FROM table_nameWHERE ROWNUM = number; 示例： SELECT *FROM PersonsWHERE ROWNUM =5; 演示数据库 在本教程中，我们将使用著名的Northwind示例数据库。 以下是”Customers” 表中的数据： CustomerID CustomerName ContactName Address City PostalCode Country 1 Alfreds Futterkiste Maria Anders Obere Str. 57 Berlin 12209 Germany 2 Ana Trujillo Emparedados y helados Ana Trujillo Avda. de la Constitución 2222 México D.F. 05021 Mexico 3 Antonio Moreno Taquería Antonio Moreno Mataderos 2312 México D.F. 05023 Mexico 4 Around the Horn Thomas Hardy 120 Hanover Sq. London WA1 1DP UK 5 Berglunds snabbköp Christina Berglund Berguvsvägen 8 Luleå S-958 22 Sweden SQL SELECT TOP 实例 以下SQL语句从”Customers” 表中选择前两条记录： 示例： SELECT TOP 2 * FROM Customers; SQL SELECT TOP PERCENT 实例 以下SQL语句从 “Customers” 表中选择前50%的记录： 示例： SELECT TOP 50 PERCENT * FROM Customers; SQL TOP，LIMIT和ROWNUM示例以下SQL语句从”Customers”表中选择前三个记录： SELECT TOP 3 * FROM Customers; 以下SQL语句显示了使用LIMIT子句的等效示例： SELECT * FROM CustomersLIMIT 3; 以下SQL语句显示了使用ROWNUM的等效示例： SELECT * FROM CustomersWHERE ROWNUM = 3; SQL TOP PERCENT示例以下SQL语句从”Customers”表中选择记录的前50％：SELECT TOP 50 PERCENT * FROM Customers; 添加一个条件 以下SQL语句从”Customers”表中选择国家为”Germany”的前三条记录： SELECT TOP 3 * FROM CustomersWHERE Country=Germany; 以下SQL语句显示了使用LIMIT子句的等效示例： SELECT * FROM CustomersWHERE Country=GermanyLIMIT 3; 以下SQL语句显示了使用ROWNUM的等效示例： SELECT * FROM CustomersWHERE Country=Germany AND ROWNUM = 3; 为什么要LIMIT你的查询结果 LIMIT作为一种简单的分页方法，主要是为了减少数据返回的时间，如果您查询一个非常大的表(例如一个有数十万或数百万行的表)而不使用限制，那么您可能会等待很长时间才能显示所有的结果，所以使用LIMIT可以减少查询数据返回的时间，提高效率。"},{"title":"SQL 空值","path":"/wiki/sql/sentence/null.html","content":"什么是SQL NULL值？ SQL 中，NULL 用于表示缺失的值。数据表中的 NULL 值表示该值所处的字段为空。 具有NULL值的字段是没有值的字段。 如果表中的字段是可选的，则可以插入新记录或更新记录而不向该字段添加值。然后，该字段将被保存为NULL值。 值为 NULL 的字段没有值。尤其要明白的是，NULL 值与 0 或者包含空白（spaces）的字段是不同的。 注意：理解NULL值与零值或包含空格的字段不同是非常重要的。具有NULL值的字段是在记录创建期间留空的字段！ 如何测试NULL值？ 使用比较运算符（例如，或）来测试NULL值是不可行的。 我们将不得不使用IS NULL和IS NOT NULL运算符。 IS NULL语法SELECT column_namesFROM table_nameWHERE column_name IS NULL; IS NOT NULL语法SELECT column_namesFROM table_nameWHERE column_name IS NOT NULL; 演示数据库 假设我们有以下的”人员”表： ID LastName FirstName Address City 1 Doe John 542 W. 27th Street New York 2 Bloggs Joe London 3 Roe Jane New York 4 Smith John 110 Bishopsgate London 假设”人员”表中的”Address”列是可选的。如果插入的记录没有”Address”值，则”Address”列将以空值保存。 IS NULL运算符 以下SQL语句使用IS NULL运算符来列出所有没有地址的人员： SELECT LastName, FirstName, Address FROM PersonsWHERE Address IS NULL; 结果集将如下所示： LastName FirstName Address Bloggs Joe Roe Jane 提示：始终使用IS NULL来查找空值。 IS NOT NULL运算符 以下SQL语句使用IS NOT NULL运算符来列出所有具有地址的人员： SELECT LastName, FirstName, Address FROM PersonsWHERE Address IS NOT NULL; 结果集将如下所示： LastName FirstName Address Doe John 542 W. 27th Street Smith John 110 Bishopsgate 语法： 创建表的时候，NULL 的基本语法如下： SQL CREATE TABLE CUSTOMERS( ID INT NOT NULL, NAME VARCHAR (20) NOT NULL, AGE INT NOT NULL, ADDRESS CHAR (25) , SALARY DECIMAL (18, 2), PRIMARY KEY (ID)); 这里，NOT NULL表示对于给定列，必须按照其数据类型明确赋值。有两列并没有使用 NOT NULL 来限定，也就是说这些列可以为 NULL。 值为 NULL 的字段是在记录创建的过程中留空的字段。 示例： NULL 值会给选取数据带来麻烦。不过，因为 NULL 和其他任何值作比较，其结果总是未知的，所以含有 NULL 的记录不会包含在最终结果里面。 必须使用 IS NULL 或者 IS NOT NULL 来检测某个字段是否为 NULL。 考虑下面的 CUSTOMERS 数据表，里面包含的记录如下所示： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | || 7 | Muffy | 24 | Indore | |+----+----------+-----+-----------+----------+ 下面是 IS NOT NULL 运算符的用法： SQL SELECT ID, NAME, AGE, ADDRESS, SALARY FROM CUSTOMERS WHERE SALARY IS NOT NULL; 上面语句的运行结果如下： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 |+----+----------+-----+-----------+----------+ 下面是 IS NULL 运算符的用法： SQL SELECT ID, NAME, AGE, ADDRESS, SALARY FROM CUSTOMERS WHERE SALARY IS NULL; 其运行结果如下： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 6 | Komal | 22 | MP | || 7 | Muffy | 24 | Indore | |+----+----------+-----+-----------+----------+"},{"title":"SQL 按关键字排序","path":"/wiki/sql/sentence/order.html","content":"SQL ORDER BY 关键字 ORDER BY 关键字用于按升序或降序对结果集进行排序。 ORDER BY 关键字默认情况下按升序排序记录。 如果需要按降序对记录进行排序，可以使用DESC关键字。 SQL ORDER BY 语法SELECT column1, column2, ...FROM table_nameORDER BY column1, column2, ... ASC|DESC; 您可以在ORDER BY子句中使用多个列，但要确保用于对该列进行排序的列应该在列表中。 演示数据库 在本教程中，我们将使用著名的Northwind示例数据库。 以下是 “Customers” 表中的数据： CustomerID CustomerName ContactName Address City PostalCode Country 1 Alfreds Futterkiste Maria Anders Obere Str. 57 Berlin 12209 Germany 2 Ana Trujillo Emparedados y helados Ana Trujillo Avda. de la Constitución 2222 México D.F. 05021 Mexico 3 Antonio Moreno Taquería Antonio Moreno Mataderos 2312 México D.F. 05023 Mexico 4 Around the Horn Thomas Hardy 120 Hanover Sq. London WA1 1DP UK 5 Berglunds snabbköp Christina Berglund Berguvsvägen 8 Luleå S-958 22 Sweden ORDER BY 实例 下面的 SQL 语句从 “Customers” 表中选取所有客户，并按照 “Country” 列排序： 示例： SELECT * FROM CustomersORDER BY Country; ORDER BY DESC 实例 下面的 SQL 语句从 “Customers” 表中选取所有客户，并按照 “Country” 列降序排序： 实例SELECT * FROM CustomersORDER BY Country DESC; ORDER BY 多列 实例1 下面的 SQL 语句从 “Customers” 表中选取所有客户，并按照 “Country” 和 “CustomerName” 列排序： 示例： SELECT * FROM CustomersORDER BY Country, CustomerName; ORDER BY 多列 实例2 以下SQL语句从”Customers” 表中选择所有客户，按 “Country” 升序排列，并按 “CustomerName” 列降序排列： SELECT * FROM CustomersORDER BY Country ASC, CustomerName DESC;"},{"title":"SQL RBDMS概念","path":"/wiki/sql/sentence/rdbms.html","content":"SQL RDBMS 概念 RDBMS是关系数据库管理系统(Relational Database Management System)的缩写。 RDBMS是SQL的基础，也是所有现代数据库系统(如MS SQL Server、IBMDB2、Oracle、MySQL和MicrosoftAccess)的基础。 关系数据库管理系统(Relational Database Management System，RDBMS)是一种基于E.F.Codd提出的关系模型的数据库管理系统。 什么是表？ RDBMS中的数据存储在称为表的数据库对象中。这个表基本上是一个相关数据条目的集合，它由许多列和行组成。请记住，表是关系数据库中最常见和最简单的数据存储形式。 下面的程序是Customers表的一个示例 +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ 什么是字段？ 每个表都被分解成更小的实体，称为字段。Customers表中的字段由ID、姓名、年龄、地址和薪资组成。 字段是表中的列，用于维护有关表中每条记录的特定信息。 什么是记录或者行数据？ 记录也称为数据行，即表中存在的每个单独的条目。例如，上面的Customers表中有7条记录。下面是Customers表中的单行数据或记录。 +----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 |+----+----------+-----+-----------+----------+ 记录是表中的水平实体。 什么是列？ 列是表中的垂直实体，其中包含与表中特定字段关联的所有信息。 例如，Customers表中的一列是Address，它表示位置描述，如下所示： +-----------+| ADDRESS |+-----------+| Ahmedabad || Delhi || Kota || Mumbai || Bhopal || MP || Indore |+----+------+ 什么是空值？ 表中的空值是显示为空的字段中的值，这意味着具有空值的字段是没有值的字段。 非常重要的一点是空值不同于零值或包含空格的字段。具有空值的字段是在创建记录时留空的字段。 SQL约束 约束是在表上的数据列上强制执行的规则。它们用于限制可以进入表中的数据类型。 这确保了数据库中数据的准确性和可靠性。 约束可以是列级别，也可以是表级别。列级约束仅应用于一列，而表级约束则应用于整个表。 以下是sql−中可用的一些最常用的约束 ：保证列中数据不能有 NULL 值 ：提供该列数据未指定时所采用的默认值 ：保证列中的所有数据各不相同 ：唯一标识数据表中的行记录 ：唯一标识其他表中的一条行记录 ：此约束保证列中的所有值满足某一条件 ：用于在数据库中快速创建或检索数据 约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。 数据完整性 每个关系数据库管理系统都存在以下类型的数据完整性： 实体完整性−表中没有重复行。域完整性−通过限制值的类型、格式或范围来强制执行给定列的有效条目。引用完整性−不能删除其他记录使用的行。用户定义的完整性−强制执行一些不属于实体、域或引用完整性的特定业务规则。 数据库规范化 数据库规范化是在数据库中有效地组织数据的过程。这个规范化过程有两个原因： 消除冗余数据，例如，将相同的数据存储在多个表中。 确保数据依赖关系是有意义的。 这两个原因都是值得追求的目标，因为它们减少了数据库消耗的空间量，并确保了数据的逻辑存储。 规范化由一系列指导原则组成，有助于指导您创建良好的数据库结构。 规范化指导原则称为范式，范式的目的是组织数据库结构，使其符合第一范式、第二范式和第三范式的规则。 你可以更长远的去选择第四范式，第五范式，等等，但一般来说，第三范式已经足够了。 第一范式(1NF)第二范式(2NF)第三范式(3NF)"},{"title":"SQL 处理重复数据","path":"/wiki/sql/sentence/repeat.html","content":"SQL 处理重复数据 有时候，数据表中会存在相同的记录。在获取表中记录时，相较于取得重复记录来说，取得唯一的记录显然更有意义。 我们之前讨论过的 SQL DISTINCT 关键字，与 SELECT 语句一起使用可以时，可以达到消除所有重复记录，只返回唯一记录的目的。 语法 利用 DISTINCT 关键字来消除重复记录的基本语法如下所示： SELECT DISTINCT column1, column2,.....columnN FROM table_nameWHERE [condition] 示例： 考虑 CUSTOMERS 表，表中记录如下所示： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ 首先，让我们先看一下 SELECT 语句是如何返回重复的薪水记录的： SQL SELECT SALARY FROM CUSTOMERS ORDER BY SALARY; 运行上述语句将会得到以下结果，其中 SALARY 为 2000 的记录出现了两次，即来自原始数据表的重复记录： +----------+| SALARY |+----------+| 1500.00 || 2000.00 || 2000.00 || 4500.00 || 6500.00 || 8500.00 || 10000.00 |+----------+ 现在，让我们在上面的 SELECT 查询中使用 DISTINCT 关键字，然后观察将会得到什么结果： SQL SELECT DISTINCT SALARY FROM CUSTOMERS ORDER BY SALARY; 上述语句将会产生如下结果，这一再没有任何重复的条目了： +----------+| SALARY |+----------+| 1500.00 || 2000.00 || 4500.00 || 6500.00 || 8500.00 || 10000.00 |+----------+"},{"title":"SQL 完整外部连接","path":"/wiki/sql/sentence/outer.html","content":"SQL FULL OUTER JOIN 关键字 当左（表1）或右（表2）表记录匹配时，FULL OUTER JOIN关键字将返回所有记录。 **　注意：** FULL OUTER JOIN可能会返回非常大的结果集！ SQL FULL OUTER JOIN 语法SELECT column_name(s)FROM table1FULL OUTER JOIN table2 ON table1.column_name = table2.column_name; 演示数据库 在本教程中，我们将使用著名的Northwind示例数据库。 以下是”Customers” 表中的数据： CustomerID CustomerName ContactName Address City PostalCode Country 1 Alfreds Futterkiste Maria Anders Obere Str. 57 Berlin 12209 Germany 2 Ana Trujillo Emparedados y helados Ana Trujillo Avda. de la Constitución 2222 México D.F. 05021 Mexico 3 Antonio Moreno Taquería Antonio Moreno Mataderos 2312 México D.F. 05023 Mexico 选自 “Orders” 表的数据： OrderID CustomerID EmployeeID OrderDate ShipperID 10308 2 7 1996-09-18 3 10309 3 3 1996-09-19 1 10310 77 8 1996-09-20 2 SQL FULL OUTER JOIN 实例 以下SQL语句选择所有客户和所有订单： SELECT Customers.CustomerName, Orders.OrderIDFROM CustomersFULL OUTER JOIN Orders ON Customers.CustomerID=Orders.CustomerIDORDER BY Customers.CustomerName; 从这套结果中选择的数据如下： CustomerName OrderID Alfreds Futterkiste Ana Trujillo Emparedados y helados 10308 Antonio Moreno Taquería 10309 10310 注意： FULL OUTER JOIN关键字返回左表（Customers）中的所有行，以及右表（Orders）中的所有行。如果 “Customers”中的行中没有”Orders”中的匹配项，或者”Orders”中的行中没有 “Customers”中的匹配项，那么这些行也会列出。"},{"title":"SQL 右连接","path":"/wiki/sql/sentence/right.html","content":"SQL右连接 RIGHT JOIN 关键字 SQL右链接 RIGHT JOIN 关键字返回右表（table2）的所有行，即使在左表（table1）上没有匹配。如果左表没有匹配，则结果为NULL。 SQL RIGHT JOIN 语法SELECT column_name(s)FROM table1RIGHT JOIN table2 ON table1.column_name = table2.column_name; **注释：**在一些数据库中，RIGHT JOIN 称为 RIGHT OUTER JOIN。 演示数据库在本教程中，我们将使用着名的Northwind示例数据库。 以下是”Orders”表中的一个选项： OrderID CustomerID EmployeeID OrderDate ShipperID 10308 2 7 1996-09-18 3 10309 37 3 1996-09-19 1 10310 77 8 1996-09-20 2 并从”Employees” t表中选择： EmployeeID LastName FirstName BirthDate Photo 1 Davolio Nancy 1281968 EmpID1.pic 2 Fuller Andrew 2191952 EmpID2.pic 3 Leverling Janet 8301963 EmpID3.pic SQL RIGHT JOIN 实例 以下SQL语句将返回所有雇员以及他们可能已经放置的任何订单： 示例： SELECT Orders.OrderID, Employees.LastName, Employees.FirstNameFROM OrdersRIGHT JOIN Employees ON Orders.EmployeeID = Employees.EmployeeIDORDER BY Orders.OrderID; **注释：**RIGHT JOIN 关键字返回右表（Employees）的所有行，即使在左表（Orders）中没有匹配。"},{"title":"SQL 自连接","path":"/wiki/sql/sentence/self.html","content":"SQL自连接 自联接是一种常规联接，但表本身是连接的。 Self JOIN语法SELECT column_name(s)FROM table1 T1, table1 T2WHERE condition; 演示数据库 在本教程中，我们将使用着名的Northwind示例数据库。 以下是”Customers”表中的选择： CustomerID CustomerName ContactName Address City PostalCode Country 1 Alfreds Futterkiste Maria Anders Obere Str. 57 Berlin 12209 Germany 2 Ana Trujillo Emparedados y helados Ana Trujillo Avda. de la Constitución 2222 México D.F. 05021 Mexico 3 Antonio Moreno Taquería Antonio Moreno Mataderos 2312 México D.F. 05023 Mexico SQL Self JOIN示例 以下SQL语句匹配来自同一城市的客户： 示例 SELECT A.CustomerName AS CustomerName1, B.CustomerName AS CustomerName2, A.CityFROM Customers A, Customers BWHERE A.CustomerID B.CustomerIDAND A.City = B.City ORDER BY A.City;"},{"title":"SQL 语句快速参考","path":"/wiki/sql/sentence/refer.html","content":"SQL语句快速参考 SQL 语句 语法 AND OR SELECT column_name(s) FROM table_name WHERE condition AND|OR condition ALTER TABLE ALTER TABLE table_name ADD column_name datatype or ALTER TABLE table_name DROP COLUMN column_name AS (alias) SELECT column_name AS column_alias FROM table_name or SELECT column_name FROM table_name AS table_alias BETWEEN SELECT column_name(s) FROM table_name WHERE column_name BETWEEN value1 AND value2 CREATE DATABASE CREATE DATABASE database_name CREATE TABLE CREATE TABLE table_name ( column_name1 data_type, column_name2 data_type, column_name2 data_type, … ) CREATE INDEX CREATE INDEX index_name ON table_name (column_name) or CREATE UNIQUE INDEX index_name ON table_name (column_name) CREATE VIEW CREATE VIEW view_name AS SELECT column_name(s) FROM table_name WHERE condition DELETE DELETE FROM table_name WHERE some_columnsome_value or DELETE FROM table_name (**Note:**Deletes the entire table!!) DELETE * FROM table_name (**Note:**Deletes the entire table!!) DROP DATABASE DROP DATABASE database_name DROP INDEX DROP INDEX table_name.index_name (SQL Server) DROP INDEX index_name ON table_name (MS Access) DROP INDEX index_name (DB2Oracle) ALTER TABLE table_name DROP INDEX index_name (MySQL) DROP TABLE DROP TABLE table_name GROUP BY SELECT column_name, aggregate_function(column_name) FROM table_name WHERE column_name operator value GROUP BY column_name HAVING SELECT column_name, aggregate_function(column_name) FROM table_name WHERE column_name operator value GROUP BY column_name HAVING aggregate_function(column_name) operator value IN SELECT column_name(s) FROM table_name WHERE column_name IN (value1,value2,..) INSERT INTO INSERT INTO table_name VALUES (value1, value2, value3,….) or INSERT INTO table_name (column1, column2, column3,…) VALUES (value1, value2, value3,….) INNER JOIN SELECT column_name(s) FROM table_name1 INNER JOIN table_name2 ON table_name1.column_nametable_name2.column_name LEFT JOIN SELECT column_name(s) FROM table_name1 LEFT JOIN table_name2 ON table_name1.column_nametable_name2.column_name RIGHT JOIN SELECT column_name(s) FROM table_name1 RIGHT JOIN table_name2 ON table_name1.column_nametable_name2.column_name FULL JOIN SELECT column_name(s) FROM table_name1 FULL JOIN table_name2 ON table_name1.column_nametable_name2.column_name LIKE SELECT column_name(s) FROM table_name WHERE column_nameLIKE pattern ORDER BY SELECT column_name(s) FROM table_name ORDER BY column_name [ASC|DESC] SELECT SELECT column_name(s) FROM table_name SELECT * SELECT * FROM table_name SELECT DISTINCT SELECT DISTINCT column_name(s) FROM table_name SELECT INTO SELECT * INTO new_table_name [IN externaldatabase] FROM old_table_name or SELECT column_name(s) INTO new_table_name [IN externaldatabase] FROM old_table_name SELECT TOP SELECT TOP number|percent column_name(s) FROM table_name TRUNCATE TABLE TRUNCATE TABLE table_name UNION SELECT column_name(s) FROM table_name1 UNION SELECT column_name(s) FROM table_name2 UNION ALL SELECT column_name(s) FROM table_name1 UNION ALL SELECT column_name(s) FROM table_name2 UPDATE UPDATE table_name SET column1value, column2value,… WHERE some_columnsome_value WHERE SELECT column_name(s) FROM table_name WHERE column_name operator value"},{"title":"SQL 使用序列","path":"/wiki/sql/sentence/sequence.html","content":"SQL 使用序列 序列是根据需要产生的一组有序整数：1, 2, 3 … 序列在数据库中经常用到，因为许多应用要求数据表中的的每一行都有一个唯一的值，序列为此提供了一种简单的方法。 本节阐述在 MySQL 中如何使用序列。 使用 AUTO_INCREMENT 列 在 MySQL 中使用序列最简单的方式是，把某列定义为 AUTO_INCREMENT，然后将剩下的事情交由 MySQL 处理： 示例 试一下下面的例子，该例将会创建一张新表，然后再里面插入几条记录，添加记录时并不需要指定记录的 ID，因为该列的值由 MySQL 自动增加。 mysql CREATE TABLE INSECT - ( - id INT UNSIGNED NOT NULL AUTO_INCREMENT, - PRIMARY KEY (id), - name VARCHAR(30) NOT NULL, # type of insect - date DATE NOT NULL, # date collected - origin VARCHAR(30) NOT NULL # where collected);Query OK, 0 rows affected (0.02 sec)mysql INSERT INTO INSECT (id,name,date,origin) VALUES - (NULL,housefly,2001-09-10,kitchen), - (NULL,millipede,2001-09-10,driveway), - (NULL,grasshopper,2001-09-10,front yard);Query OK, 3 rows affected (0.02 sec)Records: 3 Duplicates: 0 Warnings: 0mysql SELECT * FROM INSECT ORDER BY id;+----+-------------+------------+------------+| id | name | date | origin |+----+-------------+------------+------------+| 1 | housefly | 2001-09-10 | kitchen || 2 | millipede | 2001-09-10 | driveway || 3 | grasshopper | 2001-09-10 | front yard |+----+-------------+------------+------------+3 rows in set (0.00 sec) 获取 AUTO_INCREMENT 值 LAST_INSERT_ID() 是一个 SQL 函数，可以用在任何能够执行 SQL 语句地方。另外，Perl 和 PHP 各自提供了其独有的函数，用于获得最后一条记录的 AUTO_INCREMENT 值。 Perl 示例 使用 mysql_insertid 属性来获取 SQL 查询产生的 AUTO_INCREMENT 值。根据执行查询的方式不同，该属性可以通过数据库句柄或者语句句柄来访问。下面的示例通过数据库句柄取得自增值： $dbh-do (INSERT INTO INSECT (name,date,origin)VALUES(moth,2001-09-14,windowsill));my $seq = $dbh-mysql_insertid; PHP 示例 在执行完会产生自增值的查询后，可以通过调用 mysql_insert_id() 来获取此值： mysql_query (INSERT INTO INSECT (name,date,origin)VALUES(moth,2001-09-14,windowsill), $conn_id);$seq = mysql_insert_id ($conn_id); 重新编号现有序列 当你从表中删除了很多记录后，可能会想要对所有的记录重新定序。只要略施小计就能达到此目的，不过如果你的表与其他表之间存在连接的话，请千万小心。 当你觉得不得不对 AUTO_INCREMENT 列重新定序时，从表中删除该列，然后再将其添加回来，就可以达到目的了。下面的示例展示了如何使用这种方法，为 INSECT 表中的 ID 值重新定序： mysql ALTER TABLE INSECT DROP id;mysql ALTER TABLE insect - ADD id INT UNSIGNED NOT NULL AUTO_INCREMENT FIRST, - ADD PRIMARY KEY (id); 从特定值的序列 默认情况下，MySQL 中序列的起始值为 1，不过你可以在创建数据表的时候，指定任意其他值。下面的示例中，MySQL 将序列的起始值设为 100： mysql CREATE TABLE INSECT - ( - id INT UNSIGNED NOT NULL AUTO_INCREMENT = 100, - PRIMARY KEY (id), - name VARCHAR(30) NOT NULL, # type of insect - date DATE NOT NULL, # date collected - origin VARCHAR(30) NOT NULL # where collected); 或者，你也可以先创建数据表，然后使用 ALTER TABLE 来设置序列的起始值： mysql ALTER TABLE t AUTO_INCREMENT = 100;"},{"title":"SQL 各种数据库的数据类型","path":"/wiki/sql/sentence/summary.html","content":"SQL 各种数据库的数据类型 Microsoft Access、MySQL 和 SQL Server 所使用的数据类型和范围。 Microsoft Access 数据类型 数据类型 描述 存储 Text 用于文本或文本与数字的组合。最多 255 个字符。 Memo Memo 用于更大数量的文本。最多存储 65,536 个字符。**注释：**无法对 memo 字段进行排序。不过它们是可搜索的。 Byte 允许 0 到 255 的数字。 1 字节 Integer 允许介于 -32,768 与 32,767 之间的全部数字。 2 字节 Long 允许介于 -2,147,483,648 与 2,147,483,647 之间的全部数字。 4 字节 Single 单精度浮点。处理大多数小数。 4 字节 Double 双精度浮点。处理大多数小数。 8 字节 Currency 用于货币。支持 15 位的元，外加 4 位小数。**提示：**您可以选择使用哪个国家的货币。 8 字节 AutoNumber AutoNumber 字段自动为每条记录分配数字，通常从 1 开始。 4 字节 DateTime 用于日期和时间 8 字节 YesNo 逻辑字段，可以显示为 YesNo、TrueFalse 或 OnOff。在代码中，使用常量 True 和 False （等价于 1 和 0）。**注释：**YesNo 字段中不允许 Null 值 1 比特 Ole Object 可以存储图片、音频、视频或其他 BLOBs（Binary Large OBjects）。 最多 1GB Hyperlink 包含指向其他文件的链接，包括网页。 Lookup Wizard 允许您创建一个可从下拉列表中进行选择的选项列表。 4 字节 MySQL 数据类型 在 MySQL 中，有三种主要的类型：Text（文本）、Number（数字）和 DateTime（日期时间）类型。 **　Text 类型：** 数据类型 描述 CHAR(size) 保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符。 VARCHAR(size) 保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。**注释：**如果值的长度大于 255，则被转换为 TEXT 类型。 TINYTEXT 存放最大长度为 255 个字符的字符串。 TEXT 存放最大长度为 65,535 个字符的字符串。 BLOB 用于 BLOBs（Binary Large OBjects）。存放最多 65,535 字节的数据。 MEDIUMTEXT 存放最大长度为 16,777,215 个字符的字符串。 MEDIUMBLOB 用于 BLOBs（Binary Large OBjects）。存放最多 16,777,215 字节的数据。 LONGTEXT 存放最大长度为 4,294,967,295 个字符的字符串。 LONGBLOB 用于 BLOBs (Binary Large OBjects)。存放最多 4,294,967,295 字节的数据。 ENUM(x,y,z,etc.) 允许您输入可能值的列表。可以在 ENUM 列表中列出最大 65535 个值。如果列表中不存在插入的值，则插入空值。 **注释：**这些值是按照您输入的顺序排序的。 可以按照此格式输入可能的值： ENUM(‘X’,’Y’,’Z’) SET 与 ENUM 类似，不同的是，SET 最多只能包含 64 个列表项且 SET 可存储一个以上的选择。 **　Number 类型：** 数据类型 描述 TINYINT(size) -128 到 127 常规。0 到 255 无符号*。在括号中规定最大位数。 SMALLINT(size) -32768 到 32767 常规。0 到 65535 无符号*。在括号中规定最大位数。 MEDIUMINT(size) -8388608 到 8388607 普通。0 to 16777215 无符号*。在括号中规定最大位数。 INT(size) -2147483648 到 2147483647 常规。0 到 4294967295 无符号*。在括号中规定最大位数。 BIGINT(size) -9223372036854775808 到 9223372036854775807 常规。0 到 18446744073709551615 无符号*。在括号中规定最大位数。 FLOAT(size,d) 带有浮动小数点的小数字。在 size 参数中规定最大位数。在 d 参数中规定小数点右侧的最大位数。 DOUBLE(size,d) 带有浮动小数点的大数字。在 size 参数中规定最大位数。在 d 参数中规定小数点右侧的最大位数。 DECIMAL(size,d) 作为字符串存储的 DOUBLE 类型，允许固定的小数点。在 size 参数中规定最大位数。在 d 参数中规定小数点右侧的最大位数。 **注意：**这些整数类型拥有额外的选项 UNSIGNED。通常，整数可以是负数或正数。如果添加 UNSIGNED 属性，那么范围将从 0 开始，而不是某个负数。 **　Date 类型：** 数据类型 描述 DATE() 日期。格式：YYYY-MM-DD **注释：**支持的范围是从 ‘1000-01-01’ 到 ‘9999-12-31’ DATETIME() *日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS **注释：**支持的范围是从 ‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’ TIMESTAMP() *时间戳。TIMESTAMP 值使用 Unix 纪元(‘1970-01-01 00:00:00’ UTC) 至今的秒数来存储。格式：YYYY-MM-DD HH:MM:SS **注释：**支持的范围是从 ‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-09 03:14:07’ UTC TIME() 时间。格式：HH:MM:SS **注释：**支持的范围是从 ‘-838:59:59’ 到 ‘838:59:59’ YEAR() 2 位或 4 位格式的年。 **注释：**4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。 **注意：**即便 DATETIME 和 TIMESTAMP 返回相同的格式，它们的工作方式很不同。在 INSERT 或 UPDATE 查询中，TIMESTAMP 自动把自身设置为当前的日期和时间。TIMESTAMP 也接受不同的格式，比如 YYYYMMDDHHMMSS、YYMMDDHHMMSS、YYYYMMDD 或 YYMMDD。 SQL Server 数据类型 **　String 类型：** 数据类型 描述 存储 char(n) 固定长度的字符串。最多 8,000 个字符。 Defined width varchar(n) 可变长度的字符串。最多 8,000 个字符。 2 bytes + number of chars varchar(max) 可变长度的字符串。最多 1,073,741,824 个字符。 2 bytes + number of chars text 可变长度的字符串。最多 2GB 文本数据。 4 bytes + number of chars nchar 固定长度的 Unicode 字符串。最多 4,000 个字符。 Defined width x 2 nvarchar 可变长度的 Unicode 字符串。最多 4,000 个字符。 nvarchar(max) 可变长度的 Unicode 字符串。最多 536,870,912 个字符。 ntext 可变长度的 Unicode 字符串。最多 2GB 文本数据。 bit 允许 0、1 或 NULL binary(n) 固定长度的二进制字符串。最多 8,000 字节。 varbinary 可变长度的二进制字符串。最多 8,000 字节。 varbinary(max) 可变长度的二进制字符串。最多 2GB。 image 可变长度的二进制字符串。最多 2GB。 **　Number 类型：** 数据类型 描述 存储 tinyint 允许从 0 到 255 的所有数字。 1 字节 smallint 允许介于 -32,768 与 32,767 的所有数字。 2 字节 int 允许介于 -2,147,483,648 与 2,147,483,647 的所有数字。 4 字节 bigint 允许介于 -9,223,372,036,854,775,808 与 9,223,372,036,854,775,807 之间的所有数字。 8 字节 decimal(p,s) 固定精度和比例的数字。 允许从 -10^38 +1 到 10^38 -1 之间的数字。 p 参数指示可以存储的最大位数（小数点左侧和右侧）。p 必须是 1 到 38 之间的值。默认是 18。 s 参数指示小数点右侧存储的最大位数。s 必须是 0 到 p 之间的值。默认是 0。 5-17 字节 numeric(p,s) 固定精度和比例的数字。 允许从 -10^38 +1 到 10^38 -1 之间的数字。 p 参数指示可以存储的最大位数（小数点左侧和右侧）。p 必须是 1 到 38 之间的值。默认是 18。 s 参数指示小数点右侧存储的最大位数。s 必须是 0 到 p 之间的值。默认是 0。 5-17 字节 smallmoney 介于 -214,748.3648 与 214,748.3647 之间的货币数据。 4 字节 money 介于 -922,337,203,685,477.5808 与 922,337,203,685,477.5807 之间的货币数据。 8 字节 float(n) 从 -1.79E + 308 到 1.79E + 308 的浮动精度数字数据。 n 参数指示该字段保存 4 字节还是 8 字节。float(24) 保存 4 字节，而 float(53) 保存 8 字节。n 的默认值是 53。 4 或 8 字节 real 从 -3.40E + 38 到 3.40E + 38 的浮动精度数字数据。 4 字节 **　Date 类型：** 数据类型 描述 存储 datetime 从 1753 年 1 月 1 日 到 9999 年 12 月 31 日，精度为 3.33 毫秒。 8 字节 datetime2 从 1753 年 1 月 1 日 到 9999 年 12 月 31 日，精度为 100 纳秒。 6-8 字节 smalldatetime 从 1900 年 1 月 1 日 到 2079 年 6 月 6 日，精度为 1 分钟。 4 字节 date 仅存储日期。从 0001 年 1 月 1 日 到 9999 年 12 月 31 日。 3 bytes time 仅存储时间。精度为 100 纳秒。 3-5 字节 datetimeoffset 与 datetime2 相同，外加时区偏移。 8-10 字节 timestamp 存储唯一的数字，每当创建或修改某行时，该数字会更新。timestamp 值基于内部时钟，不对应真实时间。每个表只能有一个 timestamp 变量。 **　其他数据类型：** 数据类型 描述 sql_variant 存储最多 8,000 字节不同数据类型的数据，除了 text、ntext 以及 timestamp。 uniqueidentifier 存储全局唯一标识符 (GUID)。 xml 存储 XML 格式化数据。最多 2GB。 cursor 存储对用于数据库操作的指针的引用。 table 存储结果集，供稍后处理。"},{"title":"SQL 子查询","path":"/wiki/sql/sentence/subquery.html","content":"SQL 子查询 子查询（Sub Query）或者说内查询（Inner Query），也可以称作嵌套查询（Nested Query），是一种嵌套在其他 SQL 查询的 WHERE 子句中的查询。 子查询用于为主查询返回其所需数据，或者对检索数据进行进一步的限制。 子查询可以在 SELECT、INSERT、UPDATE 和 DELETE 语句中，同 、、、、、IN、BETWEEN 等运算符一起使用。 使用子查询必须遵循以下几个规则： 子查询必须括在圆括号中。 子查询的 SELECT 子句中只能有一个列，除非主查询中有多个列，用于与子查询选中的列相比较。 子查询不能使用 ORDER BY，不过主查询可以。在子查询中，GROUP BY 可以起到同 ORDER BY 相同的作用。 返回多行数据的子查询只能同多值操作符一起使用，比如 IN 操作符。 SELECT 列表中不能包含任何对 BLOB、ARRAY、CLOB 或者 NCLOB 类型值的引用。 子查询不能直接用在聚合函数中。 BETWEEN 操作符不能同子查询一起使用，但是 BETWEEN 操作符可以用在子查询中。 SELECT 语句中的子查询 通常情况下子查询都与 SELECT 语句一起使用，其基本语法如下所示： SELECT column_name [, column_name ]FROM table1 [, table2 ]WHERE column_name OPERATOR (SELECT column_name [, column_name ] FROM table1 [, table2 ] [WHERE]) 示例： 考虑 CUSTOMERS 表，表中记录如下所示： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 35 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ 现在，让我们试一下在 SELECT 语句中进行子查询： SQL SELECT * FROM CUSTOMERS WHERE ID IN (SELECT ID FROM CUSTOMERS WHERE SALARY 4500) ; 上述语句的执行结果如下所示： +----+----------+-----+---------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+---------+----------+| 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+---------+----------+ INSERT 语句中的子查询： 子查询还可以用在 INSERT 语句中。INSERT 语句可以将子查询返回的数据插入到其他表中。子查询中选取的数据可以被任何字符、日期或者数值函数所修饰。 其基本语法如下所示： INSERT INTO table_name [ (column1 [, column2 ]) ] SELECT [ *|column1 [, column2 ] FROM table1 [, table2 ] [ WHERE VALUE OPERATOR ] 示例： 考虑与 CUSTOMERS 表拥有相似结构的 CUSTOMERS_BKP 表。现在要将 CUSTOMER 表中所有的数据复制到 CUSTOMERS_BKP 表中，代码如下： SQL INSERT INTO CUSTOMERS_BKP SELECT * FROM CUSTOMERS WHERE ID IN (SELECT ID FROM CUSTOMERS) ; UPDATE 语句中的子查询： 子查询可以用在 UPDATE 语句中。当子查询同 UPDATE 一起使用的时候，既可以更新单个列，也可更新多个列。 其基本语法如下： UPDATE tableSET column_name = new_value[ WHERE OPERATOR [ VALUE ] (SELECT COLUMN_NAME FROM TABLE_NAME) [ WHERE) ] 示例： 假设我们有一份 CUSTOMERS_BKP 表作为 CUSTOMERS 表的备份。 下面的示例将 CUSTOMERS 表中所有 AGE 大于或者等于 27 的客户的 SALARY 字段都变为了原来的 0.25 倍： SQL UPDATE CUSTOMERS SET SALARY = SALARY * 0.25 WHERE AGE IN (SELECT AGE FROM CUSTOMERS_BKP WHERE AGE = 27 ); 这将影响两行数据，随后 CUSTOMERS 表中的记录将如下所示： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 35 | Ahmedabad | 125.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 2125.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ DELETE 语句中的子查询： 如同前面提到的其他语句一样，子查询还可以同 DELETE 语句一起使用。 其基本语法如下所示： DELETE FROM TABLE_NAME[ WHERE OPERATOR [ VALUE ] (SELECT COLUMN_NAME FROM TABLE_NAME) [ WHERE) ] 示例： 假设我们有一份 CUSTOMERS_BKP 表作为 CUSTOMERS 表的备份。 下面的示例将从 CUSTOMERS 表中删除所有 AGE 大于或者等于 27 的记录： SQL DELETE FROM CUSTOMERS WHERE AGE IN (SELECT AGE FROM CUSTOMERS_BKP WHERE AGE 27 ); 这将影响两行数据，随后 CUSTOMERS 表中的记录将如下所示： +----+----------+-----+---------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+---------+----------+| 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+---------+----------+"},{"title":"SQL SELECT INTO语句","path":"/wiki/sql/sentence/selectinto.html","content":"SQL SELECT INTO 语句 使用 SQL，您可以将信息从一个表中复制到另一个表中。 SELECT INTO 语句从一个表中复制数据，然后将数据插入到另一个新表中。 SQL SELECT INTO 语法我们可以把所有的列都复制到新表中： SELECT *INTO newtable [IN externaldb]FROM table1; 或者只复制希望的列插入到新表中： SELECT column_name(s)INTO newtable [IN externaldb]FROM table1; **提示：**将使用SELECT语句中定义的列名和类型创建新表。您可以使用AS子句来应用一个新名称。 SQL SELECT INTO 实例 创建 Customers 的备份复件： SELECT *INTO CustomersBackup2013FROM Customers; 请使用 IN 子句来复制表到另一个数据库中： SELECT *INTO CustomersBackup2013 IN Backup.mdbFROM Customers; 只复制一些列插入到新表中： SELECT CustomerName,ContactNameINTO CustomersBackup2013FROM Customers; 只复制德国的客户插入到新表中： SELECT *INTO CustomersBackup2013FROM CustomersWHERE Country=Germany; 复制多个表中的数据插入到新表中： SELECT Customers.CustomerName, Orders.OrderIDINTO CustomersOrderBackup2013FROM CustomersLEFT JOIN OrdersON Customers.CustomerID=Orders.CustomerID; **　提示：**SELECT INTO 语句可以用于在另一种模式下创建一个新的空表。只需添加WHERE子句，使查询返回时没有数据： SELECT *INTO newtableFROM table1WHERE 1=0;"},{"title":"SQL TRUNCATE TABLE 命令","path":"/wiki/sql/sentence/truncate.html","content":"SQL TRUNCATE TABLE 命令 SQL TRUNCATE TABLE 命令用于删除现有数据表中的所有数据。 你也可以使用 DROP TABLE 命令来删除整个数据表，不过 DROP TABLE 命令不但会删除表中所有数据，还会将整个表结构从数据库中移除。如果想要重新向表中存储数据的话，必须重建该数据表。 语法 **　TRUNCATE TABLE** 的基本语法如下所示： TRUNCATE TABLE table_name; 示例： 考虑 CUSTOMERS 表，表中的记录如下所示： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ 下面的示例展示了 TRUNCATE 命令的用法： TRUNCATE TABLE CUSTOMERS; 现在，CUSTOMERS 表已经被清空了，SELECT 语句的输出应当如下所示： SQL SELECT * FROM CUSTOMERS;Empty set (0.00 sec)"},{"title":"SQL UNION运算符","path":"/wiki/sql/sentence/union.html","content":"SQL UNION 运算符 UNION运算符用于组合两个或更多SELECT语句的结果集，而不返回任何重复的行。 UNION中的每个SELECT语句必须具有相同的列数 这些列也必须具有相似的数据类型 每个SELECT语句中的列也必须以相同的顺序排列 每个SELECT语句必须有相同数目的列表达式 但是每个SELECT语句的长度不必相同 SQL UNION 语法1SELECT column_name(s) FROM table1UNIONSELECT column_name(s) FROM table2; **注释：**默认情况下，UNION 运算符选择一个不同的值。如果允许重复值，请使用 UNION ALL。 SQL UNION 语法2SELECT column_name(s) FROM table1[WHERE condition]UNIONSELECT column_name(s) FROM table2[WHERE condition]; 给定的条件可以是基于您的需求的任何给定表达式。 SQL UNION ALL 语法1UNION All运算符用于组合两个SELECT语句(包括重复行)的结果。 适用于UNION子句的相同规则将适用于UNION All操作符。 SELECT column_name(s) FROM table1UNION ALLSELECT column_name(s) FROM table2; **注释：**UNION结果集中的列名总是等于UNION中第一个SELECT语句中的列名。 SQL UNION ALL 语法2SELECT column_name(s) FROM table1[WHERE condition]UNION ALLSELECT column_name(s) FROM table2[WHERE condition]; 演示数据库 在本教程中，我们将使用著名的Northwind示例数据库。 以下是”Customers” 表中的数据： CustomerID CustomerName ContactName Address City PostalCode Country 1 Alfreds Futterkiste Maria Anders Obere Str. 57 Berlin 12209 Germany 2 Ana Trujillo Emparedados y helados Ana Trujillo Avda. de la Constitución 2222 México D.F. 05021 Mexico 3 Antonio Moreno Taquería Antonio Moreno Mataderos 2312 México D.F. 05023 Mexico 选自 “Suppliers” 表的数据： SupplierID SupplierName ContactName Address City PostalCode Country 1 Exotic Liquid Charlotte Cooper 49 Gilbert St. Londona EC1 4SD UK 2 New Orleans Cajun Delights Shelley Burke P.O. Box 78934 New Orleans 70117 USA 3 Grandma Kelly’s Homestead Regina Murphy 707 Oxford Rd. Ann Arbor 48104 USA SQL UNION 实例下面的 SQL 语句从 “Customers” 和 “Suppliers” 表中选取所有不同的城市（只有不同的值）： 示例： SELECT City FROM CustomersUNIONSELECT City FROM SuppliersORDER BY City; **注释：**不能用 UNION 来列出两个表中的所有城市。如果一些客户和供应商来自同一个城市，每个城市将只被列入一个列表。UNION将只选择不同的值。请使用UNION ALL选择重复值! SQL UNION ALL 实例 以下SQL语句使用 UNION ALL 从 “Customers”和”Suppliers” 表中选择所有城市（也是重复的值）： 示例： SELECT City FROM CustomersUNION ALLSELECT City FROM SuppliersORDER BY City; 带有 WHERE 的 SQL UNION ALL 以下SQL语句使用UNIONALL从”Customers”和 “Suppliers” 表中选择所有德国城市（也是重复数值）： 示例： SELECT City, Country FROM CustomersWHERE Country=GermanyUNION ALLSELECT City, Country FROM SuppliersWHERE Country=GermanyORDER BY City; SQL UNION与WHERE 以下SQL语句从”客户”和”供应商”中选择所有不同的德国城市（只有不同的值）： SELECT City, Country FROM CustomersWHERE Country=GermanyUNIONSELECT City, Country FROM SuppliersWHERE Country=GermanyORDER BY City; 另一个UNION示例 以下SQL语句列出了所有客户和供应商： SELECT Customer As Type, ContactName, City, CountryFROM CustomersUNIONSELECT Supplier, ContactName, City, CountryFROM Suppliers; 还有另外两个子句(即运算符)，它们类似于UNION子句： SQL INTERSECT子句用于组合两个SELECT语句，但只返回与第二个SELECT语句中的一行相同的第一个SELECT语句中的行。 SQL EXCEPT子句用于组合两个SELECT语句，并返回第一个SELECT语句中没有由第二个SELECT语句返回的行。"},{"title":"SQL UNION子句","path":"/wiki/sql/sentence/unionziju.html","content":"SQL UNION 子句 SQL UNION 子句运算符用于将两个或者更多的 SELECT 语句的运算结果组合起来。 在使用 UNION 的时候，每个 SELECT 语句必须有相同数量的选中列、相同数量的列表达式、相同的数据类型，并且它们出现的次序要一致，不过长度不一定要相同。 语法**　UNION** 子句的基本语法如下所示： SELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition]UNIONSELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition] 这里的条件可以是任何根据你的需要而设的条件。 示例 考虑如下两张表，（a）CUSTOMERS 表： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ （b）另一张表是 ORDERS 表，如下所示： +-----+---------------------+-------------+--------+|OID | DATE | CUSTOMER_ID | AMOUNT | +-----+---------------------+-------------+--------+ | 102 | 2009-10-08 00:00:00 | 3 | 3000 || 100 | 2009-10-08 00:00:00 | 3 | 1500 | | 101 | 2009-11-20 00:00:00 | 2 | 1560 || 103 | 2008-05-20 00:00:00 | 4 | 2060 | +-----+---------------------+-------------+--------+ 现在，让我们用 SELECT 语句将这两张表连接起来： SQL SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS LEFT JOIN ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMER_IDUNION SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS RIGHT JOIN ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMER_ID; 结果如下所示： +------+----------+--------+---------------------+| ID | NAME | AMOUNT | DATE | +------+----------+--------+---------------------+ | 1 | Ramesh | NULL | NULL || 2 | Khilan | 1560 | 2009-11-20 00:00:00 | | 3 | kaushik | 3000 | 2009-10-08 00:00:00 || 3 | kaushik | 1500 | 2009-10-08 00:00:00 | | 4 | Chaitali | 2060 | 2008-05-20 00:00:00 || 5 | Hardik | NULL | NULL | | 6 | Komal | NULL | NULL || 7 | Muffy | NULL | NULL | +------+----------+--------+---------------------+ UNION ALL 子句： UNION ALL 运算符用于将两个 SELECT 语句的结果组合在一起，重复行也包含在内。 UNION ALL 运算符所遵从的规则与 UNION 一致。 语法：**　UNION ALL**的基本语法如下： SELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition]UNION ALLSELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition] 示例：考虑如下两张表，（a）CUSTOMERS 表： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ （b）另一张表是 ORDERS 表，如下所示： +-----+---------------------+-------------+--------+|OID | DATE | CUSTOMER_ID | AMOUNT | +-----+---------------------+-------------+--------+ | 102 | 2009-10-08 00:00:00 | 3 | 3000 || 100 | 2009-10-08 00:00:00 | 3 | 1500 | | 101 | 2009-11-20 00:00:00 | 2 | 1560 || 103 | 2008-05-20 00:00:00 | 4 | 2060 | +-----+---------------------+-------------+--------+ 现在，让我们用 SELECT 语句将这两张表连接起来： SQL SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS LEFT JOIN ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMER_IDUNION ALL SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS RIGHT JOIN ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMER_ID; 结果如下所示： +------+----------+--------+---------------------+| ID | NAME | AMOUNT | DATE | +------+----------+--------+---------------------+ | 1 | Ramesh | NULL | NULL || 2 | Khilan | 1560 | 2009-11-20 00:00:00 | | 3 | kaushik | 3000 | 2009-10-08 00:00:00 || 3 | kaushik | 1500 | 2009-10-08 00:00:00 | | 4 | Chaitali | 2060 | 2008-05-20 00:00:00 || 5 | Hardik | NULL | NULL | | 6 | Komal | NULL | NULL || 7 | Muffy | NULL | NULL | | 3 | kaushik | 3000 | 2009-10-08 00:00:00 || 3 | kaushik | 1500 | 2009-10-08 00:00:00 | | 2 | Khilan | 1560 | 2009-11-20 00:00:00 || 4 | Chaitali | 2060 | 2008-05-20 00:00:00 | +------+----------+--------+---------------------+ 另外，还有两个子句（亦即运算法）与 UNION 子句非常相像： SQL INTERSECT 子句：用于组合两个 SELECT 语句，但是只返回两个 SELECT 语句的结果中都有的行。 SQL EXCEPT 子句：组合两个 SELECT 语句，并将第一个 SELECT 语句的结果中存在，但是第二个 SELECT 语句的结果中不存在的行返回。"},{"title":"SQL 临时表","path":"/wiki/sql/sentence/temp.html","content":"SQL 临时表 某些关系型数据库管理系统支持临时表。临时表是一项很棒的特性，能够让你像操作普通的 SQL 数据表一样，使用 SELECT、UPDATE 和 JOIN 等功能来存储或者操作中间结果。 临时表有时候对于保存临时数据非常有用。有关临时表你需要知道的最重要的一点是，它们会在当前的终端会话结束后被删除。 临时表自 MySQL 3.23 起受到支持。如果你的 MySQL 版本比 3.23 还老，那么你就不能使用临时表了，不过你可以使用堆表（heap table）。 如先前所言，临时表只在会话期间存在。如果你在 PHP 脚本中操作数据库，那么临时表将在脚本执行完毕时被自动销毁。如果你是通过 MySQL 的客户端程序连接到 MySQL 数据库服务器的，那么临时表将会存在到你关闭客户端或者手动将其删除。 示例 下面的示例向你展示了如何使用临时表： mysql CREATE TEMPORARY TABLE SALESSUMMARY ( - product_name VARCHAR(50) NOT NULL - , total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00 - , avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00 - , total_units_sold INT UNSIGNED NOT NULL DEFAULT 0);Query OK, 0 rows affected (0.00 sec)mysql INSERT INTO SALESSUMMARY - (product_name, total_sales, avg_unit_price, total_units_sold) - VALUES - (cucumber, 100.25, 90, 2);mysql SELECT * FROM SALESSUMMARY;+--------------+-------------+----------------+------------------+| product_name | total_sales | avg_unit_price | total_units_sold |+--------------+-------------+----------------+------------------+| cucumber | 100.25 | 90.00 | 2 |+--------------+-------------+----------------+------------------+1 row in set (0.00 sec) 当你下达 SHOW TABLES 命令的时候，临时表是不会出现在结果列表当中的。现在，如果你退出 MySQL 会话，然后再执行 SELECT 命令的话，你将不能从数据库中取回任何数据，你的临时表也已经不复存在了。 删除临时表 默认情况下，所有的临时表都由 MySQL 在数据库连接关闭时删除。不过，有时候你还是会想要在会话期间将其删除，此时你需要使用 DROP TABLE 命令来达到目的。 下面是删除临时表的示例： mysql CREATE TEMPORARY TABLE SALESSUMMARY ( - product_name VARCHAR(50) NOT NULL - , total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00 - , avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00 - , total_units_sold INT UNSIGNED NOT NULL DEFAULT 0);Query OK, 0 rows affected (0.00 sec)mysql INSERT INTO SALESSUMMARY - (product_name, total_sales, avg_unit_price, total_units_sold) - VALUES - (cucumber, 100.25, 90, 2);mysql SELECT * FROM SALESSUMMARY;+--------------+-------------+----------------+------------------+| product_name | total_sales | avg_unit_price | total_units_sold |+--------------+-------------+----------------+------------------+| cucumber | 100.25 | 90.00 | 2 |+--------------+-------------+----------------+------------------+1 row in set (0.00 sec)mysql DROP TABLE SALESSUMMARY;mysql SELECT * FROM SALESSUMMARY;ERROR 1146: Table TUTORIALS.SALESSUMMARY doesnt exist"},{"title":"SQL 更新","path":"/wiki/sql/sentence/update.html","content":"SQL UPDATE 语句 UPDATE 语句用于更新表中已存在的记录。 还可以使用AND或OR运算符组合多个条件。 SQL UPDATE 语法具有WHERE子句的UPDATE查询的基本语法如下所示： UPDATE table_nameSET column1 = value1, column2 = value2, ...WHERE condition; 请注意 更新表中的记录时要小心！ 要注意SQL UPDATE 语句中的 WHERE 子句！ WHERE子句指定哪些记录需要更新。如果省略WHERE子句，所有记录都将更新！ 演示数据库 在本教程中，我们将使用著名的Northwind示例数据库。 以下是 “Customers” 表中的数据： CustomerID CustomerName ContactName Address City PostalCode Country 1 Alfreds Futterkiste Maria Anders Obere Str. 57 Berlin 12209 Germany 2 Ana Trujillo Emparedados y helados Ana Trujillo Avda. de la Constitución 2222 México D.F. 05021 Mexico 3 Antonio Moreno Taquería Antonio Moreno Mataderos 2312 México D.F. 05023 Mexico 4 Around the Horn Thomas Hardy 120 Hanover Sq. London WA1 1DP UK 5 Berglunds snabbköp Christina Berglund Berguvsvägen 8 Luleå S-958 22 Sweden SQL UPDATE 实例 以下SQL语句为第一个客户（CustomerID 1）更新了”ContactName”和”City”： 示例： UPDATE CustomersSET ContactName = Alfred Schmidt, City= FrankfurtWHERE CustomerID = 1; 现在，选自 “Customers” 表的数据如下所示： CustomerID CustomerName ContactName Address City PostalCode Country 1 Alfreds Futterkiste Alfred Schmidt Obere Str. 57 Frankfurt 12209 Germany 2 Ana Trujillo Emparedados y helados Ana Trujillo Avda. de la Constitución 2222 México D.F. 05021 Mexico 3 Antonio Moreno Taquería Antonio Moreno Mataderos 2312 México D.F. 05023 Mexico 4 Around the Horn Thomas Hardy 120 Hanover Sq. London WA1 1DP UK 5 Berglunds snabbköp Christina Berglund Berguvsvägen 8 Luleå S-958 22 Sweden 更新多个记录 WHERE子句决定了将要更新的记录数量。 以下SQL语句将把国家地区为”Mexico”的所有记录的联系人姓名更新为”Juan”： UPDATE CustomersSET ContactName=JuanWHERE Country=Mexico; “Customers”表中的选择现在看起来像这样： CustomerID CustomerName ContactName Address City PostalCode Country 1 Alfreds Futterkiste Alfred Schmidt Obere Str. 57 Frankfurt 12209 Germany 2 Ana Trujillo Emparedados y helados Juan Avda. de la Constitución 2222 México D.F. 05021 Mexico 3 Antonio Moreno Taquería Juan Mataderos 2312 México D.F. 05023 Mexico 4 Around the Horn Thomas Hardy 120 Hanover Sq. London WA1 1DP UK 5 Berglunds snabbköp Christina Berglund Berguvsvägen 8 Luleå S-958 22 Sweden Update 警告！ 更新记录时要小心。如果您省略WHERE子句，所有记录将被更新！ UPDATE CustomersSET ContactName=Juan; “Customers” 表将如下所示： CustomerID CustomerName ContactName Address City PostalCode Country 1 Alfreds Futterkiste Juan Obere Str. 57 Frankfurt 12209 Germany 2 Ana Trujillo Emparedados y helados Juan Avda. de la Constitución 2222 México D.F. 05021 Mexico 3 Antonio Moreno Taquería Juan Mataderos 2312 México D.F. 05023 Mexico 4 Around the Horn Juan 120 Hanover Sq. London WA1 1DP UK 5 Berglunds snabbköp Juan Berguvsvägen 8 Luleå S-958 22"},{"title":"SQL USE语句","path":"/wiki/sql/sentence/use.html","content":"SQL 选择数据库 USE语句 当SQL Schema中有多个数据库时，在开始操作之前，需要选择一个执行所有操作的数据库。 SQL USE语句用于选择SQL架构中的任何现有数据库。 句法USE语句的基本语法如下所示 : USE DatabaseName; 数据库名称在RDBMS中必须是唯一的。 实例 您可以查看可用的数据库，如下所示： SQL SHOW DATABASES;+--------------------+| Database |+--------------------+| information_schema || AMROOD || TUTORIALSPOINT || mysql || orig || test |+--------------------+6 rows in set (0.00 sec) 现在，如果您想使用AMROOD数据库，那么您可以执行以下SQL命令并开始使用AMROOD数据库。 SQL USE AMROOD;"},{"title":"SQL 使用视图","path":"/wiki/sql/sentence/useview.html","content":"SQL 使用视图 视图无非就是存储在数据库中并具有名字的 SQL 语句，或者说是以预定义的 SQL 查询的形式存在的数据表的成分。 视图可以包含表中的所有列，或者仅包含选定的列。视图可以创建自一个或者多个表，这取决于创建该视图的 SQL 语句的写法。 视图，一种虚拟的表，允许用户执行以下操作： 以用户或者某些类型的用户感觉自然或者直观的方式来组织数据； 限制对数据的访问，从而使得用户仅能够看到或者修改（某些情况下）他们需要的数据； 从多个表中汇总数据，以产生报表。 创建视图 在 SQL 中，视图是基于 SQL 语句的结果集的可视化表。 数据库视图由 CREATE VIEW 语句创建。视图可以创建自单个表、多个表或者其他视图。 视图中的字段是一个或多个数据库中真实表中的字段。 在使用时视图可以被视为一个”虚拟表”。 要创建视图的话，用户必须有适当的系统权限。具体需要何种权限随数据库系统实现的不同而不同。 CREATE VIEW 语句的基本语法如下所示： CREATE VIEW view_name ASSELECT column1, column2.....FROM table_nameWHERE [condition]; 和普通的 SQL SELECT 查询一样，你可以在上面的 SELECT 语句中包含多个数据表。 注释：视图总是显示最新数据！每当用户查询视图时，数据库引擎就使用视图的 SQL 语句重新构建数据。 SQL CREATE VIEW 示例 示例一考虑 CUSTOMERS 表，表中的记录如下所示： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ 下面是由 CUSTOMERS 表创建视图的例子。该视图包含来自 CUSTOMERS 表的顾客的名字（name）和年龄（age）： SQL CREATE VIEW CUSTOMERS_VIEW ASSELECT name, ageFROM CUSTOMERS; 现在，你就可以像查询普通的数据表一样查询 CUSTOMERS_VIEW 了： SQL SELECT * FROM CUSTOMERS_VIEW; 上述语句将会产生如下运行结果： +----------+-----+| name | age |+----------+-----+| Ramesh | 32 || Khilan | 25 || kaushik | 23 || Chaitali | 25 || Hardik | 27 || Komal | 22 || Muffy | 24 |+----------+-----+ 示例２下面是由 CUSTOMERS 表创建视图的例子。该视图包含来自 CUSTOMERS 表中年龄（age）为25的顾客的ADDRESS信息： SQL CREATE VIEW CUSTOMERS_ADDRESS ASSELECT ADDRESSFROM CUSTOMERS;WHERE AGE=25; 我们可以像这样查询上面这个 CUSTOMERS_ADDRESS 视图： SQL SELECT * FROM CUSTOMERS_ADDRESS; 我们也可以向查询添加条件。现在，我们仅仅需要查看 “Delhi” 的数据： SELECT * FROM CUSTOMERS_ADDRESSWHERE ADDRESS=Delhi; WITH CHECK OPTION WITH CHECK OPTION 是 CREATE VIEW 语句的一个可选项。 WITH CHECK OPTION 用于保证所有的 UPDATE 和 INSERT 语句都满足视图定义中的条件。 如果不能满足这些条件，UPDATE 或 INSERT 就会返回错误。 下面的例子创建的也是 CUSTOMERS_VIEW 视图，不过这次 WITH CHECK OPTION 是打开的： CREATE VIEW CUSTOMERS_VIEW ASSELECT name, ageFROM CUSTOMERSWHERE age IS NOT NULLWITH CHECK OPTION; 这里 WITH CHECK OPTION 使得视图拒绝任何 AGE 字段为 NULL 的条目，因为视图的定义中，AGE 字段不能为空。 更新视图 在SQL视图上也可以使用修改数据的DML语句，如 INSERT、UPDATE和DELETE。 视图可以在特定的情况下更新： SELECT 子句不能包含 DISTINCT 关键字 SELECT 子句不能包含任何汇总函数（summary functions） SELECT 子句不能包含任何集合函数（set functions） SELECT 子句不能包含任何集合运算符（set operators） SELECT 子句不能包含 ORDER BY 子句 视图不能包含连接操作符 视图不能包含伪列或表达式 FROM 子句中不能有多个数据表 WHERE 子句不能包含子查询（subquery） 查询语句中不能有 GROUP BY 或者 HAVING 计算得出的列不能更新 视图必须包含原始数据表中所有的 NOT NULL 列，从而使 INSERT 查询生效。 如果视图满足以上所有的条件，该视图就可以被更新。下面的例子中，Ramesh 的年龄被更新了： SQL UPDATE CUSTOMERS_VIEW SET AGE = 35 WHERE name=Ramesh; 最终更新的还是原始数据表，只是其结果反应在了视图上。现在查询原始数据表，SELECT 语句将会产生以下结果： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 35 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ 向视图中插入新行 可以向视图中插入新行，其规则同（使用 UPDATE 命令）更新视图所遵循的规则相同。 这里我们不能向 CUSTOMERS_VIEW 视图中添加新行，因为该视图没有包含原始数据表中所有 NOT NULL 的列。否则的话，你就可以像在数据表中插入新行一样，向视图中插入新行。 句法： INSERT INTO view_nameVALUES (value1, value2, value3, ...); 删除视图中的行 视图中的数据行可以被删除。删除数据行与更新视图和向视图中插入新行遵循相同的规则。 下面的例子将删除 CUSTOMERS_VIEW 视图中 AGE22 的数据行： SQL DELETE FROM CUSTOMERS_VIEW WHERE age = 22; 该语句最终会将原始数据表中对应的数据行删除，只不过其结果反应在了视图上。现在查询原始数据表，SELECT 语句将会产生以下结果： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 35 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ 删除视图 很明显，当我们不再需要某个视图的时候，需要有一种方式可以让我们将其删除。删除视图的语法非常简单，如下所示： DROP VIEW view_name; 下面的例子展示了如何从 CUSTOMERS 表中删除 CUSTOMERS_VIEW 视图： DROP VIEW CUSTOMERS_VIEW;"},{"title":"SQL NULL值处理","path":"/wiki/sql/sentence/valuenull.html","content":"SQL NULL 值 NULL 空值代表丢失的未知数据。 默认情况下，表列可以保存 NULL 值。 本章解释 IS NULL 和 IS NOT NULL 操作符。 SQL NULL 值 如果表中的列是可选的，那么我们可以插入一个新记录或更新一个现有记录，而无需向列添加一个值。这意味着该字段将存储为 NULL 。 NULL 值的处理与其他值不同。 NULL 为未知或不适当值的占位符。 **注释：**无法比较 NULL 和 0；它们是不等价的。 SQL 的 NULL 值处理 请看下面的 “Persons” 表： P_Id LastName FirstName Address City 1 Hansen Ola Sandnes 2 Svendson Tove Borgvn 23 Sandnes 3 Pettersen Kari Stavanger 如果 “Persons” 表 “Address” 一栏是可选的。这意味着，如果在 “Address” 列中插入一个没有值的记录，则 “Address” 列将用 NULL 值保存。 那么如何测试null的值呢？ 您不能使用比较操作符测试 NULL 值，例如、或。 我们必须使用 IS NULL 和 IS NOT NULL 操作符。 SQL IS NULL 我们如何才能选择 “Address” 列中有 NULL 值的记录？ 我们必须使用 IS NULL 操作符： SELECT LastName,FirstName,Address FROM PersonsWHERE Address IS NULL 结果集如下所示： LastName FirstName Address Hansen Ola Pettersen Kari **提示：**总是使用 IS NULL 来查找 NULL 值。 SQL IS NOT NULL 我们如何才能选择 “Address” 列中没有 NULL 值的记录？ 我们必须使用 IS NOT NULL 操作符： SELECT LastName,FirstName,Address FROM PersonsWHERE Address IS NOT NULL 结果集如下所示： LastName FirstName Address Svendson Tove Borgvn 23 在下一节中，我们将了解 ISNULL()、NVL()、IFNULL() 和 COALESCE() 函数。"},{"title":"SQL VIEW语句","path":"/wiki/sql/sentence/view.html","content":"SQL 视图（Views） 视图是可视化的表。 本章讲解如何创建、更新和删除视图。 SQL CREATE VIEW 语句 在 SQL 中，视图是基于 SQL 语句的结果集的可视化表。 视图包含行和列，就像真正的表一样。视图中的字段是一个或多个数据库中真实表中的字段。 您可以添加 SQL 函数，在哪里添加，并将语句连接到视图，或者您可以呈现数据，就像数据来自单个表一样。 SQL CREATE VIEW 语法CREATE VIEW view_name AS SELECT column_name(s) FROM table_name WHERE condition **　注释：**视图总是显示最新数据！每当用户查询视图时，数据库引擎就使用视图的 SQL 语句重新构建数据。 SQL CREATE VIEW 实例 示例数据库 Northwind 默认安装了一些视图。 “Current Product List”(当前产品列表)视图从”Products”表中列出了所有正在使用的产品（未停产的产品）。这个视图使用下面的 SQL 创建： CREATE VIEW [Current Product List] AS SELECT ProductID,ProductName FROM Products WHERE Discontinued=No 我们可以像这样查询上面这个视图： SELECT * FROM [Current Product List] Northwind 样本数据库的另一个视图会选取 “Products” 表中所有单位价格高于平均单位价格的产品： CREATE VIEW [Products Above Average Price] AS SELECT ProductName,UnitPrice FROM Products WHERE UnitPrice(SELECT AVG(UnitPrice) FROM Products) 我们可以像这样查询上面这个视图： SELECT * FROM [Products Above Average Price] Northwind 样本数据库的另一个视图会计算在 1997 年每个种类的销售总数。请注意，这个视图会从另一个名为 “Product Sales for 1997” 的视图那里选取数据： CREATE VIEW [Category Sales For 1997] AS SELECT DISTINCT CategoryName,Sum(ProductSales) AS CategorySales FROM [Product Sales for 1997] GROUP BY CategoryName 我们可以像这样查询上面这个视图： SELECT * FROM [Category Sales For 1997] 我们也可以向查询添加条件。现在，我们仅仅需要查看 “Beverages” 类的销售总数： SELECT * FROM [Category Sales For 1997] WHERE CategoryName=Beverages SQL 更新视图 您可以使用下面的语法来更新视图： SQL CREATE OR REPLACE VIEW 语法CREATE OR REPLACE VIEW view_name AS SELECT column_name(s) FROM table_name WHERE condition 现在，我们希望向 “Current Product List” 视图添加 “Category” 列。我们将通过下列 SQL 更新视图： CREATE OR REPLACE VIEW [Current Product List] AS SELECT ProductID,ProductName,Category FROM Products WHERE Discontinued=No SQL 撤销视图 您可以通过 DROP VIEW 命令来删除视图。 SQL DROP VIEW 语法DROP VIEW view_name"},{"title":"SQL 通配符","path":"/wiki/sql/sentence/wild.html","content":"SQL 通配符 我们已经讨论过 SQL 的 LIKE 操作符了，它可以利用通配符来对两个相似的值作比较。 SQL 支持以下两个通配符与 LIKE 操作符一起使用： |——–|————————————————————-| | 通配符 | 描述 | | 百分号（%） | 匹配一个或者多个字符。注意：MS Access 使用星号（*）作为匹配一个或者多个字符的通配符，而不是百分号（%）。 | | 下划线（_） | 匹配一个字符。注意：MS Access 使用问号（?），而不是下划线，来匹配任一字符。 | 百分号代表零个、一个或者多个字符。下划线代表单一的字符。这些符号可以组合在一起使用。 语法“%” 和 “_” 的基本语法如下所示： SELECT FROM table_nameWHERE column LIKE XXXX%or SELECT FROM table_nameWHERE column LIKE %XXXX%orSELECT FROM table_nameWHERE column LIKE XXXX_orSELECT FROM table_nameWHERE column LIKE _XXXXorSELECT FROM table_nameWHERE column LIKE _XXXX_ 你可以用 AND 或 OR 操作符将多个条件合并在一起。这里，XXXX 可以为任何数值或者字符串。 示例 |—————————|————————–| | 语句 | 描述 | | WHERE SALARY LIKE ‘200%’ | 找出任何以 200 开头的值。 | | WHERE SALARY LIKE ‘%200%’ | 找出任何存在 200 的值。 | | WHERE SALARY LIKE ‘00%’ | 找出任何第二个位置和第三个位置为 0 的值。 | | WHERE SALARY LIKE ‘2%_%’ | 找出任何以 2 开始，并且长度至少为 3 的值。 | | WHERE SALARY LIKE ‘%2’ | 找出任何以 2 结尾的值。 | | WHERE SALARY LIKE ‘_2%3’ | 找出任何第二个位置为 2，并且以 3 结束的值。 | | WHERE SALARY LIKE ‘2___3’ | 找出任何以 2 开始，以 3 结束的五位数。 | 让我们来看一个真实的例子，考虑拥有如下记录的 CUSTOMERS 表： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ 下面的示例将会找到 CUSTOMER 表中所有 SALARY 以 200 开头的记录，并显示出来： SQL SELECT * FROM CUSTOMERSWHERE SALARY LIKE 200%; 结果如下所示： +----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 3 | kaushik | 23 | Kota | 2000.00 |+----+----------+-----+-----------+----------+"},{"title":"SQL Wildcards通配符","path":"/wiki/sql/sentence/wildcards.html","content":"SQL Wildcards 通配符 通配符用于替换字符串中的任何其他字符。 通配符与 运算符一起使用。在 WHERE 子句中使用LIKE运算符来搜索列中的指定模式。 有两个通配符与 LIKE 运算符一起使用： ％ - 百分号表示零个，一个或多个字符 _ - 下划线表示单个字符 **　注意：** MS Access 使用星号(*）通配符而不是百分比符号(%)通配符。 MS Access 使用问号（?）而不是下划线（_）。 在MS Access和SQL Server中，你也可以使用： [ charlist ] - 定义要匹配的字符的集合和范围 [^ charlist ]或[！charlist ] - 定义不匹配字符的集合和范围 通配符也可以组合使用！ 下面是一些使用’％‘和’_‘通配符显示不同LIKE运算符的例子： LIKE运算符 描述 WHERE CustomerName LIKE ‘a%’ 查找以”a”开头的任何值 WHERE CustomerName LIKE ‘%a’ 查找以”a”结尾的任何值 WHERE CustomerName LIKE ‘%or%’ 在任何位置查找任何具有”or”的值 WHERE CustomerName LIKE ‘_r%’ 在第二个位置查找任何具有”r”的值 WHERE CustomerName LIKE ‘a_%_%’ 查找以”a”开头并且长度至少为3个字符的值 WHERE ContactName LIKE ‘a%o’ 查找以”a”开始并以”o”结尾的任何值 演示数据库 在本教程中，我们将使用著名的 Northwind 示例数据库。 以下是 “Customers” 表中的数据： CustomerID CustomerName ContactName Address City PostalCode Country 1 Alfreds Futterkiste Maria Anders Obere Str. 57 Berlin 12209 Germany 2 Ana Trujillo Emparedados y helados Ana Trujillo Avda. de la Constitución 2222 México D.F. 05021 Mexico 3 Antonio Moreno Taquería Antonio Moreno Mataderos 2312 México D.F. 05023 Mexico 4 Around the Horn Thomas Hardy 120 Hanover Sq. London WA1 1DP UK 5 Berglunds snabbköp Christina Berglund Berguvsvägen 8 Luleå S-958 22 Sweden 使用 SQL % 通配符 以下 SQL 语句选择所有客户 City 以字母”ber”开头： 示例： SELECT * FROM CustomersWHERE City LIKE ber%; 以下 SQL 语句选择 City 中包含”es”模式的所有客户： 示例： SELECT * FROM CustomersWHERE City LIKE %es%; 使用 SQL _ 通配符 以下 SQL 语句选择 City 以任意字符开头，然后是”erlin”的所有客户： 示例： SELECT * FROM CustomersWHERE City LIKE _erlin; 以下 SQL 语句选择 City 开头为”L”，后面是任意字符，后面是”n”，后面是任意字符，加”on”的所有客户： 示例： SELECT * FROM CustomersWHERE City LIKE L_n_on; 使用 SQL [charlist] 通配符 以下 SQL 语句选择所有客户 City 以”b”、”s”或”p”开头： 示例： SELECT * FROM CustomersWHERE City LIKE [bsp]%; 以下 SQL 语句选择”City”以”a”、”b”或”c”开头的所有客户： 示例： SELECT * FROM CustomersWHERE City LIKE [a-c]%; 以下 SQL 语句选择所有客户 City 不以”b”、”s”或”p”开头： 示例： SELECT * FROM CustomersWHERE City LIKE [!bsp]%; 使用[！charlist]通配符 以下两个 SQL 语句选择所有客户的城市不以”b”，”s”或”p”开头： 代码示例： SELECT * FROM CustomersWHERE City LIKE [!bsp]%; 要么： 代码示例： SELECT * FROM CustomersWHERE City NOT LIKE [bsp]%;"},{"title":"SQL 语法","path":"/wiki/sql/sentence/yufa.html","content":"SQL 语法规则 SQL语句总是以关键字开始，如SELECT、INSERT、UPDATE、DELETE、DROP、CREATE。 SQL语句以分号结尾。 SQL不区分大小写，意味着update与UPDATE相同。 数据库表 数据库通常包含一个或多个表。每个表都用一个名称标识（例如，”Customers”或”Orders”）。该表包含带有数据（行）的记录。　在本教程中，我们将使用著名的Northwind示例数据库（包括MSAccess和MSSQLServer）。 下面是选自 “Customers” 表的数据： CustomerID CustomerName ContactName Address City PostalCode Country 1 Alfreds Futterkiste Maria Anders Obere Str. 57 Berlin 12209 Germany 2 Ana Trujillo Emparedados y helados Ana Trujillo Avda. de la Constitución 2222 México D.F. 05021 Mexico 3 Antonio Moreno Taquería Antonio Moreno Mataderos 2312 México D.F. 05023 Mexico 4 Around the Horn Thomas Hardy 120 Hanover Sq. London WA1 1DP UK 5 Berglunds snabbköp Christina Berglund Berguvsvägen 8 Luleå S-958 22 Sweden 上面的表包含五条记录（每一条对应一个客户）和七个列（CustomerID、CustomerName、ContactName、Address、City、PostalCode 和 Country）。 SQL 语句 您需要在数据库上执行的大部分操作都是使用SQL语句完成的。 以下SQL语句选择”Customers”表中的所有记录： 实例SELECT * FROM Customers; 在本教程中，我们将向您解释各种不同的SQL语句。 请记住… SQL 对大小写不敏感：SELECT 与 select 是相同的。 在本教程中，我们将以大写形式编写所有SQL关键字。 SQL 语句后面的分号？ 一些数据库系统需要在每个SQL语句的末尾使用分号。 分号是分离数据库系统中每个SQL语句的标准方法，这样您就可以在对服务器的同一请求中执行多个SQL语句。 在本教程中，我们将在每个SQL语句的末尾使用分号。 一些最重要的 SQL 命令 SELECT - 从数据库中提取数据 UPDATE - 更新数据库中的数据 DELETE - 从数据库中删除数据 INSERT INTO - 向数据库中插入新数据 CREATE DATABASE - 创建新数据库 ALTER DATABASE - 修改数据库 CREATE TABLE - 创建新表 ALTER TABLE - 变更（改变）数据库表 DROP TABLE - 删除表 CREATE INDEX - 创建索引（搜索键） DROP INDEX - 删除索引 SELECT语句句法： SELECT column_name(s) FROM table_name SELECT语句和WHERE子句句法： SELECT [*] FROM [TableName] WHERE [condition1] SELECT语句与WHERE和或子句[句法： SELECT [*] FROM [TableName] WHERE [condition1] [AND [OR]] [condition2]... SELECT语句与ORDER BY句法： SELECT column_name()FROM table_nameORDER BY column_name() ASC or DESC SELECT DISTINCT(区分)子句句法： SELECT DISTINCT column1, column2....columnNFROM table_name; SELECT IN子句句法： SELECT column1, column2....columnNFROM table_nameWHERE column_name IN (val-1, val-2,...val-N); SELECT LIKE (类)子句句法： SELECT column1, column2....columnNFROM table_nameWHERE column_name LIKE PATTERN ; SELECT COUNT(计数)子句句法： SELECT COUNT(column_name)FROM table_nameWHERE CONDITION; SELECT与HAVING子句句法： SELECT SUM(column_name)FROM table_nameWHERE CONDITIONGROUP BY column_nameHAVING (arithematic function condition); INSERT INTO语句句法： INSERT INTO table_name (column, column1, column2, column3, ...)VALUES (value, value1, value2, value3 ...) UPDATE语句句法： UPDATE table_nameSET column=value, column1=value1,...WHERE someColumn=someValue DELETE语句句法： DELETE FROM tableNameWHERE someColumn = someValue CREATE 语句句法： CREATE TABLE table_name(column1 datatype,column2 datatype,column3 datatype,.....columnN datatype,PRIMARY KEY( one or more columns )); DROP 语句句法： DROP TABLE table_name; CREATE INDEX语句句法： CREATE UNIQUE INDEX index_nameON table_name ( column1, column2,...columnN); DROP INDEX语句句法： ALTER TABLE table_nameDROP INDEX index_name; DESC语句句法： DESC table_name; TRUNCATE 截断表语句句法： TRUNCATE TABLE table_name; ALTER TABLE语句句法： sql ALTER TABLE table_name ADD|DROP|MODIFY column_name data_ype; ALTER TABLE语句(对表名重命名)句法： ALTER TABLE table_name RENAME TO new_table_name; Use语句句法： USE database_name; COMMIT语句句法： COMMIT; ROLLBACK语句句法： ROLLBACK;"},{"title":"SQL 运算符","path":"/wiki/sql/sentence/yunsf.html","content":"SQL 运算符 运算符是保留字或主要用于 SQL 语句的 中的字符，用于执行操作，例如：比较和算术运算。 这些运算符用于指定 SQL 语句中的条件，并用作语句中多个条件的连词。 常见运算符有以下几种： 算术运算符 比较运算符 逻辑运算符 否定条件运算符 SQL 算术运算符 假设变量 a 的值是：10，变量 b 的值是：20，以下为各运算符执行结果： 运算符 描述 例子 + 加法，执行加法运算。 a + b 得到 30 - 减法，执行减法运算。 a - b 得到 -10 * 乘法，执行乘法运算。 a * b 得到 200 用左操作数除以右操作数。 b a 得到 2 % 用左操作数除以右操作数并返回余数。 b % a 得到 0 SQL 比较运算符 假设变量 a 的值是：10，变量 b 的值是：20，以下为各运算符执行结果： 运算符 描述 例子 检查两个操作数的值是否相等，如果是，则条件为真(true)。 (a b) is false. ! 检查两个操作数的值是否相等，如果值不相等则条件为真(true)。 (a ! b) is true. 检查两个操作数的值是否相等，如果值不相等则条件为真(true)。 (a b) is true. 检查左操作数的值是否大于右操作数的值，如果是，则条件为真(true)。 (a b) is false. 检查左操作数的值是否小于右操作数的值，如果是，则条件为真(true)。 (a b) is true. 检查左操作数的值是否大于或等于右操作数的值，如果是，则条件为真(true)。 (a b) is false 检查左操作数的值是否小于或等于右操作数的值，如果是，则条件为真(true)。 (a b) is true. ! 检查左操作数的值是否不小于右操作数的值，如果是，则条件变为真(true)。 (a ! b) is false. ! 检查左操作数的值是否不大于右操作数的值，如果是，则条件变为真(true)。 (a ! b) is true. SQL 逻辑运算符： 这是在 SQL 所有的逻辑运算符的列表。 运算符 描述 ALL ALL运算符用于将值与另一个值集中的所有值进行比较。 AND AND运算符允许在SQL语句的WHERE子句中指定多个条件。 ANY ANY运算符用于根据条件将值与列表中的任何适用值进行比较。 BETWEEN BETWEEN运算符用于搜索在给定最小值和最大值内的值。 EXISTS EXISTS运算符用于搜索指定表中是否存在满足特定条件的行。 IN运算符用于将值与已指定的文字值列表进行比较。 LIKE LIKE运算符用于使用通配符运算符将值与类似值进行比较。 NOT NOT运算符反转使用它的逻辑运算符的含义。 例如：NOT EXISTS, NOT BETWEEN, NOT IN等等，这是一个否定运算符。 OR OR运算符用于组合SQL语句的WHERE子句中的多个条件。 IS NULL IS NULL运算符用于将值与NULL值进行比较。 UNIQUE UNIQUE运算符搜索指定表的每一行的唯一性(无重复项)。"},{"title":"SQL 查询子句","path":"/wiki/sql/sentence/ziju.html","content":"SQL WHERE 子句 WHERE 子句用于过滤记录。 WHERE 子句用于提取满足指定标准的记录。 SQL WHERE 语法SELECT column1, column2, ...FROM table_nameWHERE condition; 注意： WHERE子句不仅用于SELECT语法，还用于UPDATE，DELETE语法等！ WHERE子句可以与以下类型的SQL语句一起使用： UPDATE DELETE UPDATE语句： UPDATE table_nameSET column_1 = [new value]WHERE condition; DELETE语句： DELETE FROM table_name WHERE condition; 演示数据库 在本教程中，我们将使用著名的Northwind示例数据库。　以下是 “Customers” 表中的数据： CustomerID CustomerName ContactName Address City PostalCode Country 1 Alfreds Futterkiste Maria Anders Obere Str. 57 Berlin 12209 Germany 2 Ana Trujillo Emparedados y helados Ana Trujillo Avda. de la Constitución 2222 México D.F. 05021 Mexico 3 Antonio Moreno Taquería Antonio Moreno Mataderos 2312 México D.F. 05023 Mexico 4 Around the Horn Thomas Hardy 120 Hanover Sq. London WA1 1DP UK 5 Berglunds snabbköp Christina Berglund Berguvsvägen 8 Luleå S-958 22 Sweden WHERE 子句实例 以下SQL语句从”Customers”表中选择其国家为”Mexico”的所有客户： 示例: SELECT * FROM Customers WHERE Country=Mexico; 你也可以使用OR运算符的查询子句： 示例: SELECT * FROM Customers WHERE Country=Mexico OR PostalCode=05021; 文本字段与数值字段 SQL在文本值周围使用单引号（大多数数据库系统也接受双引号）。 如果是数值字段，则不要使用引号。 示例: SELECT * FROM Customers WHERE CustomerID=1; WHERE 子句中的运算符 WHERE子句中可以使用以下运算符： 运算符 描述 等于 不等于。 注意 ：在某些版本的SQL中，这个操作符可能写成! 大于 小于 大于等于 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 IN 为列指定多个可能的值"},{"title":"SQL 选择","path":"/wiki/sql/sentence/xuanze.html","content":"SQL SELECT 语法 SELECT 语法用于从数据库中选择数据。 返回的数据存储在结果表中，称为结果集。 基本语法：SELECT和FROM在任何SQL查询语句中都：SELECT和FROM他们必须按顺序排列。SELECT指示要查看哪些列，FROM标识它们所在的表。 SQL SELECT 语法如下所示： SELECT column1, column2, ...FROM table_name; 这里，column1，column2，…是要从中选择数据的表的字段名称。如果要选择表中可用的所有字段，请使用以下语法： SELECT * FROM table_name; 演示数据库 在本教程中，我们将使用众所周知的 Northwind 样本数据库。 下面是罗斯文示例数据库中”Customers”表的一个选择： CustomerID CustomerName ContactName Address City PostalCode Country 1 Alfreds Futterkiste Maria Anders Obere Str. 57 Berlin 12209 Germany 2 Ana Trujillo Emparedados y helados Ana Trujillo Avda. de la Constitución 2222 México D.F. 05021 Mexico 3 Antonio Moreno Taquería Antonio Moreno Mataderos 2312 México D.F. 05023 Mexico 4 Around the Horn Thomas Hardy 120 Hanover Sq. London WA1 1DP UK 5 Berglunds snabbköp Christina Berglund Berguvsvägen 8 Luleå S-958 22 Sweden SELECT Column 实例 我们将为以下三种用例提供实例 1、检索一列2、检索多列3、检索所有列 我们将用上述的”Customers”表来说明三种用例的使用。 SELECT 检索一列下面的 SQL 语句从 “Customers” 表中选取 “City” 列： 实例SELECT City FROM Customers; SELECT 检索多列下面的 SQL 语句从 “Customers” 表中选取 “CustomerName” 和 “City” 列： 实例SELECT CustomerName, City FROM Customers; **注意：**这两个列名在查询中用逗号分隔。每当您选择多个列时，它们必须用逗号分隔，但最后一列名称之后不能添加逗号。 SELECT * 实例 - 检索所有列下面的 SQL 语句从 “Customers” 表中选取所有列： 实例SELECT * FROM Customers; 如果要选择表中的所有列，则可以使用 * 而不需要把所有列名罗列查询。 结果集中的导航 大多数数据库软件系统都允许使用编程函数在结果集中进行导航，例如：Move-To-First-Record、Get-Record-Content、Move-To-Next-Record 等等。 本教程中不包括与这些编程函数类似的功能。要了解如何通过函数调用访问数据，请访问我们的 或者 。"},{"title":"SQL COUNT() 函数","path":"/wiki/sql/function/count.html","content":"COUNT() 函数COUNT() 函数返回匹配指定条件的行数。 SQL COUNT(column_name) 语法COUNT(column_name) 函数返回指定列的值的数目（NULL 不计入）： SELECT COUNT(column_name) FROM table_name; SQL COUNT(*) 语法COUNT(*) 函数返回表中的记录数： SELECT COUNT(*) FROM table_name; SQL COUNT(DISTINCT column_name) 语法COUNT(DISTINCT column_name) 函数返回指定列的不同值的数目： SELECT COUNT(DISTINCT column_name) FROM table_name; 注释：COUNT(DISTINCT) 适用于 ORACLE 和 Microsoft SQL Server，但是无法用于 Microsoft Access。 演示数据库在本教程中，我们将使用 ngrok 样本数据库。 下面是选自 “access_log” 表的数据： +-----+---------+-------+------------+| aid | site_id | count | date |+-----+---------+-------+------------+| 1 | 1 | 45 | 2016-05-10 || 2 | 3 | 100 | 2016-05-13 || 3 | 1 | 230 | 2016-05-14 || 4 | 2 | 10 | 2016-05-14 || 5 | 5 | 205 | 2016-05-14 || 6 | 4 | 13 | 2016-05-15 || 7 | 3 | 220 | 2016-05-15 || 8 | 5 | 545 | 2016-05-16 || 9 | 3 | 201 | 2016-05-17 |+-----+---------+-------+------------+ SQL COUNT(column_name) 实例下面的 SQL 语句计算 “access_log” 表中 “site_id”3 的总访问量： 示例 SELECT COUNT(count) AS nums FROM access_logWHERE site_id=3; SQL COUNT(*) 实例下面的 SQL 语句计算 “access_log” 表中总记录数： 示例 SELECT COUNT(*) AS nums FROM access_log; 执行以上 SQL 输出结果如下： SQL COUNT(DISTINCT column_name) 实例mn-name-实例)下面的 SQL 语句计算 “access_log” 表中不同 site_id 的记录数： 示例 SELECT COUNT(DISTINCT site_id) AS nums FROM access_log;"}]