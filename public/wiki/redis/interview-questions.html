
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.30.1" theme-name="Stellar" theme-version="1.30.1">
  
  <meta name="generator" content="Hexo 7.3.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  
  <title>Redis：Redis 面试题 - 烟火075的博客</title>

  
    <meta name="description" content="redis面试题Redis 常见面试问题总结和答案。 什么是Redis？Redis(Remote Dictionary Server) Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API 的非关系型数据库。 传统数据库遵循 ACID 规则。而 Nosql（Not Only SQL 的">
<meta property="og:type" content="website">
<meta property="og:title" content="Redis 面试题">
<meta property="og:url" content="https://blog.zycloud.tk/wiki/redis/interview-questions.html">
<meta property="og:site_name" content="烟火075的博客">
<meta property="og:description" content="redis面试题Redis 常见面试问题总结和答案。 什么是Redis？Redis(Remote Dictionary Server) Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API 的非关系型数据库。 传统数据库遵循 ACID 规则。而 Nosql（Not Only SQL 的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanhuo075/images-repo/upload/riq1.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanhuo075/images-repo/upload/riq2.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanhuo075/images-repo/upload/riq3.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanhuo075/images-repo/upload/riq4.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanhuo075/images-repo/upload/riq5.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanhuo075/images-repo/upload/riq6.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanhuo075/images-repo/upload/riq7.png">
<meta property="article:published_time" content="2025-06-11T16:15:36.673Z">
<meta property="article:modified_time" content="2025-06-11T16:15:36.673Z">
<meta property="article:author" content="YanHuo075">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/yanhuo075/images-repo/upload/riq1.png">
  
  
  
  

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.30.1">


  

  

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/lxgw-wenkai-screen-webfont/1.7.0/lxgwwenkaiscreen.min.css" media="print" onload="this.media='all'">
</head>
<body>



<div class="l_body content tech" id="start" layout="wiki" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><div class="icon"><img no-lazy class="icon" src="https://cdn.jsdelivr.net/gh/yanhuo075/images-repo/upload/Redis.svg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></div><a class="title" href="/wiki/redis/intro.html"><div class="main" ff="title">Redis</div><div class="sub normal cap">数据库教程</div><div class="sub hover cap" style="opacity:0"> Designed by YanHuo075</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" data-filter="/wiki/redis/" placeholder="在Redis文档中搜索..."></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"><a class="nav-item" title="博客" href="/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item active" title="文档" href="/wiki/" style="color:#3DC550"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M14.25 4.48v3.057c0 .111 0 .27.02.406a.936.936 0 0 0 .445.683a.96.96 0 0 0 .783.072c.13-.04.272-.108.378-.159L17 8.005l1.124.534c.106.05.248.119.378.16a.958.958 0 0 0 .783-.073a.936.936 0 0 0 .444-.683c.021-.136.021-.295.021-.406V3.031c.113-.005.224-.01.332-.013C21.154 2.98 22 3.86 22 4.933v11.21c0 1.112-.906 2.01-2.015 2.08c-.97.06-2.108.179-2.985.41c-1.082.286-1.99 1.068-3.373 1.436c-.626.167-1.324.257-1.627.323V5.174c.32-.079 1.382-.203 1.674-.371c.184-.107.377-.216.576-.323m5.478 8.338a.75.75 0 0 1-.546.91l-4 1a.75.75 0 0 1-.364-1.456l4-1a.75.75 0 0 1 .91.546" clip-rule="evenodd"/><path fill="currentColor" d="M18.25 3.151c-.62.073-1.23.18-1.75.336a8.2 8.2 0 0 0-.75.27v3.182l.75-.356l.008-.005a1.13 1.13 0 0 1 .492-.13c.047 0 .094.004.138.01c.175.029.315.1.354.12l.009.005l.749.356V3.647z"/><path fill="currentColor" d="M12 5.214c-.334-.064-1.057-.161-1.718-.339C8.938 4.515 8.05 3.765 7 3.487c-.887-.234-2.041-.352-3.018-.412C2.886 3.007 2 3.9 2 4.998v11.146c0 1.11.906 2.01 2.015 2.079c.97.06 2.108.179 2.985.41c.486.129 1.216.431 1.873.726c1.005.451 2.052.797 3.127 1.034z" opacity=".5"/><path fill="currentColor" d="M4.273 12.818a.75.75 0 0 1 .91-.545l4 1a.75.75 0 1 1-.365 1.455l-4-1a.75.75 0 0 1-.545-.91m.909-4.545a.75.75 0 1 0-.364 1.455l4 1a.75.75 0 0 0 .364-1.455z"/></svg></a><a class="nav-item" title="笔记" href="/notes/" style="color:#FA6400"><img no-lazy src="https://cdn.jsdelivr.net/gh/yanhuo075/images-repo/upload/notes.svg" / onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="nav-item" title="友链" href="/friends/" style="color:#F44336"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M20 12a8 8 0 1 1-16 0a8 8 0 0 1 16 0" opacity=".5"/><path fill="currentColor" d="M17.712 5.453c1.047-.193 2.006-.259 2.797-.152c.77.103 1.536.393 1.956 1.064c.446.714.312 1.542-.012 2.258c-.33.728-.918 1.499-1.672 2.268c-1.516 1.547-3.836 3.226-6.597 4.697c-2.763 1.472-5.495 2.484-7.694 2.92c-1.095.217-2.098.299-2.923.201c-.8-.095-1.6-.383-2.032-1.075c-.47-.752-.296-1.63.07-2.379c.375-.768 1.032-1.586 1.872-2.403L4 12.416c0 .219.083.71.168 1.146c.045.23.09.444.123.596c-.652.666-1.098 1.263-1.339 1.756c-.277.567-.208.825-.145.925c.072.116.305.305.937.38c.609.073 1.44.018 2.455-.183c2.02-.4 4.613-1.351 7.28-2.772c2.667-1.42 4.85-3.015 6.23-4.423c.694-.707 1.15-1.334 1.377-1.836c.233-.515.167-.75.107-.844c-.07-.112-.289-.294-.883-.374c-.542-.072-1.272-.041-2.163.112L16.87 5.656c.338-.101.658-.17.842-.203"/></svg></a></nav>
</div>
<div class="widgets">

<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">第一章 Redis教程</span></div><div class="widget-body fs14"><a class="link" href="/wiki/redis/intro.html#start"><span class="toc-text">Redis 简介</span></a><a class="link" href="/wiki/redis/install.html"><span class="toc-text">Redis 安装</span></a><a class="link" href="/wiki/redis/config.html"><span class="toc-text">Redis 配置文件详解</span></a><a class="link" href="/wiki/redis/data-types.html"><span class="toc-text">Redis 数据类型</span></a></div><div class="widget-header dis-select"><span class="name">第二章 Redis命令</span></div><div class="widget-body fs14"><a class="link" href="/wiki/redis/commands.html"><span class="toc-text">Redis 命令</span></a><a class="link" href="/wiki/redis/keys.html"><span class="toc-text">Redis 键</span></a><a class="link" href="/wiki/redis/strings.html"><span class="toc-text">Redis 字符串</span></a><a class="link" href="/wiki/redis/hashes.html"><span class="toc-text">Redis 哈希</span></a><a class="link" href="/wiki/redis/lists.html"><span class="toc-text">Redis 列表</span></a><a class="link" href="/wiki/redis/sets.html"><span class="toc-text">Redis 集合</span></a><a class="link" href="/wiki/redis/sorted-sets.html"><span class="toc-text">Redis 有序集合</span></a><a class="link" href="/wiki/redis/hyperloglog.html"><span class="toc-text">Redis HyperLogLog</span></a><a class="link" href="/wiki/redis/geo.html"><span class="toc-text">Redis 地理信息GEO</span></a><a class="link" href="/wiki/redis/stream.html"><span class="toc-text">Redis Stream</span></a><a class="link" href="/wiki/redis/pub-sub.html"><span class="toc-text">Redis 发布订阅</span></a><a class="link" href="/wiki/redis/transaction.html"><span class="toc-text">Redis 事务</span></a><a class="link" href="/wiki/redis/scripting.html"><span class="toc-text">Redis 脚本</span></a><a class="link" href="/wiki/redis/connection.html"><span class="toc-text">Redis 连接</span></a><a class="link" href="/wiki/redis/server.html"><span class="toc-text">Redis 服务器</span></a></div><div class="widget-header dis-select"><span class="name">第三章 Redis高级功能</span></div><div class="widget-body fs14"><a class="link" href="/wiki/redis/backup-restore.html"><span class="toc-text">Redis 备份和恢复</span></a><a class="link" href="/wiki/redis/persistence.html"><span class="toc-text">Redis 持久化</span></a><a class="link" href="/wiki/redis/security.html"><span class="toc-text">Redis 安全</span></a><a class="link" href="/wiki/redis/benchmarks.html"><span class="toc-text">Redis 性能测试</span></a><a class="link" href="/wiki/redis/client-connection.html"><span class="toc-text">Redis 客户端连接</span></a><a class="link" href="/wiki/redis/pipelining.html"><span class="toc-text">Redis 流水线</span></a><a class="link" href="/wiki/redis/partitioning.html"><span class="toc-text">Redis 分区</span></a><a class="link" href="/wiki/redis/java-redis.html"><span class="toc-text">Java 使用 Redis</span></a><a class="link" href="/wiki/redis/php-redis.html"><span class="toc-text">PHP 使用 Redis</span></a></div><div class="widget-header dis-select"><span class="name">第四章 Redis差异</span></div><div class="widget-body fs14"><a class="link" href="/wiki/redis/redis-vs-memcached.html"><span class="toc-text">Redis 和 Memcached</span></a><a class="link" href="/wiki/redis/redis-vs-mongodb.html"><span class="toc-text">Redis 和 MongoDB</span></a><a class="link" href="/wiki/redis/redis-vs-elasticsearch.html"><span class="toc-text">Redis 和 Elasticsearch</span></a></div><div class="widget-header dis-select"><span class="name">第五章 Redis面试题</span></div><div class="widget-body fs14"><a class="link active" href="/wiki/redis/interview-questions.html"><span class="toc-text">Redis 面试题</span><svg class="active-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M21 11.098v4.993c0 3.096 0 4.645-.734 5.321c-.35.323-.792.526-1.263.58c-.987.113-2.14-.907-4.445-2.946c-1.02-.901-1.529-1.352-2.118-1.47a2.225 2.225 0 0 0-.88 0c-.59.118-1.099.569-2.118 1.47c-2.305 2.039-3.458 3.059-4.445 2.945a2.238 2.238 0 0 1-1.263-.579C3 20.736 3 19.188 3 16.091v-4.994C3 6.81 3 4.666 4.318 3.333C5.636 2 7.758 2 12 2c4.243 0 6.364 0 7.682 1.332C21 4.665 21 6.81 21 11.098" opacity=".5"/><path fill="currentColor" d="M9 5.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5z"/></svg></a></div></widget>

<widget class="widget-wrapper post-card"><div class="widget-header dis-select"><span class="name">更多：数据库</span></div><div class="widget-body"><a class="item wiki" href="/wiki/sql/index.html"><span class="title">数据库SQL语法大全</span><span class="excerpt">SQL 是用于访问和处理数据库的标准的计算机语言。</span></a></div></widget>
</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="/" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/08a41b181ce68.svg"/></a><a class="social" onclick="switchTheme()"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024"><path fill="currentColor" fill-rule="evenodd" d="M582.4 326.4c-140.8 0-256 115.2-256 256s115.2 256 256 256 256-115.2 256-256-115.2-256-256-256z m0 448c-70.4 0-131.2-36.8-164.8-92.8 12.8 3.2 27.2 4.8 40 4.8 121.6 0 219.2-99.2 219.2-219.2 0-17.6-1.6-35.2-6.4-52.8 60.8 32 102.4 96 102.4 169.6 1.6 104-84.8 190.4-190.4 190.4zM582.4 262.4c17.6 0 32-14.4 32-32v-128c0-17.6-14.4-32-32-32s-32 14.4-32 32v128c0 17.6 14.4 32 32 32zM262.4 582.4c0-17.6-14.4-32-32-32h-128c-17.6 0-32 14.4-32 32s14.4 32 32 32h128c17.6 0 32-14.4 32-32zM310.4 356.8c6.4 6.4 14.4 9.6 22.4 9.6 8 0 16-3.2 22.4-9.6 12.8-12.8 12.8-32 0-44.8l-91.2-91.2c-12.8-12.8-32-12.8-44.8 0-12.8 12.8-12.8 32 0 44.8l91.2 91.2zM944 220.8c-12.8-12.8-32-12.8-44.8 0l-91.2 91.2c-12.8 12.8-12.8 32 0 44.8 6.4 6.4 14.4 9.6 22.4 9.6 8 0 16-3.2 22.4-9.6l91.2-91.2c12.8-12.8 12.8-33.6 0-44.8zM310.4 808l-91.2 91.2c-12.8 12.8-12.8 32 0 44.8 6.4 6.4 14.4 9.6 22.4 9.6 8 0 16-3.2 22.4-9.6l91.2-91.2c12.8-12.8 12.8-32 0-44.8-11.2-11.2-32-11.2-44.8 0z"></path></svg></a></div></footer>
</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" id="menu" href="/wiki">文档</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/wiki/redis/intro.html">Redis</a></div>
<div class="flex-row" id="post-meta"><span class="text created">更新于：<time datetime="2025-06-11T16:15:36.673Z">2025-06-12</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>Redis 面试题</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><h1 id="redis面试题"><a href="#redis面试题" class="headerlink" title="redis面试题"></a>redis面试题</h1><p><strong>Redis 常见面试问题</strong>总结和答案。</p>
<h2 id="什么是Redis？"><a href="#什么是Redis？" class="headerlink" title="什么是Redis？"></a>什么是Redis？</h2><p>Redis(Remote Dictionary Server) Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 <a target="_blank" rel="noopener" href="https://www.redis.com.cn/clients.html">API</a> 的非关系型数据库。</p>
<p>传统数据库遵循 ACID 规则。而 Nosql（Not Only SQL 的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称） 一般为分布式而分布式一般遵循 CAP 定理。</p>
<p>Github 源码：<a target="_blank" rel="noopener" href="https://github.com/antirez/redis">https://github.com/antirez/redis</a></p>
<p>Redis 官网：<a target="_blank" rel="noopener" href="https://redis.io/">https://redis.io/</a></p>
<p>与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value 数据库。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务、持久化、LUA 脚本、LRU 驱动事件、多种集群方案。</p>
<h2 id="Redis支持的数据类型？"><a href="#Redis支持的数据类型？" class="headerlink" title="Redis支持的数据类型？"></a>Redis支持的数据类型？</h2><p>Redis 可以存储键和不同类型的值之间的映射。键的类型只能为字符串，值常见有五种数据类型：字符串、列表、集合、散列表、有序集合。</p>
<p><strong>String字符串</strong>：</p>
<p>格式: set key value</p>
<p>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</p>
<p>string类型是Redis最基本的数据类型，一个键最大能存储512MB。</p>
<p><strong>Hash（哈希）</strong></p>
<p>格式: hmset name key1 value1 key2 value2</p>
<p>Redis hash 是一个键值(key&#x3D;&gt;value)对集合。</p>
<p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<p><strong>List（列表）</strong></p>
<p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<p>格式: lpush name value</p>
<p>在 key 对应 list 的头部添加字符串元素</p>
<p>格式: rpush name value</p>
<p>在 key 对应 list 的尾部添加字符串元素</p>
<p>格式: lrem name index</p>
<p>key 对应 list 中删除 count 个和 value 相同的元素</p>
<p>格式: llen name</p>
<p>返回 key 对应 list 的长度</p>
<p><strong>Set（集合）</strong></p>
<p>格式: sadd name value</p>
<p>Redis的Set是string类型的无序集合。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p>
<p><strong>zset(sorted set：有序集合)</strong></p>
<p>格式: zadd name score value</p>
<p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。</p>
<p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>zset的成员是唯一的,但分数(score)却可以重复。</p>
<h2 id="什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？"><a href="#什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？" class="headerlink" title="什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？"></a>什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？</h2><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p>
<p>Redis 提供了两种持久化方式:RDB（默认） 和AOF</p>
<p><strong>RDB：</strong></p>
<p>rdb是Redis DataBase缩写</p>
<p>功能核心函数rdbSave(生成RDB文件)和rdbLoad（从文件加载内存）两个函数</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/yanhuo075/images-repo/upload/riq1.png" alt="img"></p>
<p><strong>AOF:</strong></p>
<p>Aof是Append-only file缩写</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/yanhuo075/images-repo/upload/riq2.png" alt="img"></p>
<p>每当执行服务器(定时)任务或者函数时flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作</p>
<p>aof写入保存：</p>
<p>WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件</p>
<p>SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。</p>
<p><strong>存储结构:</strong></p>
<p>内容是redis通讯协议(RESP )格式的命令文本存储。</p>
<p><strong>比较</strong>：</p>
<p>1、aof文件比rdb更新频率高，优先使用aof还原数据。</p>
<p>2、aof比rdb更安全也更大</p>
<p>3、rdb性能比aof好</p>
<p>4、如果两个都配了优先加载AOF</p>
<h2 id="刚刚上面你有提到redis通讯协议-RESP-，能解释下什么是RESP？有什么特点？（可以看到很多面试其实都是连环炮，面试官其实在等着你回答到这个点，如果你答上了对你的评价就又加了一分）"><a href="#刚刚上面你有提到redis通讯协议-RESP-，能解释下什么是RESP？有什么特点？（可以看到很多面试其实都是连环炮，面试官其实在等着你回答到这个点，如果你答上了对你的评价就又加了一分）" class="headerlink" title="刚刚上面你有提到redis通讯协议(RESP )，能解释下什么是RESP？有什么特点？（可以看到很多面试其实都是连环炮，面试官其实在等着你回答到这个点，如果你答上了对你的评价就又加了一分）"></a>刚刚上面你有提到redis通讯协议(RESP )，能解释下什么是RESP？有什么特点？（可以看到很多面试其实都是连环炮，面试官其实在等着你回答到这个点，如果你答上了对你的评价就又加了一分）</h2><p>RESP 是redis客户端和服务端之前使用的一种通讯协议；</p>
<p>RESP 的特点：实现简单、快速解析、可读性好</p>
<p>For Simple Strings the first byte of the reply is “+” 回复</p>
<p>For Errors the first byte of the reply is “-“ 错误</p>
<p>For Integers the first byte of the reply is “:” 整数</p>
<p>For Bulk Strings the first byte of the reply is “$” 字符串</p>
<p>For Arrays the first byte of the reply is “*” 数组</p>
<h2 id="Redis-有哪些架构模式？讲讲各自的特点"><a href="#Redis-有哪些架构模式？讲讲各自的特点" class="headerlink" title="Redis 有哪些架构模式？讲讲各自的特点"></a>Redis 有哪些架构模式？讲讲各自的特点</h2><p><strong>单机版</strong></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/yanhuo075/images-repo/upload/riq3.png" alt="img"></p>
<p>特点：简单</p>
<p>问题：</p>
<p>1、内存容量有限 2、处理能力有限 3、无法高可用。</p>
<p><strong>主从复制</strong></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/yanhuo075/images-repo/upload/riq4.png" alt="img"></p>
<p>Redis 的复制（replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（master），而通过复制创建出来的服务器复制品则为从服务器（slave）。 只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。</p>
<p>特点：</p>
<p>1、master&#x2F;slave 角色</p>
<p>2、master&#x2F;slave 数据相同</p>
<p>3、降低 master 读压力在转交从库</p>
<p>问题：</p>
<p>无法保证高可用</p>
<p>没有解决 master 写的压力</p>
<p><strong>哨兵</strong></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/yanhuo075/images-repo/upload/riq5.png" alt="img"></p>
<p>Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：</p>
<p>监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</p>
<p>提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</p>
<p>自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。</p>
<p>特点：</p>
<p>1、保证高可用</p>
<p>2、监控各个节点</p>
<p>3、自动故障迁移</p>
<p>缺点：主从模式，切换需要时间丢数据</p>
<p>没有解决 master 写的压力</p>
<p><strong>集群（proxy 型）：</strong></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/yanhuo075/images-repo/upload/riq6.png" alt="img"></p>
<p>Twemproxy 是一个 Twitter 开源的一个 redis 和 memcache 快速&#x2F;轻量级代理服务器； Twemproxy 是一个快速的单线程代理程序，支持 Memcached ASCII 协议和 redis 协议。</p>
<p>特点：1、多种 hash 算法：MD5、CRC16、CRC32、CRC32a、hsieh、murmur、Jenkins</p>
<p>2、支持失败节点自动删除</p>
<p>3、后端 Sharding 分片逻辑对业务透明，业务方的读写方式和操作单个 Redis 一致</p>
<p>缺点：增加了新的 proxy，需要维护其高可用。</p>
<p>failover 逻辑需要自己实现，其本身不能支持故障的自动转移可扩展性差，进行扩缩容都需要手动干预</p>
<p><strong>集群（直连型）：</strong></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/yanhuo075/images-repo/upload/riq7.png" alt="img"></p>
<p>从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。</p>
<p>特点：</p>
<p>1、无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。</p>
<p>2、数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。</p>
<p>3、可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。</p>
<p>4、高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本</p>
<p>5、实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。</p>
<p>缺点：</p>
<p>1、资源隔离性较差，容易出现相互影响的情况。</p>
<p>2、数据通过异步复制,不保证数据的强一致性</p>
<h2 id="什么是一致性哈希算法？什么是哈希槽？"><a href="#什么是一致性哈希算法？什么是哈希槽？" class="headerlink" title="什么是一致性哈希算法？什么是哈希槽？"></a>什么是一致性哈希算法？什么是哈希槽？</h2><p>这两个问题篇幅过长 网上找了两个解锁的不错的文章</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lpfuture/p/5796398.html">https://www.cnblogs.com/lpfuture/p/5796398.html</a></p>
<p><a target="_blank" rel="noopener" href="http://www.jasontec.cn/articles/2020/04/11/1586586130767.html">http://www.jasontec.cn/articles/2020/04/11/1586586130767.html</a></p>
<h2 id="Redis常用命令？"><a href="#Redis常用命令？" class="headerlink" title="Redis常用命令？"></a>Redis常用命令？</h2><p>Keys pattern</p>
<p>列出所有key，*表示区配所有。</p>
<p>Set</p>
<p>设置 key 对应的值为 string 类型的 value。</p>
<p>setnx</p>
<p>设置 key 对应的值为 string 类型的 value。如果 key 已经存在，返回 0，nx 是 not exist 的意思。</p>
<p>Del</p>
<p>删除某个key，第一次返回1 删除了 第二次返回0</p>
<p>Expire</p>
<p>设置过期时间（单位秒）</p>
<p>TTL</p>
<p>查看剩下多少时间，返回负数则key失效，key不存在了</p>
<p>Setex</p>
<p>设置 key 对应的值为 string 类型的 value，并指定此键值对应的有效期。</p>
<p>Mset</p>
<p>一次设置多个 key 的值，成功返回 ok 表示所有的值都设置了，失败返回 0 表示没有任何值被设置。</p>
<p>Getset</p>
<p>设置 key 的值，并返回 key 的旧值。</p>
<p>Mget</p>
<p>一次获取多个 key 的值，如果对应 key 不存在，则对应返回 nil。</p>
<p>Incr</p>
<p>对 key 的值做加加操作,并返回新的值。注意 incr 一个不是 int 的 value 会返回错误，incr 一个不存在的 key，则设置 key 为 1</p>
<p>incrby</p>
<p>同 incr 类似，加指定值 ，key 不存在时候会设置 key，并认为原来的 value 是 0</p>
<p>Decr</p>
<p>对 key 的值做的是减减操作，decr 一个不存在 key，则设置 key 为-1</p>
<p>Decrby</p>
<p>同 decr，减指定值。</p>
<p>Append</p>
<p>给指定 key 的字符串值追加 value,返回新字符串值的长度。</p>
<p>Strlen</p>
<p>取指定 key 的 value 值的长度。</p>
<p>persist xxx(取消过期时间)</p>
<p>选择数据库（0-15库）</p>
<p>Select 0</p>
<p>选择数据库</p>
<p>move age 1</p>
<p>把age 移动到1库</p>
<p>Randomkey</p>
<p>随机返回一个key</p>
<p>Rename</p>
<p>重命名</p>
<p>Type</p>
<p>返回数据类型</p>
<h2 id="使用过Redis分布式锁么，它是怎么实现的？"><a href="#使用过Redis分布式锁么，它是怎么实现的？" class="headerlink" title="使用过Redis分布式锁么，它是怎么实现的？"></a>使用过Redis分布式锁么，它是怎么实现的？</h2><p>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。</p>
<p><strong>如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？</strong></p>
<p>set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！</p>
<h2 id="使用过Redis做异步队列么，你是怎么用的？有什么缺点？"><a href="#使用过Redis做异步队列么，你是怎么用的？有什么缺点？" class="headerlink" title="使用过Redis做异步队列么，你是怎么用的？有什么缺点？"></a>使用过Redis做异步队列么，你是怎么用的？有什么缺点？</h2><p>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。</p>
<p>缺点：</p>
<p>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。</p>
<p><strong>能不能生产一次消费多次呢？</strong></p>
<p>使用pub&#x2F;sub主题订阅者模式，可以实现1:N的消息队列。</p>
<h2 id="什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？"><a href="#什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？" class="headerlink" title="什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？"></a>什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？</h2><p><strong>缓存穿透</strong></p>
<p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p>
<p>如何避免？</p>
<p>1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。</p>
<p>2：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。</p>
<p><strong>缓存雪崩</strong></p>
<p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。</p>
<p>如何避免？</p>
<p>1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<p>2：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期</p>
<p>3：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
<h2 id="Redis的用途是什么？"><a href="#Redis的用途是什么？" class="headerlink" title="Redis的用途是什么？"></a>Redis的用途是什么？</h2><p><strong>计数器</strong> 可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p>
<p><strong>缓存</strong>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p>
<p><strong>会话缓存</strong> 可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p>
<p><strong>全页缓存（FPC）</strong> 除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p>
<p><strong>查找表</strong> 例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了Redis快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p>
<p><strong>消息队列(发布&#x2F;订阅功能)</strong> List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。</p>
<p><strong>分布式锁实现</strong> 在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p>
<p><strong>其它</strong> Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet可以实现有序性操作，从而实现排行榜等功能。</p>
<h2 id="如何与Redis连接？"><a href="#如何与Redis连接？" class="headerlink" title="如何与Redis连接？"></a>如何与Redis连接？</h2><p>安装服务器后，可以运行 redis 安装时提供的 Redis 客户端，也可以打开命令提示符并使用以下命令：</p>
<p> redis-cli</p>
<p>通过使用其中任何一个，您可以与 Redis 交互。</p>
<h2 id="Redis的主要特点是什么？"><a href="#Redis的主要特点是什么？" class="headerlink" title="Redis的主要特点是什么？"></a>Redis的主要特点是什么？</h2><p>以下是 Redis 的主要功能：</p>
<ul>
<li>读写性能优异， Redis 能读的速度是 110000 次&#x2F;s，写的速度是 81000 次&#x2F;s。</li>
<li>支持数据持久化，支持 AOF 和 RDB 两种持久化方式。</li>
<li>支持事务，Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作合并后的原子性执行。</li>
<li>数据结构丰富，除了支持 string 类型的 value 外还支持 hash、set、zset、list 等数据结构。</li>
<li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li>
</ul>
<h2 id="解释Redis的复制功能？"><a href="#解释Redis的复制功能？" class="headerlink" title="解释Redis的复制功能？"></a>解释Redis的复制功能？</h2><p>Redis 可以使用主从同步，从从同步。第一次同步时，主节点做一次 bgsave，并同时将后续修改操作记录到内存 buffer，待完成后将 rdb 文件全量同步到复制节点，复制节点接受完成后将 rdb 镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p>
<h2 id="Redis和RDBMS有什么区别？"><a href="#Redis和RDBMS有什么区别？" class="headerlink" title="Redis和RDBMS有什么区别？"></a>Redis和RDBMS有什么区别？</h2><p>Redis 和 RDBMS 之间存在很多差异：</p>
<ul>
<li>Redis 是 NoSQL 数据库，而 RDBMS 是 SQL 数据库。</li>
<li>Redis 遵循键值结构，而 RDBMS 遵循表结构。</li>
<li>Redis 非常快，而 RDBMS 相对较慢。</li>
<li>Redis 将所有数据集存储在主存储器中，而 RDBMS 将其数据集存储在辅助存储器中。</li>
<li>Redis 通常用于存储小型和常用文件，而 RDBMS 用于存储大文件。</li>
<li>Redis 仅为 Linux，BSD，Mac OS X，Solaris 提供官方支持。它目前没有为 Windows 提供官方支持，而 RDBMS 提供对两者的支持。</li>
</ul>
<h2 id="为什么Redis不同于其他的键值存储数据库？"><a href="#为什么Redis不同于其他的键值存储数据库？" class="headerlink" title="为什么Redis不同于其他的键值存储数据库？"></a>为什么Redis不同于其他的键值存储数据库？</h2><p>有两个主要原因：</p>
<ul>
<li>Redis发展方向不同与其他键值数据库，<strong>它能包含很多复杂数据类型，对这些数据类型操作都是原子的</strong>。Redis数据类型与基本数据结构强相关，直接暴露给程序员，没有增加抽象层。</li>
<li>Redis是一个基于内存的，能够持久化到硬盘的数据库，<strong>因此为了实现高速读写，数据集大小不能超过内存</strong>。内存数据库另一个优点是，内存数据库相对于硬盘数据库非常容易操作复杂数据结构，因此Redis的可以做很多事情，内部复杂性低。与此同时两款磁盘存储格式（RDB和AOF）不需要支持随机访问，因此他们是紧凑的，而且总是以追加形式生成（甚至AOF日志轮换也是一个追加操作，因为新版本是由内存中的副本生成）。比起基于磁盘的数据存储， Redis 用来处理重要数据时需要确保数据集及时落盘刷新。</li>
</ul>
<h2 id="Redis内存使用情况？"><a href="#Redis内存使用情况？" class="headerlink" title="Redis内存使用情况？"></a>Redis内存使用情况？</h2><p>举几个例子（所有数据基于64位实例）</p>
<ul>
<li>一个空实例大约占用3M内存</li>
<li>1百万简单字符串键值对大约占用85M内存</li>
<li>1百万哈希表键值对，每个对象有5个属性，大约占用160M内存</li>
</ul>
<p>为了测试你的用例，使用redis-benchmark工具生成随机数据集，使用INFO memory命令检查使用内存空间。</p>
<p>存储相同的键，64位系统比32位系统使用更多的内存，键值很小情况下更明显。这是因为64位系统指针占用8字节。但是64位系统优点是可以配置更多内存（校对注：32位操作系统支持的内存最多为2的32次方，就是4G），因此为了运行大型Redis服务器，64位系统尤佳。另一种方案是使用分片。</p>
<h2 id="我喜欢Redis的高性能操作和特性，但是不喜欢所有内容都在内存中，我不能创建一个比内存更大数据集。有计划改变吗？"><a href="#我喜欢Redis的高性能操作和特性，但是不喜欢所有内容都在内存中，我不能创建一个比内存更大数据集。有计划改变吗？" class="headerlink" title="我喜欢Redis的高性能操作和特性，但是不喜欢所有内容都在内存中，我不能创建一个比内存更大数据集。有计划改变吗？"></a>我喜欢Redis的高性能操作和特性，但是不喜欢所有内容都在内存中，我不能创建一个比内存更大数据集。有计划改变吗？</h2><p>过去为了允许数据集超过RAM大小，Redis开发人员尝试使用虚拟内存和其他系统，但是我们非常高兴可以把一件事情做好：数据服务由内存提供，磁盘用于存储数据。所以现在没有计划为Redis创建磁盘后端，毕竟Redis大部分特性都是基于其当前架构设计的。</p>
<p>你的真正问题并不是所需的总内存，而是你需要划分你的数据集到多个Redis实例上，为了获取更多信息请阅读本文档中的分区页面。</p>
<h2 id="同时使用Redis和磁盘数据库，是不是一个好想法？"><a href="#同时使用Redis和磁盘数据库，是不是一个好想法？" class="headerlink" title="同时使用Redis和磁盘数据库，是不是一个好想法？"></a>同时使用Redis和磁盘数据库，是不是一个好想法？</h2><p>是的，一个通用的设计方案是，在非常频繁的写小的数据时采用Redis（并且你需要使用Redis数据结构给你的问题建立高效模型），以及将大数据存储到SQL数据库或者最终一致性磁盘数据库中。</p>
<h2 id="有没有方法降低Redis内存使用率？"><a href="#有没有方法降低Redis内存使用率？" class="headerlink" title="有没有方法降低Redis内存使用率？"></a>有没有方法降低Redis内存使用率？</h2><p>如果可以的话使用Redis 32位实例。另外，还要善于使用哈希表，列表，有序集合和整数集，因为在特殊情况下Redis使用这些数据类型可以更紧凑存储一些元素。可以在内存优化页面获取更多信息。</p>
<h2 id="Redis内存不足时会发生什么？"><a href="#Redis内存不足时会发生什么？" class="headerlink" title="Redis内存不足时会发生什么？"></a>Redis内存不足时会发生什么？</h2><p>Redis要么被Linux内核OOM杀掉，抛出错误崩溃，要么开始变得卡顿。随着现代操作系统malloc方法通常都不返回NULL，而是服务器开始交换，因此Redis性能降低，因此你可能会观察到一些错误现象。</p>
<p>INFO命令返回Redis使用内存总量，因此你可以编写脚本监控Redis服务器内存临界值。</p>
<p>Redis内置保护措施允许用户在配置文件中使用<code>maxmemory</code>选项，设置Redis最大占用内存。如果达到此限制，Redis将开始返回错误给写命令（但是将继续接受只读命令），或者当最大内存限制达到时也可以配置为键淘汰，在这种情况下Redis作为缓存使用。</p>
<p>我们有文档描述Redis作为LRU缓存使用。</p>
<h2 id="在Linux系统中，即使我有很多空闲内存，后台保存失败报fork-错误！"><a href="#在Linux系统中，即使我有很多空闲内存，后台保存失败报fork-错误！" class="headerlink" title="在Linux系统中，即使我有很多空闲内存，后台保存失败报fork()错误！"></a>在Linux系统中，即使我有很多空闲内存，后台保存失败报fork()错误！</h2><p>精简回答：<code>echo 1 &gt; /proc/sys/vm/overcommit_memory</code></p>
<p>详细回答：</p>
<p>Redis后台保存模式依赖现代操作系统的写时拷贝技术。Redis fork（创建一个子进程）是父进程精确拷贝。子进程存储数据到磁盘并且最终退出。从理论上讲，子进程应该和父进程使用同样多内存，作为父进程副本，但是得益于多数现代操作系统实现的写时复制技术，父进程和子进程共享内存页。内存页在父进程或子进程改变时将被复制。当子进程保存时，理论上所有页面都可能改变，Linux无法提前告知子进程需要多少内存，因此如果overcommit_memory设置为0，fork将会失败除非有足够的空闲RAM真正复制父进程内存页.结果是，如果你有3G Redis数据集，只有2G可用内存将会失败。</p>
<p>overcommit_memory设置为1，意味着Linux 使用更乐观方式fork，这确实是你所期望的Redis。</p>
<p>“理解虚拟机内存 ”是红帽经典文章，可以了解Linux虚拟内存怎么工作，overcommitmemory和overcommitratio的替代品。这篇文章校正了proc(5)用户手册对overcommit_memory1和2配置正确含义。</p>
<h2 id="Redis磁盘快照是不是原子操作？"><a href="#Redis磁盘快照是不是原子操作？" class="headerlink" title="Redis磁盘快照是不是原子操作？"></a>Redis磁盘快照是不是原子操作？</h2><p>是的，当服务器不在执行命令时，Redis后台保存进程总是被创建，因此每个命令在RAM中是原子的，并且在磁盘快照过程也是原子的。</p>
<h2 id="Redis是单线程的，我怎么利用多CPU-核"><a href="#Redis是单线程的，我怎么利用多CPU-核" class="headerlink" title="Redis是单线程的，我怎么利用多CPU&#x2F;核?"></a>Redis是单线程的，我怎么利用多CPU&#x2F;核?</h2><p>CPU基本不可能成为的Redis的瓶颈，因为通常Redis受限于内存或网络。例如使用Pipelining，Redis运行在普通的Linux系统上，每秒可以处理50万请求，所以如果你的应用程序主要使用O(N) 或者 O(log(N))命令，几乎不会使用太多的CPU。</p>
<p>然而为了最大限度利用CPU，你可以在一台机器上启动多个Redis实例，并把它们设置为不同服务器。某些时候单个机器是不够的，所以如果你想使用多个CPU，你可以提前考虑使用分片。</p>
<p>关于使用多Redis实例，你可以在Partitioning page找到更多的信息</p>
<h2 id="单个Redis实例最多可以存储多少键？哈希表、列表、集合和有序集合最大可以包含多少元素？"><a href="#单个Redis实例最多可以存储多少键？哈希表、列表、集合和有序集合最大可以包含多少元素？" class="headerlink" title="单个Redis实例最多可以存储多少键？哈希表、列表、集合和有序集合最大可以包含多少元素？"></a>单个Redis实例最多可以存储多少键？哈希表、列表、集合和有序集合最大可以包含多少元素？</h2><p>Redis最大可以处理232键，实践测试每个实例最少可以处理2.5亿键。</p>
<p>每个哈希表、列表、集合和有序集合可以容纳232元素。</p>
<p>换句话说，Redis极限容量就是系统可用内存。</p>
<h2 id="为什么从实例与主实例拥有不同数量键？"><a href="#为什么从实例与主实例拥有不同数量键？" class="headerlink" title="为什么从实例与主实例拥有不同数量键？"></a>为什么从实例与主实例拥有不同数量键？</h2><p>如果你使用有生存周期的键，这就是正常现象。这就导致主从实例键的数量不一致原因。</p>
<ul>
<li>主实例在第一次与从实例同步时生成RDB文件。</li>
<li>RDB文件不包含已经过期的键，但是已经过期的键仍然在内存中。</li>
<li>尽管这些键从逻辑上说已经过期失效，但是还在Redis主实例内存中，他们并不被识别为存在的，当增量或访问这些键时这些键会被回收。尽管从逻辑上说这些键不是数据集一部分，但是INFO和DBSIZE命令结果包含这些信息。</li>
<li>当从实例读取主实例生成的RDB文件时，过期键不会被载入。</li>
</ul>
<p>为很多键设置过期属性，通常为用户提供了在从实例上存储更少键，但是实际上实例内容没有逻辑区别。</p>
<h2 id="Redis实际含义是什么？"><a href="#Redis实际含义是什么？" class="headerlink" title="*Redis实际含义是什么？"></a>*Redis实际含义是什么？</h2><p>Redis是远程数据字典服务器（REmote DIctionary Server）。</p>
<h2 id="为什么启动Redis项目？"><a href="#为什么启动Redis项目？" class="headerlink" title="为什么启动Redis项目？"></a>为什么启动Redis项目？</h2><p>最初启动Redis，是为了扩大LLOOGG。但是当我完成了基本服务端工作后，我喜欢把这个想法分享给其他人，然后Redis转变成开源项目。</p>
<h2 id="Redis-如何发音？"><a href="#Redis-如何发音？" class="headerlink" title="Redis 如何发音？"></a>Redis 如何发音？</h2><p>Redis 读作颜色的”red”，然后是 “iss”。</p>

<div class="article-footer fs14"></div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">回顾上一篇</div><a href="/wiki/redis/redis-vs-elasticsearch.html">Redis 和 Elasticsearch</a></div><div class="item" id="next"></div></section></div>




<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">YanHuo075</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.30.1">Stellar 1.30.1</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">redis面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRedis%EF%BC%9F"><span class="toc-text">什么是Redis？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">Redis支持的数据类型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRedis%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9FRedis%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9A%E5%88%9A%E4%B8%8A%E9%9D%A2%E4%BD%A0%E6%9C%89%E6%8F%90%E5%88%B0redis%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-RESP-%EF%BC%8C%E8%83%BD%E8%A7%A3%E9%87%8A%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AFRESP%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F%EF%BC%88%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E5%BE%88%E5%A4%9A%E9%9D%A2%E8%AF%95%E5%85%B6%E5%AE%9E%E9%83%BD%E6%98%AF%E8%BF%9E%E7%8E%AF%E7%82%AE%EF%BC%8C%E9%9D%A2%E8%AF%95%E5%AE%98%E5%85%B6%E5%AE%9E%E5%9C%A8%E7%AD%89%E7%9D%80%E4%BD%A0%E5%9B%9E%E7%AD%94%E5%88%B0%E8%BF%99%E4%B8%AA%E7%82%B9%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BD%A0%E7%AD%94%E4%B8%8A%E4%BA%86%E5%AF%B9%E4%BD%A0%E7%9A%84%E8%AF%84%E4%BB%B7%E5%B0%B1%E5%8F%88%E5%8A%A0%E4%BA%86%E4%B8%80%E5%88%86%EF%BC%89"><span class="toc-text">刚刚上面你有提到redis通讯协议(RESP )，能解释下什么是RESP？有什么特点？（可以看到很多面试其实都是连环炮，面试官其实在等着你回答到这个点，如果你答上了对你的评价就又加了一分）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F%EF%BC%9F%E8%AE%B2%E8%AE%B2%E5%90%84%E8%87%AA%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">Redis 有哪些架构模式？讲讲各自的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8C%E6%A7%BD%EF%BC%9F"><span class="toc-text">什么是一致性哈希算法？什么是哈希槽？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%9F"><span class="toc-text">Redis常用命令？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%87Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%B9%88%EF%BC%8C%E5%AE%83%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">使用过Redis分布式锁么，它是怎么实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%87Redis%E5%81%9A%E5%BC%82%E6%AD%A5%E9%98%9F%E5%88%97%E4%B9%88%EF%BC%8C%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">使用过Redis做异步队列么，你是怎么用的？有什么缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%9F%E4%BD%95%E5%A6%82%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-text">什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E7%94%A8%E9%80%94%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Redis的用途是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%B8%8ERedis%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-text">如何与Redis连接？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Redis的主要特点是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8ARedis%E7%9A%84%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-text">解释Redis的复制功能？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%92%8CRDBMS%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Redis和RDBMS有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E4%B8%8D%E5%90%8C%E4%BA%8E%E5%85%B6%E4%BB%96%E7%9A%84%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F"><span class="toc-text">为什么Redis不同于其他的键值存储数据库？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-text">Redis内存使用情况？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%91%E5%96%9C%E6%AC%A2Redis%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E6%93%8D%E4%BD%9C%E5%92%8C%E7%89%B9%E6%80%A7%EF%BC%8C%E4%BD%86%E6%98%AF%E4%B8%8D%E5%96%9C%E6%AC%A2%E6%89%80%E6%9C%89%E5%86%85%E5%AE%B9%E9%83%BD%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%8C%E6%88%91%E4%B8%8D%E8%83%BD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%AF%94%E5%86%85%E5%AD%98%E6%9B%B4%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E3%80%82%E6%9C%89%E8%AE%A1%E5%88%92%E6%94%B9%E5%8F%98%E5%90%97%EF%BC%9F"><span class="toc-text">我喜欢Redis的高性能操作和特性，但是不喜欢所有内容都在内存中，我不能创建一个比内存更大数据集。有计划改变吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8Redis%E5%92%8C%E7%A3%81%E7%9B%98%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E6%98%AF%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%A5%BD%E6%83%B3%E6%B3%95%EF%BC%9F"><span class="toc-text">同时使用Redis和磁盘数据库，是不是一个好想法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%B2%A1%E6%9C%89%E6%96%B9%E6%B3%95%E9%99%8D%E4%BD%8ERedis%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E7%8E%87%EF%BC%9F"><span class="toc-text">有没有方法降低Redis内存使用率？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E6%97%B6%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Redis内存不足时会发生什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E5%8D%B3%E4%BD%BF%E6%88%91%E6%9C%89%E5%BE%88%E5%A4%9A%E7%A9%BA%E9%97%B2%E5%86%85%E5%AD%98%EF%BC%8C%E5%90%8E%E5%8F%B0%E4%BF%9D%E5%AD%98%E5%A4%B1%E8%B4%A5%E6%8A%A5fork-%E9%94%99%E8%AF%AF%EF%BC%81"><span class="toc-text">在Linux系统中，即使我有很多空闲内存，后台保存失败报fork()错误！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%A3%81%E7%9B%98%E5%BF%AB%E7%85%A7%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-text">Redis磁盘快照是不是原子操作？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%8C%E6%88%91%E6%80%8E%E4%B9%88%E5%88%A9%E7%94%A8%E5%A4%9ACPU-%E6%A0%B8"><span class="toc-text">Redis是单线程的，我怎么利用多CPU&#x2F;核?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%B8%AARedis%E5%AE%9E%E4%BE%8B%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8%E5%A4%9A%E5%B0%91%E9%94%AE%EF%BC%9F%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%81%E5%88%97%E8%A1%A8%E3%80%81%E9%9B%86%E5%90%88%E5%92%8C%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E6%9C%80%E5%A4%A7%E5%8F%AF%E4%BB%A5%E5%8C%85%E5%90%AB%E5%A4%9A%E5%B0%91%E5%85%83%E7%B4%A0%EF%BC%9F"><span class="toc-text">单个Redis实例最多可以存储多少键？哈希表、列表、集合和有序集合最大可以包含多少元素？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%8E%E5%AE%9E%E4%BE%8B%E4%B8%8E%E4%B8%BB%E5%AE%9E%E4%BE%8B%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%95%B0%E9%87%8F%E9%94%AE%EF%BC%9F"><span class="toc-text">为什么从实例与主实例拥有不同数量键？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%AE%9E%E9%99%85%E5%90%AB%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">*Redis实际含义是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%90%AF%E5%8A%A8Redis%E9%A1%B9%E7%9B%AE%EF%BC%9F"><span class="toc-text">为什么启动Redis项目？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%A6%82%E4%BD%95%E5%8F%91%E9%9F%B3%EF%BC%9F"><span class="toc-text">Redis 如何发音？</span></a></li></ol></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
    tag_plugins: {
      chat: Object.assign({"api":"https://siteinfo.listentothewind.cn/api/v1"}),
    }
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js`,
    marked: `https://cdn.jsdelivr.net/npm/marked@13.0.1/lib/marked.umd.min.js`
  }
  

</script>

<script type="text/javascript">
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          utils.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }

  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')) {
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function () {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },

    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function (response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function (data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function (error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
    /********************** requestAnimationFrame ********************************/
    // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
    requestAnimationFrame: (fn) => {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      }
      window.requestAnimationFrame(fn)
    },
    dark: {},
  };

  // utils.dark.mode 当前模式 dark or light
  // utils.dark.toggle() 暗黑模式触发器
  // utils.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  utils.dark.method = {
    toggle: new RunItem(),
  };
  utils.dark = Object.assign(utils.dark, {
    push: utils.dark.method.toggle.push,
  });
</script>
<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>


<!-- required -->
<script src="/js/main.js?v=1.30.1" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    applyThemeToGiscus(theme)
  }

  const applyThemeToGiscus = (theme) => {
    theme = theme === 'auto' ? 'preferred_color_scheme' : theme

    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)
    utils.dark.mode = newTheme === 'auto' ? (window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light") : newTheme;
    utils.dark.method.toggle.start();

    const messages = {
      light: `切换到浅色模式`,
      dark: `切换到深色模式`,
      auto: `切换到跟随系统配色`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    } else {
      utils.dark.mode = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    utils.dark.method.toggle.start();
  })()
</script>


<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else if (id == 'voice') {
        ctx.voiceAudios = document.querySelectorAll('.voice>audio');
        if (ctx.voiceAudios?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            createVoiceDom(ctx.voiceAudios);
          });
        }
      } else if (id == 'video') {
        ctx.videos = document.querySelectorAll('.video>video');
        if (ctx.videos?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            videoEvents(ctx.videos);
          });
        }
      } else if (id == 'download-file') {
        ctx.files = document.querySelectorAll('.file');
        if (ctx.files?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            downloadFileEvent(ctx.files);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }

    // chat iphone time
    let phoneTimes = document.querySelectorAll('.chat .status-bar .time');

    if (phoneTimes.length > 0) {
      NowTime();
      var date = new Date();
      var sec = date.getSeconds();
      var firstAdjustInterval = setInterval(firstAdjustTime, 1000 * (60 - sec));
    }

    function firstAdjustTime() {
      NowTime();
      clearInterval(firstAdjustInterval);
      setInterval(NowTime, 1000 * 60);
    }

    function NowTime() {
      for (let i = 0; i < phoneTimes.length; ++i) {
        var timeSpan = phoneTimes[i];
        var date = new Date();
        var hour = date.getHours();
        var min = date.getMinutes();
        timeSpan.innerHTML = check(hour) + ":" + check(min);
      }
    };

    function check(val) {
      if (val < 10) {
        return ("0" + val);
      }
      return (val);
    }

    // chat quote
    const chat_quote_obverser = new IntersectionObserver((entries, observer) => {
      entries.filter((entry) => { return entry.isIntersecting }).sort((a, b) => a.intersectionRect.y !== b.intersectionRect.y ? a.intersectionRect.y - b.intersectionRect.y : a.intersectionRect.x - b.intersectionRect.x).forEach((entry, index) => {
          observer.unobserve(entry.target);
          setTimeout(() => {
            entry.target.classList.add('quote-blink');
            setTimeout(() => {
              entry.target.classList.remove('quote-blink');
            }, 1000);
          }, Math.max(100, 16) * (index + 1));
        });
    });

    var chatQuotes = document.querySelectorAll(".chat .talk .quote");
    chatQuotes.forEach((quote) => {
      quote.addEventListener('click', function () {
        var chatCellDom = document.getElementById("quote-" + quote.getAttribute("quotedCellTag"));
        if (chatCellDom) {
          var chatDiv = chatCellDom.parentElement;
          var mid = chatDiv.clientHeight / 2;
          var offsetTop = chatCellDom.offsetTop;
          if (offsetTop > mid - chatCellDom.clientHeight / 2) {
            chatDiv.scrollTo({
              top: chatCellDom.offsetTop - mid + chatCellDom.clientHeight / 2,
              behavior: "smooth"
            });
          } else {
            chatDiv.scrollTo({
              top: 0,
              behavior: "smooth"
            });
          }
          chat_quote_obverser.observe(chatCellDom);
        }
      });
    });
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
<script>var posts=["2025/06/09/hello-world/","2025/06/13/2025/06/Typora-Github-PicGo/","2025/06/09/2025/06/theme-design1/","2025/06/09/2025/06/theme-design2/"];function toRandomPost(){ window.pjax ? pjax.loadUrl('/'+posts[Math.floor(Math.random()*posts.length)]) : window.open('/'+posts[Math.floor(Math.random()*posts.length)], "_self"); };</script>